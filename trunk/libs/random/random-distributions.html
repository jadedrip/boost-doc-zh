<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Boost 随机数库：分布</title>
</head>

<body bgcolor="#FFFFFF" text="#000000">
  <h1>随机数库：分布</h1>

  <ul>
    <li><a href="#intro">简介</a></li>

    <li><a href="#synopsis">概览</a></li>

    <li><a href="#uniform_smallint"><code>uniform_smallint</code> 类模板</a></li>

    <li><a href="#uniform_int"><code>uniform_int</code> 类模板</a></li>

    <li><a href="#uniform_01"><code>uniform_01</code> 类模板</a></li>

    <li><a href="#uniform_real"><code>uniform_real</code> 类模板</a></li>

    <li><a href="#bernoulli_distribution"><code>bernoulli_distribution</code> 类模板</a></li>

    <li><a href="#geometric_distribution"><code>geometric_distribution</code> 类模板</a></li>

    <li><a href="#triangle_distribution"><code>triangle_distribution</code> 类模板</a></li>

    <li><a href="#exponential_distribution"><code>exponential_distribution</code> 类模板</a></li>

    <li><a href="#normal_distribution"><code>normal_distribution</code> 类模板</a></li>

    <li><a href="#lognormal_distribution"><code>lognormal_distribution</code> 类模板</a></li>

    <li><a href="#uniform_on_sphere"><code>uniform_on_sphere</code> 类模板</a></li>
  </ul>

  <h2><a name="intro" id="intro">简介</a></h2>

  <p>除了 <a href="random-generators.html">随机数生成器</a> 之外，本库还提供了把一种分布 (通常是生成器产生的均匀分布) 映射到另一种分布的分布函数。(译注：后面的部分中，我们有时会把“随机数生成器”更一般地称为“随机数源”。)</p>

  <p>对于某一映射通常会有多种实现方案：有的需要较多的空间和对内部随机数源的调用，而有的需要进行较多的费时的运算 (如三角函数)。以下给出的对接口的描述是与具体实现无关的；然而，如果某一实现不能覆盖特定分布的全部值域，或者不符合该分布的统计学性质，该实现是无效的。</p>

  <table border="1" summary="">
    <tr>
      <th>分布</th>

      <th>描述</th>

      <th>实例</th>
    </tr>

    <tr>
      <td><code><a href="#uniform_smallint">uniform_smallint</a></code></td>

      <td>在小整数集 (远小于内部生成器的值域) 上的离散均匀分布</td>

      <td>罐中取物</td>
    </tr>

    <tr>
      <td><code><a href="#uniform_int">uniform_int</a></code></td>

      <td>在整数集上的离散均匀分布；可能会多次调用内部生成器以获得足够多的“随机性”</td>

      <td>罐中取物</td>
    </tr>

    <tr>
      <td><code><a href="#uniform_01">uniform_01</a></code></td>

      <td>区间 [0,1) 上的连续均匀分布；此分布是其它分布的重要基础</td>

      <td>-</td>
    </tr>

    <tr>
      <td><code><a href="#uniform_real">uniform_real</a></code></td>

      <td>实数区间 [min, max) 上的连续均匀分布</td>

      <td>随机投下一木棒，其角度的弧度数是 [0, 2pi) 上的这种分布 (假设角度的分布是均匀的)</td>
    </tr>

    <tr>
      <td><code><a href=
      "#bernoulli_distribution">bernoulli_distribution</a></code></td>

      <td>伯努利试验 (Bernoulli experiment)：离散布尔分布，概率可配置</td>

      <td>投掷硬币 (p=0.5)</td>
    </tr>

    <tr>
      <td><code><a href=
      "#geometric_distribution">geometric_distribution</a></code></td>

      <td>重复伯努利试验，直到出现某一结果的试验次数</td>

      <td>抛掷骰子，记录“6”首次出现时的试验次数</td>
    </tr>

    <tr>
      <td><code><a href=
      "#triangle_distribution">triangle_distribution</a></code></td>

      <td>?</td>

      <td>?</td>
    </tr>

    <tr>
      <td><code><a href=
      "#exponential_distribution">exponential_distribution</a></code></td>

      <td>质数分布</td>

      <td>放射性物质发射 alpha 粒子的间隔时间</td>
    </tr>

    <tr>
      <td><code><a href=
      "#normal_distribution">normal_distribution</a></code></td>

      <td>无穷次重复伯努利试验的结果计数</td>

      <td>投掷硬币 10000 次，记录正面出现的次数</td>
    </tr>

    <tr>
      <td><code><a href=
      "#lognormal_distribution">lognormal_distribution</a></code></td>

      <td>对数正态分布 (lognormal distribution) (有时用于模拟)</td>

      <td>流水线工人的工作完成时间</td>
    </tr>

    <tr>
      <td><code><a href=
      "#uniform_on_sphere">uniform_on_sphere</a></code></td>

      <td>多维空间的单位球面上的均匀分布</td>

      <td>在地球 (近似看作是球体) 表面任选一点去旅游</td>
    </tr>
  </table>

  <p>分布函数的模板参数总按照下列顺序排列：</p>

  <ul>
    <li>内部随机数源</li>

    <li>If applicable, return type, with a default to a reasonable type.</li>
  </ul>

  <p><em>The distribution functions no longer satisfy the input iterator
  requirements (std:24.1.1 [lib.input.iterators]), because this is redundant
  given the Generator interface and imposes a run-time overhead on all users.
  Moreover, a Generator interface appeals to random number generation as
  being more "natural". Use an <a href=
  "../utility/iterator_adaptors.htm">iterator adaptor</a> if you need to wrap
  any of the generators in an input iterator interface.</em></p>

  <p>下面描述的所有分布函数都保存对随机数源的一个非 const 引用；因此分布函数不是 Assignable；不过它们是 CopyConstructible。复制分布函数将会复制参数值；副本和原分布函数将会使用同一内部随机数源，因此两者会从同一序列中取得随机数。</p>

  <p>对于在 <a href="random-concepts.html">概念文档</a> 中已经给出定义的成员，在下面的描述中不会详细说明。</p>

  <h2><code>&lt;boost/random.hpp&gt;</code> 中的分布：<a name="synopsis" id="synopsis">概览</a></h2>
  <pre>
namespace boost {
  template&lt;class IntType = int&gt;
  class uniform_smallint;
  template&lt;class IntType = int&gt;
  class uniform_int;
  template&lt;class RealType = double&gt;
  class uniform_01;
  template&lt;class RealType = double&gt;
  class uniform_real;

  // discrete distributions
  template&lt;class RealType = double&gt;
  class bernoulli_distribution;
  template&lt;class IntType = int&gt;
  class geometric_distribution;

  // continuous distributions
  template&lt;class RealType = double&gt;
  class triangle_distribution;
  template&lt;class RealType = double&gt;
  class exponential_distribution;
  template&lt;class RealType = double&gt;
  class normal_distribution;
  template&lt;class RealType = double&gt;
  class lognormal_distribution;
  template&lt;class RealType = double,
    class Cont = std::vector&lt;RealType&gt; &gt;
  class uniform_on_sphere;
}
</pre>

  <h2><a name="uniform_smallint" id="uniform_smallint"><code>uniform_smallint</code> 类模板</a></h2>

  <h3>概览</h3>
  <pre>
#include &lt;<a href=
"../../boost/random/uniform_smallint.hpp">boost/random/uniform_smallint.hpp</a>&gt;

template&lt;class IntType = int&gt;
class uniform_smallint
{
public:
  typedef IntType input_type;
  typedef IntType result_type;
  static const bool has_fixed_range = false;
  uniform_smallint(IntType min, IntType max);
  result_type min() const;
  result_type max() const;
  void reset();
  template&lt;class UniformRandomNumberGenerator&gt;
  result_type operator()(UniformRandomNumberGenerator&amp; urng);
};
</pre>

  <h3>描述</h3>

  <p>分布函数 <code>uniform_smallint</code> 是 <a href="random-concepts.html#random-dist">随机分布</a> 的模型。每次调用都将返回在整数集 {min, min+1, min+2, ..., max} 上均匀分布的随机整数。它假设目的区间长度 (max-min+1) 比内部随机数源小得多，因此不考虑量子化问题。</p>

  <p>令 r<sub>out</sub>=(max-min+1) 为目的区间 (或其长度)，r<sub>base</sub> 为随机数源的区间 (或其长度)。于是对于均匀分布，r<sub>out</sub> 中任意数 i 的理论概率为 p<sub>out</sub>(i) = 1/r<sub>out</sub>。类似地，今内部随机数源产生 r<sub>base</sub> 上的均匀分布，故有 p<sub>base</sub>(i) = 1/r<sub>base</sub>。令 p<sub>out_s</sub>(i) 为 <code>uniform_smallint</code> 对应的分布函数。对 r<sub>out</sub> 中的各 i ，(p<sub>out_s</sub>(i)/p<sub>out</sub>(i) -1)<sup>2</sup> 的和应不大于 r<sub>out</sub>/r<sub>base</sub><sup>2</sup> (r<sub>base</sub> mod
  r<sub>out</sub>)(r<sub>out</sub> - r<sub>base</sub> mod
  r<sub>out</sub>)。</p>

  <p>模板参数 <code>IntType</code> 应为一类整数的值类型。</p>

  <p><em>Note:</em> The property above is the square sum of the relative
  differences in probabilities between the desired uniform distribution
  p<sub>out</sub>(i) and the generated distribution p<sub>out_s</sub>(i). The
  property can be fulfilled with the calculation (base_rng mod
  r<sub>out</sub>), as follows: Let r = r<sub>base</sub> mod r<sub>out</sub>.
  The base distribution on r<sub>base</sub> is folded onto the range
  r<sub>out</sub>. The numbers i &lt; r have assigned (r<sub>base</sub> div
  r<sub>out</sub>)+1 numbers of the base distribution, the rest has only
  (r<sub>base</sub> div r<sub>out</sub>). Therefore, p<sub>out_s</sub>(i) =
  ((r<sub>base</sub> div r<sub>out</sub>)+1) / r<sub>base</sub> for i &lt; r
  and p<sub>out_s</sub>(i) = (r<sub>base</sub> div
  r<sub>out</sub>)/r<sub>base</sub> otherwise. Substituting this in the above
  sum formula leads to the desired result.</p>

  <p><em>Note:</em> The upper bound for (r<sub>base</sub> mod
  r<sub>out</sub>)(r<sub>out</sub> - r<sub>base</sub> mod r<sub>out</sub>) is
  r<sub>out</sub><sup>2</sup>/4. Regarding the upper bound for the square sum
  of the relative quantization error of
  r<sub>out</sub><sup>3</sup>/(4*r<sub>base</sub><sup>2</sup>), it seems wise
  to either choose r<sub>base</sub> so that r<sub>base</sub> &gt;
  10*r<sub>out</sub><sup>2</sup> or ensure that r<sub>base</sub> is divisible
  by r<sub>out</sub>.</p>

  <h3>成员</h3>
  <pre>
uniform_smallint(IntType min, IntType max)
</pre>

  <p><strong>效果：</strong>构建一 <code>uniform_smallint</code> 函子。<code>min</code> 和 <code>max</code> 分别为输出值域的上下界。</p>

  <h2><a name="uniform_int" id="uniform_int"><code>uniform_int</code> 类模板</a></h2>

  <h3>概览</h3>
  <pre>
#include &lt;<a href=
"../../boost/random/uniform_int.hpp">boost/random/uniform_int.hpp</a>&gt;

template&lt;class IntType = int&gt;
class uniform_int
{
public:
  typedef IntType input_type;
  typedef IntType result_type;
  static const bool has_fixed_range = false;
  explicit uniform_int(IntType min = 0, IntType max = 9);
  result_type min() const;
  result_type max() const;
  void reset();
  template&lt;class UniformRandomNumberGenerator&gt;
  result_type operator()(UniformRandomNumberGenerator&amp; urng);
  template&lt;class UniformRandomNumberGenerator&gt;
  result_type operator()(UniformRandomNumberGenerator&amp; urng, result_type n);
};
</pre>

  <h3>描述</h3>

  <p>分布函数 <code>uniform_int</code> 是 <a href="random-concepts.html#random-dist">随机分布</a> 的模型。每次调用都将返回在整数集 {min, min+1, min+2, ..., max} 上均匀分布的随机整数。</p>

  <p>模板参数 <code>IntType</code> 应为一类整数的值类型。</p>

  <h3>成员</h3>
  <pre>
    uniform_int(IntType min = 0, IntType max = 9)
</pre>

  <p><strong>需求：</strong> min &lt;= max<br>
  <strong>效果：</strong>构建一 <code>uniform_int</code> 对象。<code>min</code> 和 <code>max</code> 为分布的参数。</p>
  <pre>
    result_type min() const
</pre>

  <p><strong>返回：</strong>分布的 "min" 参数。</p>
  <pre>
    result_type max() const
</pre>

  <p><strong>返回：</strong>分布的 "max" 参数。</p>
  <pre>
    result_type operator()(UniformRandomNumberGenerator&amp; urng, result_type n)
</pre>

  <p><strong>返回：</strong>在值域 0 &lt;= x &lt; n 内均匀分布的随机数 x。<em>[注记：This allows a <code>variate_generator</code> object
  with a <code>uniform_int</code> distribution to be used with
  std::random_shuffe, see [lib.alg.random.shuffle]. ]</em></p>

  <h2><a name="uniform_01" id="uniform_01"><code>uniform_01</code> 类模板</a></h2>

  <h3>概览</h3>
  <pre>
#include &lt;<a href=
"../../boost/random/uniform_01.hpp">boost/random/uniform_01.hpp</a>&gt;

template&lt;class UniformRandomNumberGenerator, class RealType = double&gt;
class uniform_01
{
public:
  typedef UniformRandomNumberGenerator base_type;
  typedef RealType result_type;
  static const bool has_fixed_range = false;
  explicit uniform_01(base_type rng);
  result_type operator()();
  result_type min() const;
  result_type max() const;
};
</pre>

  <h3>描述</h3>

  <p>分布函数 <code>uniform_01</code> 是 <a href="random-concepts.html#random-dist">随机分布</a> 的模型。每次调用都将返回在区间 [0...1) 上均匀分布的随机浮点数。这一数值是用  <code>std::numeric_limits&lt;RealType&gt;::digits</code> 个随机二进制位构造而成的，也即浮点数的尾数全都是随机的二进制位。[<em>注记：</em>是否要使这一行为可配置？]</p>

  <p><em>警告：</em>因为偶然的历史原因，此类的构造函数取一 UniformRandomNumberGenerator，且<strong>传值</strong>。通常需要的是引用语义，从而生成器就地改变，而不是复制；如果需要引用语义，用引用类型作为 UniformRandomNumberGenerator 的模板参数。</p>

  <p>模板参数 <code>RealType</code> 应为一类浮点的值类型，支持双目运算符 +, - 和 /。<code>rng.max()-rng.min()+1</code> 的值必须在其可表示范围内。</p>

  <p><code>base_type::result_type</code> 必须为一类数字的值类型，必须支持到 <code>RealType</code> 的 <code>static_cast&lt;&gt;</code>和双目运算符 -。</p>

  <p><em>注意：</em>当前的实现是有 bug 的，因为在某些情况下不会把尾数全部填充为随机的二进制位。目前尚不知道如何把 (尚未发明的) <code>boost::bigfloat</code> 类有效地用随机位填满。可能需要一个 traits 类了。</p>

  <h3>成员</h3>
  <pre>
explicit uniform_01(base_type rng)
</pre>

  <p><strong>效果：</strong>构造一 <code>uniform_01</code> 函子，使用给定的随机数生成器作为内部随机数源。</p>

  <h2><a name="uniform_real" id="uniform_real"><code>uniform_real</code> 类模板</a></h2>

  <h3>概览</h3>
  <pre>
#include &lt;<a href=
"../../boost/random/uniform_real.hpp">boost/random/uniform_real.hpp</a>&gt;

template&lt;class RealType = double&gt;
class uniform_real
{
public:
  typedef RealType input_type;
  typedef RealType result_type;
  static const bool has_fixed_range = false;
  uniform_real(RealType min = RealType(0), RealType max = RealType(1));
  result_type min() const;
  result_type max() const;
  void reset();
  template&lt;class UniformRandomNumberGenerator&gt;
  result_type operator()(UniformRandomNumberGenerator&amp; urng);
};
</pre>

  <h3>描述</h3>

  <p>分布函数 <code>uniform_real</code> 是 <a href="random-concepts.html#random-dist">随机分布</a> 的模型。每次调用都将返回在区间 [min..max) 上均匀分布的随机浮点数。这一数值是用 <code>std::numeric_limits&lt;RealType&gt;::digits</code> 个随机二进制位，也即浮点数的尾数全都是随机的二进制位。</p>

  <p><em>注意：</em>当前的实现是有 bug 的，因为在某些情况下不会把尾数全部填充为随机的二进制位。</p>

  <h3>成员</h3>
  <pre>
    uniform_real(RealType min = RealType(0), RealType max = RealType(1))
</pre>

  <p><strong>需求：</strong> min &lt;= max<br>
  <strong>效果：</strong>构建一 <code>uniform_real</code> 对象。<code>min</code> 和 <code>max</code> 是分布的参数。</p>
  <pre>
    result_type min() const
</pre>

  <p><strong>返回：</strong>分布的 "min" 参数。</p>
  <pre>
    result_type max() const
</pre>

  <p><strong>返回：</strong>分布的 "max" 参数。</p>

  <h2><a name="bernoulli_distribution" id="bernoulli_distribution"><code>bernoulli_distribution</code> 类模板</a></h2>

  <h3>概览</h3>
  <pre>
#include &lt;<a href=
"../../boost/random/bernoulli_distribution.hpp">boost/random/bernoulli_distribution.hpp</a>&gt;

template&lt;class RealType = double&gt;
class bernoulli_distribution
{
public:
  typedef int input_type;
  typedef bool result_type;

  explicit bernoulli_distribution(const RealType&amp; p = RealType(0.5));
  RealType p() const;
  void reset();
  template&lt;class UniformRandomNumberGenerator&gt;
  result_type operator()(UniformRandomNumberGenerator&amp; urng);
};
</pre>

  <h3>描述</h3>

  <p><code>bernoulli_distribution</code> 类模板的实例是 <a href="random-concepts.html#random-dist">随机分布</a> 的模型。此分布产生 <code>bool</code> 值，概率满足 P(true) = p 且 P(false) = 1-p。p 是分布的参数。</p>

  <h3>成员</h3>
  <pre>
    bernoulli_distribution(const RealType&amp; p = RealType(0.5))
</pre>

  <p><strong>需求：</strong> 0 &lt;= p &lt;= 1<br>
  <strong>效果：</strong>构建一 <code>bernoulli_distribution</code> 对象。<code>p</code> 是分布的参数。</p>
  <pre>
    RealType p() const
</pre>

  <p><strong>返回：</strong>分布的 "p" 参数。</p>

  <h2><a name="geometric_distribution" id="geometric_distribution"><code>geometric_distribution</code> 类模板</a></h2>

  <h3>概览</h3>
  <pre>
#include &lt;<a href=
"../../boost/random/geometric_distribution.hpp">boost/random/geometric_distribution.hpp</a>&gt;

template&lt;class UniformRandomNumberGenerator, class IntType = int&gt;
class geometric_distribution
{
public:
  typedef RealType input_type;
  typedef IntType result_type;

  explicit geometric_distribution(const RealType&amp; p = RealType(0.5));
  RealType p() const;
  void reset();
  template&lt;class UniformRandomNumberGenerator&gt;
  result_type operator()(UniformRandomNumberGenerator&amp; urng);
};
</pre>

  <h3>描述</h3>

  <p><code>geometric_distribution</code> 类模板的实例是 <a href="random-concepts.html#random-dist">随机分布</a> 的模型。对整数 <em>i</em> &gt;= 1，产生 i 的概率 p(i) = (1-p) * p<sup>i-1</sup>，其中 p 是分布的参数。对 UniformRandomNumberGenerator 的每次调用应产生在 [0,1) 上均匀分布的浮点数。</p>

  <h3>成员</h3>
  <pre>
    geometric_distribution(const RealType&amp; p = RealType(0.5))
</pre>

  <p><strong>需求：</strong> 0 &lt; p &lt; 1<br>
  <strong>效果：</strong>构造一 <code>geometric_distribution</code> 对象。<code>p</code> 是分布的参数。</p>
  <pre>
   RealType p() const
</pre>

  <p><strong>返回：</strong>分布的 "p" 参数。</p>

  <h2><a name="triangle_distribution" id="triangle_distribution"><code>triangle_distribution</code> 类模板</a></h2>

  <h3>概览</h3>
  <pre>
#include &lt;<a href=
"../../boost/random/triangle_distribution.hpp">boost/random/triangle_distribution.hpp</a>&gt;

template&lt;class RealType = double&gt;
class triangle_distribution
{
public:
  typedef RealType input_type;
  typedef RealType result_type;
  triangle_distribution(result_type a, result_type b, result_type c);
  result_type a() const;
  result_type b() const;
  result_type c() const;
  void reset();
  template&lt;class UniformRandomNumberGenerator&gt;
  result_type operator()(UniformRandomNumberGenerator&amp; urng);
};
</pre>

  <h3>描述</h3>

  <p><code>triangle_distribution</code> 类模板的实例是 <a href="random-concepts.html#random-dist">随机分布</a> 的模型。返回的浮点数 <code>x</code> 满足 <code>a &lt;= x
  &lt;= c</code>; <code>x</code> 服从三角形分布，其中 <code>b</code> 为概率最大的点。对 UniformRandomNumberGenerator 的每次调用应产生在 [0,1) 上均匀分布的浮点数。</p>

  <h3>成员</h3>
  <pre>
triangle_distribution(result_type a, result_type b, result_type c)
</pre>

  <p><strong>效果：</strong>构建一 <code>triangle_distribution</code> 函子。<code>a, b, c</code> 是分布的参数。</p>

  <h2><a name="exponential_distribution" id="exponential_distribution"><code>exponential_distribution</code> 类模板</a></h2>

  <h3>概览</h3>
  <pre>
#include &lt;<a href=
"../../boost/random/exponential_distribution.hpp">boost/random/exponential_distribution.hpp</a>&gt;

template&lt;class RealType = double&gt;
class exponential_distribution
{
public:
  typedef RealType input_type;
  typedef RealType result_type;
  explicit exponential_distribution(const result_type&amp; lambda);
  RealType lambda() const;
  void reset();
  template&lt;class UniformRandomNumberGenerator&gt;
  result_type operator()(UniformRandomNumberGenerator&amp; urng);
};
</pre>

  <h3>Description</h3>

  <p>Instantiations of class template <code>exponential_distribution</code>
  model a <a href="random-concepts.html#random-dist">random distribution</a>.
  Such a distribution produces random numbers x &gt; 0 distributed with
  probability density function p(x) = lambda * exp(-lambda * x), where lambda
  is the parameter of the distribution.
  Each invocation of the UniformRandomNumberGenerator shall result in a 
  floating-point value in the range [0,1).  </p>

  <h3>Members</h3>
  <pre>
    exponential_distribution(const result_type&amp; lambda = result_type(1))
</pre>

  <p><strong>Requires:</strong> lambda &gt; 0<br>
  <strong>Effects:</strong> Constructs an
  <code>exponential_distribution</code> object with <code>rng</code> as the
  reference to the underlying source of random numbers. <code>lambda</code>
  is the parameter for the distribution.</p>
  <pre>
    RealType lambda() const
</pre>

  <p><strong>Returns:</strong> The "lambda" parameter of the
  distribution.</p>

  <h2><a name="normal_distribution" id="normal_distribution">Class template
  <code>normal_distribution</code></a></h2>

  <h3>概览</h3>
  <pre>
#include &lt;<a href=
"../../boost/random/normal_distribution.hpp">boost/random/normal_distribution.hpp</a>&gt;

template&lt;class RealType = double&gt;
class normal_distribution
{
public:
  typedef RealType input_type;
  typedef RealType result_type;
  explicit normal_distribution(const result_type&amp; mean = 0,
                               const result_type&amp; sigma = 1);
  RealType mean() const;
  RealType sigma() const;
  void reset();
  template&lt;class UniformRandomNumberGenerator&gt;
  result_type operator()(UniformRandomNumberGenerator&amp; urng);
};
</pre>

  <h3>Description</h3>

  <p>Instantiations of class template <code>normal_distribution</code> model
  a <a href="random-concepts.html#random-dist">random distribution</a>. Such
  a distribution produces random numbers x distributed with probability
  density function p(x) = 1/sqrt(2*pi*sigma) * exp(- (x-mean)<sup>2</sup> /
  (2*sigma<sup>2</sup>) ), where mean and sigma are the parameters of the
  distribution.  Each invocation of the UniformRandomNumberGenerator shall
  result in a floating-point value in the range [0,1).</p>

  <h3>Members</h3>
  <pre>
    explicit normal_distribution(const result_type&amp; mean = 0,
                                 const result_type&amp; sigma = 1);
</pre>

  <p><strong>Requires:</strong> sigma &gt; 0<br>
  <strong>Effects:</strong> Constructs a <code>normal_distribution</code>
  object; <code>mean</code> and <code>sigma</code> are the parameters for the
  distribution.</p>
  <pre>
    RealType mean() const
</pre>

  <p><strong>Returns:</strong> The "mean" parameter of the distribution.</p>
  <pre>
    RealType sigma() const
</pre>

  <p><strong>Returns:</strong> The "sigma" parameter of the distribution.</p>

  <h2><a name="lognormal_distribution" id="lognormal_distribution">Class
  template <code>lognormal_distribution</code></a></h2>

  <h3>概览</h3>
  <pre>
#include &lt;<a href=
"../../boost/random/lognormal_distribution.hpp">boost/random/lognormal_distribution.hpp</a>&gt;

template&lt;class RealType = double&gt;
class lognormal_distribution
{
public:
  typedef typename normal_distribution&lt;RealType&gt;::input_type
  typedef RealType result_type;
  explicit lognormal_distribution(const result_type&amp; mean = 1.0,
                                  const result_type&amp; sigma = 1.0);
  RealType&amp; mean() const;
  RealType&amp; sigma() const;                                 
  void reset();
  template&lt;class UniformRandomNumberGenerator&gt;
  result_type operator()(UniformRandomNumberGenerator&amp; urng);
};
</pre>

  <h3>Description</h3>

  <p>Instantiations of class template <code>lognormal_distribution</code>
  model a <a href="random-concepts.html#random-dist">random distribution</a>.
  Such a distribution produces random numbers with p(x) = 1/(x * normal_sigma
  * sqrt(2*pi)) * exp( -(log(x)-normal_mean)<sup>2</sup> /
  (2*normal_sigma<sup>2</sup>) ) for x &gt; 0, where normal_mean =
  log(mean<sup>2</sup>/sqrt(sigma<sup>2</sup> + mean<sup>2</sup>)) and
  normal_sigma = sqrt(log(1 + sigma<sup>2</sup>/mean<sup>2</sup>)).
  Each invocation of the UniformRandomNumberGenerator shall result in a
  floating-point value in the range [0,1).  </p>

  <h3>Members</h3>
  <pre>
lognormal_distribution(const result_type&amp; mean,
                       const result_type&amp; sigma)
</pre>

  <p><strong>Effects:</strong> Constructs a
  <code>lognormal_distribution</code> functor. <code>mean</code> and
  <code>sigma</code> are the mean and standard deviation of the lognormal
  distribution.</p>

  <h2><a name="uniform_on_sphere" id="uniform_on_sphere"><code>uniform_on_sphere</code> 类模板</a></h2>

  <h3>概览</h3>
  <pre>
#include &lt;<a href=
"../../boost/random/uniform_on_sphere.hpp">boost/random/uniform_on_sphere.hpp</a>&gt;

template&lt;class RealType = double,
  class Cont = std::vector&lt;RealType&gt; &gt;
class uniform_on_sphere
{
public:
  typedef RealType input_type;
  typedef Cont result_type;
  explicit uniform_on_sphere(int dim = 2);
  void reset();
  template&lt;class UniformRandomNumberGenerator&gt;
  const result_type &amp; operator()(UniformRandomNumberGenerator&amp; urng);
};
</pre>

  <h3>描述</h3>

  <p><code>uniform_on_sphere</code> 类模板的实例是 <a href="random-concepts.html#random-dist">随机分布</a> 的模型。Such a
  distribution produces random numbers uniformly distributed on the unit
  sphere of arbitrary dimension <code>dim</code>. The <code>Cont</code>
  template parameter must be a STL-like container type with
  <code>begin</code> and <code>end</code> operations returning non-const
  ForwardIterators of type <code>Cont::iterator</code>.
  Each invocation of the UniformRandomNumberGenerator shall result in a 
  floating-point value in the range [0,1).  </p>

  <h3>Members</h3>
  <pre>
explicit uniform_on_sphere(int dim = 2)
</pre>

  <p><strong>Effects:</strong> Constructs a <code>uniform_on_sphere</code>
  functor. <code>dim</code> is the dimension of the sphere.</p>
  <hr>

  <p><a href="http://validator.w3.org/check?uri=referer"><img border="0" src=
  "http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Transitional"
  height="31" width="88"></a></p>

  <p>Revised 
  <!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->05
  December, 2006<!--webbot bot="Timestamp" endspan i-checksum="38516" --></p>

  <p><i>Copyright &copy; 2000-2007 <a href=
  "http://www.boost.org/people/jens_maurer.htm">Jens Maurer</a></i></p>

  <p><i>Distributed under the Boost Software License, Version 1.0. (See
  accompanying file <a href="../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or
  copy at <a href=
  "http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</i></p>
</body>
</html>
