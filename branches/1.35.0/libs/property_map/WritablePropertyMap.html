<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
  <title>WritablePropertyMap</title>
</head>


<body alink="#ff0000" bgcolor="#ffffff" link="#0000ee" text="#000000" vlink="#551a8b">
 
<img src="../../boost.png" alt="C++ Boost" height="86" width="277"> 

<br clear="">



<h2><a name="concept:WritablePropertyMap"></a>可写 Property Map
</h2>
可读 Property Map 具有通过 <tt>put()</tt> 函数对与给定键对象相关联的值对象进行设置的能力。

<h3>强化自</h3>


<a href="../utility/CopyConstructible.html">可复制构造</a>


<h3>符号</h3>


<table>

  <tbody>
    <tr>

      <td><tt>PMap</tt></td>

      <td>一个类型，符合可写 Property Map.</td>

    </tr>

    <tr>

      <td><tt>pmap</tt></td>

      <td>类型 <tt>PMap</tt> 的一个对象</td>

    </tr>

    <tr>

      <td><tt>key</tt></td>

      <td>类型 <tt>boost::property_traits&lt;PMap&gt;::key_type</tt> 的一个对象</td>

    </tr>

    <tr>

      <td><tt>val</tt></td>

      <td>类型 <tt>boost::property_traits&lt;PMap&gt;::value_type</tt> 的一个对象</td>

    </tr>

  </tbody>
</table>


<h3>关联类型</h3>


<table border="1">


  <tbody>
    <tr>

      <td>Value Type</td>

      <td><tt>boost::property_traits&lt;PMap&gt;::value_type</tt></td>
 
      <td>属性的类型
      </td>

    </tr>


    <tr>

      <td>Key Type</td>

      <td><tt>boost::property_traits&lt;PMap&gt;::key_type</tt></td>
 
      <td>用于查找属性的键对象的类型。property map 可以依照键类型参数化，这种情况下该 typedef 可以为 <tt>void</tt>.&nbsp;
      </td>

    </tr>


    <tr>

      <td>Property Map Category </td>

      <td><tt>boost::property_traits&lt;PMap&gt;::category</tt></td>

      <td>属性的分类：可转换为 <span style="font-family: monospace;">writ</span><tt>able_property_map_tag</tt> 的类型
      </td>

    </tr>


  </tbody>
</table>



<h3>有效表达式</h3>


<table border="1">

  <tbody>
    <tr>

      <th>名字</th>
      <th>表达式</th>
      <th>返回类型</th>
      <th>描述</th>

    </tr>


    <tr>

      <td>设置属性值<a href="#1">[1]</a></td>

      <td><tt>put(pmap, key, val)</tt></td>

      <td><tt>void</tt></td>

      <td>
将 <tt>val</tt> 赋给与 <tt>k</tt> 相关联的属性
      </td>

    </tr>


  </tbody>
</table>



<h3>备注</h3>


<a name="1">[1]</a> 函数 <tt>put()</tt> 原来的名字是
<tt>set()</tt>, 但为了在使用非标准名字查找规则的编译器(Microsoft Visual C++)时避免与
<tt>std::set</tt> 类发生名字冲突，改为现在的名字。以下例子演示了这个问题。 
<pre>#include &lt;set&gt;<br>using namespace std;<br>namespace boost {<br>  void set() { }<br>}</pre>



<h3>概念检查类</h3>


<pre>  template &lt;class PMap, class Key&gt;<br>  struct WritablePropertyMapConcept<br>  {<br>    typedef typename property_traits&lt;PMap&gt;::key_type key_type;<br>    typedef typename property_traits&lt;PMap&gt;::category Category;<br>    typedef boost::writable_property_map_tag WritableTag;<br>    void constraints() {<br>      function_requires&lt; ConvertibleConcept&lt;Category, WritableTag&gt; &gt;();<br>      put(pmap, k, val);<br>    }<br>    PMap pmap;<br>    Key k;<br>    typename property_traits&lt;PMap&gt;::value_type val;<br>  };</pre>


<h3>参见</h3>


<a href="./property_map.html">Property map 概念</a><br>

<hr>
<table>

  <tbody>
    <tr valign="top">

      <td nowrap="nowrap">Copyright &copy; 2000</td>
      <td>
      <a href="../../people/jeremy_siek.htm">Jeremy Siek</a>, Univ.of Notre Dame (<a href="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</a>)
      </td>
    </tr>
  </tbody>
</table>


</body>
</html>
