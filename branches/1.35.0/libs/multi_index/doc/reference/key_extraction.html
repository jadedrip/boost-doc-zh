<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html>
<head>





  
  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">






  
  
  
  
  
  
  
  
  <title>Boost.MultiIndex Documentation - Key extraction reference</title>
  <link rel="stylesheet" href="../style.css" type="text/css">





  
  
  
  
  <link rel="start" href="../index.html">





  
  
  
  
  <link rel="prev" href="rnd_indices.html">





  
  
  
  
  <link rel="up" href="index.html">





  
  
  
  
  <link rel="next" href="../compiler_specifics.html">
</head>


<body>





<h1><img src="../../../../boost.png" alt="boost.png (6897 bytes)" align="middle" height="86" width="277">Boost.MultiIndex 键提取参考</h1>






<div class="prev_link"><a href="rnd_indices.html"><img src="../prev.gif" alt="random access indices" border="0"><br>




随机访问索引
</a></div>





<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.MultiIndex reference" border="0"><br>





Boost.MultiIndex 参考
</a></div>





<div class="next_link"><a href="../compiler_specifics.html"><img src="../next.gif" alt="compiler specifics" border="0"><br>




编译器特性
</a></div>




<br style="" clear="all">






<hr>

<h2>Contents目录</h2>






<ul>





  <li><a href="#key_extractors">键提取器</a>
    
    
    
    
    
    <ul>





      <li><a href="#chained_pointers">链式指针</a></li>





    
    
    
    
    
    </ul>





  </li>





  <li><a href="#synopsis">头文件 <code>"boost/multi_index/key_extractors.hpp"</code> 摘要</a>
  </li>





  <li><a href="#identity_synopsis">头文件 <code>"boost/multi_index/identity.hpp"</code> 摘要</a>
    
    
    
    
    
    <ul>





      <li><a href="#identity">类模板 <code>identity</code></a></li>





    
    
    
    
    
    </ul>





  </li>





  <li><a href="#member_synopsis">头文件 <code>"boost/multi_index/member.hpp"</code> 摘要</a>
    
    
    
    
    
    <ul>





      <li><a href="#member">类模板 <code>member</code></a></li>





      <li><a href="#member_offset">类模板 <code>member_offset</code></a></li>





      <li><a href="#boost_multi_index_member">宏&nbsp;<code>BOOST_MULTI_INDEX_MEMBER</code></a></li>





    
    
    
    
    
    </ul>





  </li>





  <li><a href="#mem_fun_synopsis">头文件 <code>"boost/multi_index/mem_fun.hpp"</code> 摘要</a>
    
    
    
    
    
    <ul>





      <li><a href="#const_mem_fun">类模板 <code>const_mem_fun</code></a></li>





      <li><a href="#mem_fun">类模板 <code>mem_fun</code></a></li>





      <li><a href="#const_mem_fun_explicit">类模板 <code>const_mem_fun_explicit</code></a></li>





      <li><a href="#mem_fun_explicit">类模板 <code>mem_fun_explicit</code></a></li>





      <li><a href="#boost_multi_index_const_mem_fun">宏&nbsp;<code>BOOST_MULTI_INDEX_CONST_MEM_FUN</code></a></li>





      <li><a href="#boost_multi_index_mem_fun">宏&nbsp;<code>BOOST_MULTI_INDEX_MEM_FUN</code></a></li>





    
    
    
    
    
    </ul>





  </li>





  <li><a href="#global_fun_synopsis">头文件 <code>"boost/multi_index/global_fun.hpp"</code> 摘要</a> 
  </li>
  <ul>
    <li><a href="#global_fun">类模板 <code>global_fun</code></a> </li>
  </ul>
  <li><a href="#composite_key_synopsis">头文件 <code>"boost/multi_index/composite_key.hpp"</code> 摘要</a>
    
    
    
    
    
    <ul>





      <li><a href="#composite_key">类模板 <code>composite_key</code></a></li>





      <li><a href="#composite_key_result">类模板 <code>composite_key_result</code></a></li>





      <li><a href="#ckey_result_equality">等价性</a>
        
        
        
        
        
        <ul>





          <li><a href="#composite_key_equal_to">类模板 <code>composite_key_equal_to</code></a></li>





          <li><a href="#composite_key_result_equal_to">类模板 <code>composite_key_result_equal_to</code></a></li>





          <li><a href="#equal_to_composite_key_result"><code>std::equal_to</code> 对 <code>composite_key</code> 结果的特化</a></li>





        
        
        
        
        
        </ul>





      </li>





      <li><a href="#ckey_result_comparison">比较</a>
        
        
        
        
        
        <ul>





          <li><a href="#composite_key_compare">类模板 <code>composite_key_compare</code></a></li>





          <li><a href="#composite_key_result_less">类模板 <code>composite_key_result_less</code></a></li>





          <li><a href="#composite_key_result_greater">类模板 <code>composite_key_result_greater</code></a></li>





          <li><a href="#less_composite_key_result"><code>std::less</code> 对 <code>composite_key</code> results 的特化</a></li>





          <li><a href="#greater_composite_key_result"><code>std::greater</code> 对 <code>composite_key</code> 结果的特化</a></li>





        
        
        
        
        
        </ul>





      </li>





      <li><a href="#ckey_result_hashing">散列</a>
        
        
        
        
        
        <ul>





          <li><a href="#composite_key_hash">类模板 <code>composite_key_hash</code></a></li>





          <li><a href="#composite_key_result_hash">类模板 <code>composite_key_result_hash</code></a></li>





          <li><a href="#hash_composite_key_result"><code>boost::hash</code> 对 <code>composite_key</code> 结果的特化</a></li>





        
        
        
        
        
        </ul>





      </li>





      <li><a href="#ckey_result_semantics"><code>composite_key_result 的语义</code></a></li>





    
    
    
    
    
    </ul>





  </li>





</ul>






<h2><a name="key_extractors">键提取器</a></h2>






<p>键提取类用于
<a href="indices.html#key_based_indices">key-based indices基于键的索引</a> 从 multi_index_container 的元素中取得索引键。<a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable可赋值的</code></a>
类 <code>KeyFromValue</code> 被称为类型 Type 的键提取器，如果
</p>




<ol>





  <li>类型 <code>KeyFromValue::result_type</code> 有定义,</li>





  <li><code>k1(ca)</code> 有定义且返回一个可转换为 <code>const KeyFromValue::result_type&amp;</code> 的值，</li>





  <li>如果 <code>k2</code> 是 <code>k1 的拷贝</code>, <code>k1(ca)</code> 的值与 <code>k2(ca) 相同</code>,</li>





</ol>



其中 <code>k1</code>, <code>k2</code> 的类型为<code> KeyFromValue</code>,&nbsp;<code>ca</code> 的类型为 <code>const Type&amp;</code>.


<p>另外，<code>KeyFromValue</code> 是一个 <i>读/写</i> 键提取器，如果满足以下额外条件：
</p>




<ol>





  <li><code>k1(a)</code> 有定义且返回一个可转换为 <code>KeyFromValue::result_type&amp;</code> 的值,</li>





  <li><code>const_cast&lt;const KeyFromValue::result_type&amp;&gt;(k1(a))</code>
    的值与
    <code>k1(const_cast&lt;const Type&amp;&gt;(a))</code> 相同,</li>





</ol>



其中 <code>k1</code> 的类型为 <code>const KeyFromValue</code>，<code>a</code> 的类型为 <code>Type&amp;</code>.


<p>
Boost.MultiIndex 提供了五种多用途的键提取器：
</p>




<ul>





  <li><a href="#identity"><code>identity</code></a>,</li>





  <li><a href="#member"><code>member</code></a>,</li>





  <li><a href="#const_mem_fun"><code>const_mem_fun</code></a>,</li>





  <li><a href="#mem_fun"><code>mem_fun</code></a> 和</li>





  <li><a href="#composite_key"><code>composite_key</code></a>,</li>





</ul>



以及一些替代品：
<ul>





  <li><a href="#member_offset"><code>member_offset</code></a>,</li>





  <li><a href="#const_mem_fun_explicit"><code>const_mem_fun_explicit</code></a> 和</li>





  <li><a href="#mem_fun_explicit"><code>mem_fun_explicit</code></a>,</li>





</ul>



弥补某些编译器对非类型模板参数支持的不足。


<h3><a name="chained_pointers">链式指针</a></h3>






<p>Boost.MultiIndex 提供的键提取器依照类型 Type 模板化，但不仅可用于从类型 Type 的对象中取出键值，也可以从
<a href="../../../../doc/html/ref.html">Boost.Ref</a> 所提供的引用包装或从 <code>Type</code>&nbsp;(或 <code>Type</code> 的引用包装)的链式指针取出键值: 链式指针是指满足以下条件的任意类型 <code>P</code>：对象 <code>p</code> 的类型为
<code>const P</code>
</p>




<ul>





  <li><code>*p</code> 生成一个类型为 <code>Type&amp;</code> 或
    <code>boost::reference_wrapper&lt;Type&gt;</code> 的对象, 或者</li>





  <li><code>*p</code> 生成一个 <code>Type 链式指针对象</code>,</li>





</ul>





即，链式指针为类似于指针的对象的任意组合，该指针最终可被提领为 <code>Type&amp;</code> 或
<code>boost::reference_wrapper&lt;Type&gt;</code> 的值。
<p>

</p>




<h2><a name="synopsis">头文件 </a><a href="../../../../boost/multi_index/key_extractors.hpp"><code>"boost/multi_index/key_extractors.hpp"</code></a> 摘要
</h2>






<blockquote>
  
  
  
  
  <pre><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index</span><span class="special">/</span><span class="identifier">identity</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index</span><span class="special">/</span><span class="identifier">member</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index</span><span class="special">/</span><span class="identifier">mem_fun</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multi_index</span><span class="special">/</span><span class="identifier">composite_key</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
  </pre>




</blockquote>






<p>该头文件包含了 Boost.MultiIndex 所提供的所有键提取器。
</p>






<h2>
<a name="identity_synopsis">头文件 </a><a href="../../../../boost/multi_index/identity.hpp"><code>"boost/multi_index/identity.hpp"</code></a> 摘要</h2>






<blockquote>
  
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">identity</span><span class="special">;</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>




</blockquote>






<h3><a name="identity">类模板 <code>identity</code></a></h3>






<p>
<code>identity</code> <a href="#key_extractors"><code>键提取器</code></a>
的作用就象 identity 函数对象。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">identity</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">Type</span> <span class="identifier">result_type</span><span class="special">;</span>

  <span class="comment">// only provided if const ChainedPtr&amp; is not convertible to const Type&amp;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ChainedPtr</span><span class="special">&gt;</span> <span class="identifier">Type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">ChainedPtr</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">const</span> <span class="identifier">Type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span> <br>  <span class="identifier">Type</span><span class="special">&amp;</span>       <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span> <span class="comment">// only provided if Type is non-const<br><br>  // only provided if Type is non-const</span>
  <span class="keyword">const</span> <span class="identifier">Type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">Type</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span> <br><br>  <span class="comment">// only provided if Type is const</span>
  <span class="identifier">Type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">remove_const</span><span class="special">&lt;</span><span class="identifier">Type</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span> <br><br>  <span class="identifier">Type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="identifier">Type</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>
<code>identity&lt;Type&gt;</code> 符合:
</p>




<ul>





  <li>Type 的读/写 <a href="#key_extractors"><code>键提取器</code></a>,</li>





  <li><a href="#key_extractors"><code></code></a><code>reference_wrapper&lt;const Type&gt;</code> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><code>reference_wrapper&lt;Type&gt;</code>read/write 的读/写 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><a href="#key_extractors"><code></code></a><code>const Type 的</code> <a href="key_extraction.html#chained_pointers">链式指针</a><code> </code> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><code>Type</code> <code>的</code> <a href="key_extraction.html#chained_pointers">链式指针</a><code> </code> 的读/写 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>.</li>





</ul>







<h4><code>identity</code> 的成员</h4>






<code>template&lt;typename ChainedPtr&gt; Type&amp; operator()(const ChainedPtr&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>ChainedPtr</code> 为 Type 的 <a href="#chained_pointers">链式指针</a>.<br>





  <b>返回:</b>&nbsp;<code>x 所指对象的引用。</code>
</blockquote>






<code>const Type&amp; operator()(const Type&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>x</code>.
</blockquote>






<code>Type&amp; operator()(Type&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>x</code>.
</blockquote>






<code>const Type&amp; operator()(const reference_wrapper&lt;const Type&gt;&amp; x)const;</code>
<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>x.get()</code>.
</blockquote>






<code>Type&amp; operator()(const reference_wrapper&lt;typename remove_const&lt;Type&gt;::type&gt;&amp; x)const;</code>
<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>x.get()</code>.
</blockquote>






<code>Type&amp; operator()(const reference_wrapper&lt;Type&gt;&amp; x)const;</code>
<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>x.get()</code>.
</blockquote>







<h2>
<a name="member_synopsis">头文件 </a><a href="../../../../boost/multi_index/member.hpp"><code>"boost/multi_index/member.hpp"</code></a> 摘要</h2>






<blockquote>
  
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Class</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span><span class="identifier">Type</span> <span class="identifier">Class</span><span class="special">::*</span><span class="identifier">PtrToMember</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">member</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Class</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">OffsetOfMember</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">member_offset</span><span class="special">;</span>

<span class="preprocessor">#define</span> <span class="identifier">BOOST_MULTI_INDEX_MEMBER</span><span class="special">(</span><span class="identifier">Class</span><span class="special">,</span><span class="identifier">Type</span><span class="special">,</span><span class="identifier">MemberName</span><span class="special">)</span> <b>implementation defined</b>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>




</blockquote>






<h3><a name="member">类模板 <code>member</code></a></h3>






<p>
<code>member</code> <a href="#key_extractors"><code>键提取器</code></a>
用于访问一个类的给定成员。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Class</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span><span class="identifier">Type</span> <span class="identifier">Class</span><span class="special">::*</span><span class="identifier">PtrToMember</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">member</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">Type</span> <span class="identifier">result_type</span><span class="special">;</span>

  <span class="comment">// only provided if const ChainedPtr&amp; is not convertible to const Class&amp;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ChainedPtr</span><span class="special">&gt;</span> <span class="identifier">Type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">ChainedPtr</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">const</span> <span class="identifier">Type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Class</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">Type</span><span class="special">&amp;</span>       <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Class</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span> <span class="comment">// only provided if Type is non-const</span>
  <span class="keyword">const</span> <span class="identifier">Type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">Class</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">Type</span><span class="special">&amp;</span>       <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="identifier">Class</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>
<code>模板参数 PtrToMember</code> 为特定类型<code> Class::*</code> pointer 指向要取出的成员。<code>member&lt;Class,Type,PtrToMember&gt;</code> 符合：
</p>




<ul>





  <li><code>Class</code> 的读/写 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><a href="#key_extractors"><code></code></a><code>reference_wrapper&lt;const Class&gt; 的</code> <a href="key_extraction.html#key_extractors"><code>键提取器</code></a><code></code>,</li>





  <li><code>reference_wrapper&lt;Class&gt;</code> 的读/写 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><a href="#key_extractors"><code></code></a><code>const Class</code><code> 的</code> <a href="key_extraction.html#chained_pointers">链式指针</a> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><code>Class 的</code> <a href="key_extraction.html#chained_pointers">链式指针</a> 的读/写 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>.</li>





</ul>







<h4><code>member</code> 的成员</h4>






<code>template&lt;typename ChainedPtr&gt; Type&amp; operator()(const ChainedPtr&amp; x)const;</code>
  
<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>ChainedPtr</code> 为 Type 的 <a href="#chained_pointers">链式指针</a>。<br>





  <span style="font-weight: bold;">返回</span><b>:</b> <code>x</code> 所指对象的引用。
</blockquote>






<code>const Type&amp; operator()(const Class&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>x.*PtrToMember</code>.
</blockquote>






<code>Type&amp; operator()(Class&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>x.*PtrToMember</code>.
</blockquote>






<code>const Type&amp; operator()(const reference_wrapper&lt;const Class&gt;&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>x.get().*PtrToMember</code>.
</blockquote>






<code>Type&amp; operator()(const reference_wrapper&lt;Class&gt;&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>x.get().*PtrToMember</code>.
</blockquote>






<h3><a name="member_offset">类模板 <code>member_offset</code></a></h3>






<p>有些编译器不完全支持以成员指针作为非类型模板参数。以下编译器被确认在这方面的问题：
</p>




<ul>





  <li>MSVC++ 6.0 (see 
    <a href="http://support.microsoft.com/default.aspx?scid=kb;EN-US;249045">Microsoft
    Knowledge Base article #249045</a>),</li>





  <li>MSVC++ 7.0 (not officially confirmed by Microsoft),</li>





  <li>Intel C++ 7.0/7.1 for Windows (support issue #207321),</li>





  <li>VisualAge 6.0 for AIX (internal defect #288539.)</li>





</ul>



这种情况下，<code>member_offset</code> 作为 <a href="#member"><code>member</code></a> 的替代，接受偏移量来替代成员指针。请注意，标准禁止对非POD类型使用
<code>offsetof</code>;
幸运的是，多数编译器还是接受的，所以
<code>member_offset</code> 在多数实际场合中都可以使用。


<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Class</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">OffsetOfMember</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">member_offset</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">Type</span> <span class="identifier">result_type</span><span class="special">;</span>

  <span class="comment">// only provided if const ChainedPtr&amp; is not convertible to const Class&amp;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ChainedPtr</span><span class="special">&gt;</span> <span class="identifier">Type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">ChainedPtr</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">const</span> <span class="identifier">Type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Class</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span> <br>  <span class="identifier">Type</span><span class="special">&amp;</span>       <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Class</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span> <span class="comment">// only provided if Type is non-const</span>
  <span class="keyword">const</span> <span class="identifier">Type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">Class</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">Type</span><span class="special">&amp;</span>       <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="identifier">Class</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>作为一个用例，给定以下类</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">class</span> <span class="identifier">A</span>
<span class="special">{</span>
  <span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
<span class="special">}</span>
  </pre>




</blockquote>






<p><code>member&lt;A,int,&amp;A::x&gt;</code> 可以模拟为 <code>member_offset&lt;A,int,offsetof(A,x)&gt;</code>.
</p>






<h3><a name="boost_multi_index_member">宏&nbsp;<code>BOOST_MULTI_INDEX_MEMBER</code></a></h3>






<blockquote>
  
  
  
  
  <pre><span class="identifier">BOOST_MULTI_INDEX_MEMBER</span><span class="special">(</span><span class="identifier">Class</span><span class="special">,</span><span class="identifier">Type</span><span class="special">,</span><span class="identifier">MemberName</span><span class="special">)</span>
  </pre>




</blockquote>






<p>该宏有助于在编写跨平台代码时使用 <code>member</code> 和
<code>member_offset</code>，它展开为
</p>






<blockquote>
  
  
  
  
  <pre><span class="special">::</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">member</span><span class="special">&lt;</span><span class="identifier">Class</span><span class="special">,</span><span class="identifier">Type</span><span class="special">,&amp;</span><span class="identifier">Class</span><span class="special">::</span><span class="identifier">MemberName</span><span class="special">&gt;</span>
  </pre>




</blockquote>






<p>但如果 <a href="../../../config/config.htm">Boost Configuration Library</a> 的宏 <code>BOOST_NO_POINTER_TO_MEMBER_TEMPLATE_PARAMETERS</code>
被定义，则展开为
</p>






<blockquote>
  
  
  
  
  <pre><span class="special">::</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">member_offset</span><span class="special">&lt;</span><span class="identifier">Class</span><span class="special">,</span><span class="identifier">Type</span><span class="special">,</span><span class="identifier">offsetof</span><span class="special">(</span><span class="identifier">Class</span><span class="special">,</span><span class="identifier">MemberName</span><span class="special">)&gt;</span>
  </pre>




</blockquote>






<p><br>




</p>






<h2>
<a name="mem_fun_synopsis">头文件 </a><a href="../../../../boost/multi_index/mem_fun.hpp"><code>"boost/multi_index/mem_fun.hpp"</code></a> 摘要</h2>






<blockquote>
  
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Class</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span><span class="identifier">Type</span> <span class="special">(</span><span class="identifier">Class</span><span class="special">::*</span><span class="identifier">PtrToMemberFunction</span><span class="special">)()</span><span class="keyword">const</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">const_mem_fun</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Class</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span><span class="identifier">Type</span> <span class="special">(</span><span class="identifier">Class</span><span class="special">::*</span><span class="identifier">PtrToMemberFunction</span><span class="special">)()&gt;</span>
<span class="keyword">struct</span> <span class="identifier">mem_fun</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span>
  <span class="keyword">class</span> <span class="identifier">Class</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span>
  <span class="keyword">typename</span> <span class="identifier">PtrToMemberFunctionType</span><span class="special">,</span><span class="identifier">PtrToMemberFunctionType</span> <span class="identifier">PtrToMemberFunction</span>
<span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">const_mem_fun_explicit</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span>
  <span class="keyword">class</span> <span class="identifier">Class</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span>
  <span class="keyword">typename</span> <span class="identifier">PtrToMemberFunctionType</span><span class="special">,</span><span class="identifier">PtrToMemberFunctionType</span> <span class="identifier">PtrToMemberFunction</span>
<span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">mem_fun_explicit</span><span class="special">;</span>

<span class="preprocessor">#define</span> <span class="identifier">BOOST_MULTI_INDEX_CONST_MEM_FUN</span><span class="special">(</span><span class="identifier">Class</span><span class="special">,</span><span class="identifier">Type</span><span class="special">,</span><span class="identifier">MemberFunName</span><span class="special">)</span> <span class="special">\</span>
<b>implementation defined</b>
<span class="preprocessor">#define</span> <span class="identifier">BOOST_MULTI_INDEX_MEM_FUN</span><span class="special">(</span><span class="identifier">Class</span><span class="special">,</span><span class="identifier">Type</span><span class="special">,</span><span class="identifier">MemberFunName</span><span class="special">)</span> <span class="special">\</span>
<b>implementation defined</b>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>




</blockquote>






<h3><a name="const_mem_fun">类模板 <code>const_mem_fun</code></a></h3>






<p>
<code>const_mem_fun</code> 是一个 <a href="#key_extractors"><code>键提取器</code></a>，返回对类的某个常量成员函数的调用结果作为键值。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Class</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span><span class="identifier">Type</span> <span class="special">(</span><span class="identifier">Class</span><span class="special">::*</span><span class="identifier">PtrToMemberFunction</span><span class="special">)()</span><span class="keyword">const</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">const_mem_fun</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">Type</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">result_type</span><span class="special">;</span>

  <span class="comment">// only provided if const ChainedPtr&amp; is not convertible to const Class&amp;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ChainedPtr</span><span class="special">&gt;</span> <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">ChainedPtr</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Class</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">Class</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="identifier">Class</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>模板参数 <code>PtrToMemberFunction</code> 指定了在提取时所用的常量成员函数指针，特定类型为<code> (Class::*PtrToMemberFunction)()const</code>.
<code>const_mem_fun&lt;Class,Type,PtrToMemberFunction&gt;</code> 符合:
</p>




<ul>





  <li><a href="#key_extractors"><code></code></a><code>Class</code>&nbsp;的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><a href="#key_extractors"><code></code></a><code>reference_wrapper&lt;const Class&gt;&nbsp;</code>的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><a href="#key_extractors"><code></code></a><code>reference_wrapper&lt;Class&gt;</code> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><a href="#key_extractors"><code></code></a><code>const Class</code><code> 的</code> <a href="key_extraction.html#chained_pointers">链式指针</a> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a><a href="key_extraction.html#key_extractors"><code></code></a>,</li>





  <li><a href="#key_extractors"><code></code></a><code>Class</code><code> 的</code> <a href="key_extraction.html#chained_pointers">链式指针</a> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>.</li>





</ul>







<h4><code>const_mem_fun</code> 的成员</h4>






<code>template&lt;typename ChainedPtr&gt; Type operator()(const ChainedPtr&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>ChainedPtr</code> 为 Type 的 <a href="#chained_pointers">链式指针</a>。<br>





  <span style="font-weight: bold;">返回</span><b>:</b> <code>(y.*PtrToMemberFunction)()</code>, <code>y</code> 为 <code>x 所指对象。</code>
</blockquote>






<code>Type operator()(const Class&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>(x.*PtrToMemberFunction)()</code>.
</blockquote>






<code>Type operator()(const reference_wrapper&lt;const Class&gt;&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>(x.get().*PtrToMemberFunction)()</code>.
</blockquote>






<code>Type operator()(const reference_wrapper&lt;Class&gt;&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>(x.get().*PtrToMemberFunction)()</code>.
</blockquote>






<h3><a name="mem_fun">类模板 <code>mem_fun</code></a></h3>






<p>
<code>mem_fun</code> 是一个 <a href="#key_extractors"><code>键提取器</code></a>，返回类的某个成员函数的调用结果作为键值。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Class</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span><span class="identifier">Type</span> <span class="special">(</span><span class="identifier">Class</span><span class="special">::*</span><span class="identifier">PtrToMemberFunction</span><span class="special">)()&gt;</span>
<span class="keyword">struct</span> <span class="identifier">mem_fun</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">Type</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">result_type</span><span class="special">;</span>

  <span class="comment">// only provided if ChainedPtr&amp; is not convertible to Class&amp;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ChainedPtr</span><span class="special">&gt;</span> <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">ChainedPtr</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Class</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="identifier">Class</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>模板参数 <code>PtrToMemberFunction</code> 指定了在提取时所用的成员函数指针，特定类型为<code> (Class::*PtrToMemberFunction)()</code>.&nbsp; <code>mem_fun&lt;Class,Type,PtrToMemberFunction&gt;</code> 符合:
</p>




<ul>


  <li><a href="key_extraction.html#key_extractors"><code></code></a><code>reference_wrapper&lt;Class&gt;</code> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>


  <li><a href="key_extraction.html#key_extractors"><code></code></a><code>Class</code><code> 的</code> <a href="key_extraction.html#chained_pointers">链式指针</a> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>.</li>


</ul>


<h4><code>mem_fun</code> 的成员</h4>






<code>template&lt;typename ChainedPtr&gt; Type operator()(const ChainedPtr&amp; x)const;</code>
<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>ChainedPtr</code> 为 Type 的 <a href="key_extraction.html#chained_pointers">链式指针</a>。<br>





  <span style="font-weight: bold;">返回</span><b>:</b> <code>(y.*PtrToMemberFunction)()</code>, <code>y</code> 为 <code>x 所指对象。</code></blockquote>


<code>Type operator()(Class&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>(x.*PtrToMemberFunction)()</code>.
</blockquote>






<code>Type operator()(const reference_wrapper&lt;Class&gt;&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> <code>(x.get().*PtrToMemberFunction)()</code>.
</blockquote>






<h3><a name="const_mem_fun_explicit">类模板 <code>const_mem_fun_explicit</code></a></h3>






<p>
MSVC++ 6.0 不能完全支持以常量成员函数指针作为非类型模板参数，因此 <a href="#const_mem_fun"><code>const_mem_fun</code></a> 不能用于该编译器。简单的方法是以一个额外的模板参数和来指定这些指针的类型。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span>
  <span class="keyword">class</span> <span class="identifier">Class</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span>
  <span class="keyword">typename</span> <span class="identifier">PtrToMemberFunctionType</span><span class="special">,</span><span class="identifier">PtrToMemberFunctionType</span> <span class="identifier">PtrToMemberFunction</span>
<span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">const_mem_fun_explicit</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">Type</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">result_type</span><span class="special">;</span>

  <span class="comment">// only provided if const ChainedPtr&amp; is not convertible to const Class&amp;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ChainedPtr</span><span class="special">&gt;</span> <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">ChainedPtr</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Class</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">Class</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="identifier">Class</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>
<code>const_mem_fun_explicit</code> 提供了与 <code>const_mem_fun</code> 同样的功能。例如，给定以下类型
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">struct</span> <span class="identifier">A</span>
<span class="special">{</span>
  <span class="keyword">int</span> <span class="identifier">f</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>提取器 <code>const_mem_fun&lt;A,int,&amp;A::f&gt;</code> 可替换为
<code>const_mem_fun_explicit&lt;A,int,int (A::*)()const,&amp;A::f&gt;</code>.
</p>






<h3><a name="mem_fun_explicit">类模板 <code>mem_fun_explicit</code></a></h3>






<p>与 <a href="#const_mem_fun_explicit"><code>const_mem_fun_explicit</code></a> 类似，<a href="#mem_fun"><code>mem_fun</code></a> 也有一个变种接受一个额外的参数用于指定提取所用的非常量成员函数指针的类型。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span>
  <span class="keyword">class</span> <span class="identifier">Class</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span>
  <span class="keyword">typename</span> <span class="identifier">PtrToMemberFunctionType</span><span class="special">,</span><span class="identifier">PtrToMemberFunctionType</span> <span class="identifier">PtrToMemberFunction</span>
<span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">mem_fun_explicit</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">Type</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">result_type</span><span class="special">;</span>

  <span class="comment">// only provided if ChainedPtr&amp; is not convertible to Class&amp;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ChainedPtr</span><span class="special">&gt;</span> <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">ChainedPtr</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Class</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="identifier">Class</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<h3><a name="boost_multi_index_const_mem_fun">宏&nbsp;<code>BOOST_MULTI_INDEX_CONST_MEM_FUN</code></a></h3>






<blockquote>
  
  
  
  
  <pre><span class="identifier">BOOST_MULTI_INDEX_CONST_MEM_FUN</span><span class="special">(</span><span class="identifier">Class</span><span class="special">,</span><span class="identifier">Type</span><span class="special">,</span><span class="identifier">MemberFunName</span><span class="special">)</span>
  </pre>




</blockquote>






<p>在编写跨平台代码时，使用这个宏可以在编译器不支持时用
<code>const_mem_fun_explicit</code> 替换 <code>const_mem_fun</code>. 一般情况下，该宏展开为
</p>






<blockquote>
  
  
  
  
  <pre><span class="special">::</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">const_mem_fun</span><span class="special">&lt;</span><span class="identifier">Class</span><span class="special">,</span><span class="identifier">Type</span><span class="special">,&amp;</span><span class="identifier">Class</span><span class="special">::</span><span class="identifier">MemberFunName</span><span class="special">&gt;</span>
  </pre>




</blockquote>






<p>而对于 MSVC++6.0 或更低版本，它展开为
</p>






<blockquote>
  
  
  
  
  <pre><span class="special">::</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">const_mem_fun_explicit</span><span class="special">&lt;</span>
  <span class="identifier">Class</span><span class="special">,</span><span class="identifier">Type</span><span class="special">,</span><span class="identifier">Type</span> <span class="special">(</span><span class="identifier">Class</span><span class="special">::*)()</span><span class="keyword">const</span><span class="special">,&amp;</span><span class="identifier">Class</span><span class="special">::</span><span class="identifier">MemberFunName</span>
<span class="special">&gt;</span>
  </pre>




</blockquote>






<p>
</p>







<h3><a name="boost_multi_index_mem_fun">宏&nbsp;<code>BOOST_MULTI_INDEX_MEM_FUN</code></a></h3>






<blockquote>
  
  
  
  
  <pre><span class="identifier">BOOST_MULTI_INDEX_MEM_FUN</span><span class="special">(</span><span class="identifier">Class</span><span class="special">,</span><span class="identifier">Type</span><span class="special">,</span><span class="identifier">MemberFunName</span><span class="special">)</span>
  </pre>




</blockquote>






<p>
缺省时，该宏展开为
</p>






<blockquote>
  
  
  
  
  <pre><span class="special">::</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">mem_fun</span><span class="special">&lt;</span><span class="identifier">Class</span><span class="special">,</span><span class="identifier">Type</span><span class="special">,&amp;</span><span class="identifier">Class</span><span class="special">::</span><span class="identifier">MemberFunName</span><span class="special">&gt;</span>
  </pre>




</blockquote>






<p>对于 MSVC++6.0 或更低版本，它展开为
</p>






<blockquote>
  
  
  
  
  <pre><span class="special">::</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">mem_fun_explicit</span><span class="special">&lt;</span>
  <span class="identifier">Class</span><span class="special">,</span><span class="identifier">Type</span><span class="special">,</span><span class="identifier">Type</span> <span class="special">(</span><span class="identifier">Class</span><span class="special">::*)()</span><span class="special">,&amp;</span><span class="identifier">Class</span><span class="special">::</span><span class="identifier">MemberFunName</span>
<span class="special">&gt;</span>
  </pre>




</blockquote>






<p>
</p>
<h2><a name="global_fun_synopsis">头文件 </a><a href="../../../../boost/multi_index/global_fun.hpp"><code>"boost/multi_index/global_fun.hpp"</code></a> 摘要</h2>

<blockquote>
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span><br><br><span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span><br><br><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Value</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span><span class="identifier">Type</span> <span class="special">(*</span><span class="identifier">PtrToFunction</span><span class="special">)(</span><span class="identifier">Value</span><span class="special">)&gt;</span><br><span class="keyword">struct</span> <span class="identifier">global_fun</span><span class="special">;</span><br><br><span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>
</blockquote>

<h3><a name="global_fun">类模板 <code>global_fun</code></a></h3>

<p><code>global_fun</code> 是一个 <a href="#key_extractors"><code>Key 
Extractor 键提取器</code></a>，基于一个给定的全局函数或静态成员函数，该函数以基类型为参数并返回相应的键。 </p>

<blockquote>
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Value</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Type</span><span class="special">,</span><span class="identifier">Type</span> <span class="special">(*</span><span class="identifier">PtrToFunction</span><span class="special">)(</span><span class="identifier">Value</span><span class="special">)&gt;</span><br><span class="keyword">struct</span> <span class="identifier">global_fun</span><br><span class="special">{</span><br>  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">Type</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">result_type</span><span class="special">;</span><br><br>  <span class="comment">// Only provided under the following circumstances:<br>  //   - If Value is a reference to a constant type, only provided<br>  //     when const ChainedPtr&amp; is not convertible to Value;<br>  //   - if Value is a reference to a non-const type, only provided<br>  //     when ChainedPtr&amp; is not convertible to Value;<br>  //   - else, only provided when const ChainedPtr&amp; is not<br>  //     convertible to const Value&amp;.</span><br>  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">ChainedPtr</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br>  <br>  <span class="comment">// only provided if Value is a reference type</span><br>  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Value</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><br>  <span class="comment">// only provided if Value is not a reference type</span><br>  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Value</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><br>  <span class="comment">// only provided if Value is not a reference type</span><br>  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">Value</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><br>  <span class="comment">// only provided if Value is a reference type</span><br>  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><br>    <span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><br>      <span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">Value</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><br>  <span class="comment">// only provided if Value is not a reference type or is<br>  // a reference to a constant type</span><br>  <span class="identifier">Type</span> <span class="keyword">operator</span><span class="special">()(</span><br>    <span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><br>      <span class="keyword">typename</span> <span class="identifier">remove_const</span><span class="special">&lt;</span><br>        <span class="keyword">typename</span> <span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">Value</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span><br><span class="special">};</span>
  </pre>
</blockquote>

<p><code>PtrToFunction</code> 指定某个特定函数，用于从某个 <code>BaseType</code> 提取类型 <code>Type</code> 的键。<code>global_fun</code> 支持以下函数签名： 
</p>
<ul>
  <li><code>Type f(BaseType)</code> (<code>Value</code> 为 <code>BaseType</code>), 

  </li>
  <li><code>Type f(const BaseType&amp;)</code> (<code>Value</code> 为 <code>const 
BaseType&amp;</code>), 
  </li>
  <li><code>Type f(BaseType&amp;)</code> (<code>Value</code> 为 
    <code>BaseType&amp;</code>). 
  </li>
</ul>
<code>global_fun&lt;Type,Value,PtrToFunction&gt;</code> 符合： 

<ul>
  <li><a href="#key_extractors"><code></code></a>来自 
    <code>reference_wrapper&lt;BaseType&gt;</code> 的 <a href="key_extraction.html#key_extractors"><code>Key Extractor键提取器</code></a>, 
  </li>
  <li><a href="#key_extractors"><code></code></a>来自 <code>BaseType</code> 的任何 <a href="#chained_pointers">链式指针</a> 的 <a href="key_extraction.html#key_extractors"><code>Key Extractor键提取器</code></a>。 
  </li>
</ul>
如果 <code>Value</code> 为 <code>BaseType</code> 或 <code>const 
BaseType&amp;</code>, <code>global_fun&lt;Type,Value,PtrToFunction&gt;</code> 还符合： 
<ul>
  <li><a href="#key_extractors"><code></code></a>来自
    <code>BaseType</code> 的 <a href="key_extraction.html#key_extractors"><code>Key Extractor键提取器</code></a> 
  </li>
  <li><a href="#key_extractors"><code></code></a>来自 
    <code>reference_wrapper&lt;const BaseType&gt;</code><code></code> 的 <a href="key_extraction.html#key_extractors"><code>Key Extractor键提取器</code></a>, 
  </li>
  <li><a href="#key_extractors"><code></code></a>来自 <code>const</code>&nbsp;<code>BaseType</code> 的任何 <a href="key_extraction.html#chained_pointers">链式指针</a> 的 <a href="key_extraction.html#key_extractors"><code>Key Extractor键提取器</code></a>. 
  </li>
</ul>

<p></p>

<h4><code>global_fun</code> 成员</h4>
<code>template&lt;typename 
ChainedPtr&gt; Type operator()(const ChainedPtr&amp; x)const;</code> 
<blockquote><b>要求：</b><code>ChainedPtr</code> 为
  <code>Value</code> 的 <a href="#chained_pointers">链式指针</a> 类型。<br>
  <b>返回：</b><code>PtrToFunction)(y)</code>, 其中 
  <code>y</code> 为指向 <code>x</code> 的链式指针对象。 
</blockquote>
<code>Type operator()(Value x)const;</code> 
<blockquote><b>返回：</b><code>PtrToFunction(x)</code>. 
</blockquote>
<code>Type operator()(const Value&amp; x)const;</code> 
<blockquote><b>返回：</b><code>PtrToFunction(x)</code>. 
</blockquote>
<code>Type operator()(const reference_wrapper&lt;const 
Value&gt;&amp; x)const;</code> 
<blockquote><b>返回：</b><code>PtrToFunction(x.get())</code>. 
</blockquote>
<code>Type operator()(<br>
&nbsp;&nbsp;const 
reference_wrapper&lt;remove_reference&lt;Value&gt;::type&gt;&amp; 
x)const;</code> 
<blockquote><b>返回：</b><code>PtrToFunction(x.get())</code>. 
</blockquote>
<code>Type operator()(<br>
&nbsp;&nbsp;const 
reference_wrapper&lt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;typename remove_const&lt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename 
remove_reference&lt;Value&gt;::type&gt;::type&gt;&amp; x)const;</code> 
<blockquote><b>返回：</b><code>PtrToFunction(x.get())</code>. </blockquote>






<h2>
<a name="composite_key_synopsis">头文件 </a><a href="../../../../boost/multi_index/composite_key.hpp"><code>"boost/multi_index/composite_key.hpp"</code></a> 摘要</h2>






<blockquote>
  
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">KeyFromValue0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">KeyFromValuen</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_result</span><span class="special">;</span>
  
<span class="comment">// comparison operators for composite_key_result:</span>

<span class="comment">// <b>OP</b> is any of =,&lt;,!=,&gt;,&gt;=,&lt;=</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey2</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span> <b><i>OP</i></b><span class="special">(</span>
  <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey1</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey2</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span> <b><i>OP</i></b><span class="special">(</span>
  <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span> <b><i>OP</i></b><span class="special">(</span>
  <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="comment">// equality functors:</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Pred0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Predn</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_equal_to</span><span class="special">;</span>
  
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKeyResult</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_result_equal_to</span><span class="special">;</span>

<span class="comment">// comparison functors:</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Compare0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Comparen</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_compare</span><span class="special">;</span>
  
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKeyResult</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_result_less</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKeyResult</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_result_greater</span><span class="special">;</span>

<span class="comment">// hash functors:</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Hash0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Hashn</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_hash</span><span class="special">;</span>
  
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKeyResult</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_result_hash</span><span class="special">;</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span>

<span class="special">}</span> <span class="comment">// namespace boost</span>

<span class="comment">// specializations of external functors for composite_key_result:</span>

<span class="keyword">namespace</span> <span class="identifier">std</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;</span> <span class="special">&gt;;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;</span> <span class="special">&gt;;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">greater</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;</span> <span class="special">&gt;;</span>

<span class="special">}</span> <span class="comment">// namespace std</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">hash</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;</span> <span class="special">&gt;;</span>

<span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>




</blockquote>






<h3><a name="composite_key">类模板 <code>composite_key</code></a></h3>






<p>
<code>composite_key</code> 是一个 <a href="#key_extractors"><code>键提取器</code></a>，返回多个键提取器的组合值，这些键提取器在编译期指定。返回对象的类型为
<a href="#composite_key_result">
<code>composite_key_result</code></a><code>&lt;composite_key&gt;</code>.
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">KeyFromValue0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">KeyFromValuen</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">KeyFromValue0</span><span class="special">,...,</span><span class="identifier">KeyFromValuen</span><span class="special">&gt;</span> <span class="identifier">key_extractor_tuple</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">Value</span>                                  <span class="identifier">value_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">composite_key</span><span class="special">&gt;</span>    <span class="identifier">result_type</span><span class="special">;</span>

  <span class="identifier">composite_key</span><span class="special">(</span>
    <span class="keyword">const</span> <span class="identifier">KeyFromValue0</span><span class="special">&amp;</span> <span class="identifier">k0</span><span class="special">=</span><span class="identifier">KeyFromValue0</span><span class="special">(),</span>
    <span class="special">...</span>
    <span class="keyword">const</span> <span class="identifier">KeyFromValuen</span><span class="special">&amp;</span> <span class="identifier">kn</span><span class="special">=</span><span class="identifier">KeyFromValuen</span><span class="special">());</span>

  <span class="identifier">composite_key</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">key_extractor_tuple</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>

  <span class="keyword">const</span> <span class="identifier">key_extractor_tuple</span><span class="special">&amp;</span> <span class="identifier">key_extractors</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">key_extractor_tuple</span><span class="special">&amp;</span>       <span class="identifier">key_extractors</span><span class="special">()</span>

  <span class="comment">// only provided if const ChainedPtr&amp; is not convertible to const value_type&amp;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ChainedPtr</span><span class="special">&gt;</span>
  <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">ChainedPtr</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  
  <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">reference_wrapper</span><span class="special">&lt;</span><span class="identifier">value_type</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>
<code>KeyFromValue0</code>, ... , <code>KeyFromValuen</code> 是组成组合键的各个键提取器。它们都必须是 Value 的 <a href="#key_extractors"><code>键提取器</code></a><code></code>。至少要提供一个键提取器。<code>composite_key</code> 实例中的键提取器的最大数量由实现定义。<code>composite_key</code> 在内部为每个键提取器保存了一个对象。<code>composite_key&lt;Value,KeyFromValue0,...,KeyFromValuen&gt;</code> 符合:
</p>




<ul>





  <li><a href="#key_extractors"><code></code></a><code>Value</code> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><a href="#key_extractors"><code></code></a><code>reference_wrapper&lt;const Value&gt;</code> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><a href="#key_extractors"><code></code></a><code>reference_wrapper&lt;Value&gt;</code> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><a href="#key_extractors"><code></code></a><code>const Value</code><code> 的</code> <a href="key_extraction.html#chained_pointers">链式指针</a> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>,</li>





  <li><a href="#key_extractors"><code></code></a><code>Value</code><code> 的</code> <a href="key_extraction.html#chained_pointers">链式指针</a> 的 <a href="key_extraction.html#key_extractors"><code>键提取器</code></a>。</li>





</ul>







<h4><code>composite_key</code> 的成员</h4>






<code>composite_key(<br>





&nbsp;&nbsp;const KeyFromValue0&amp; k0=KeyFromValue0(),<br>





&nbsp;&nbsp;...<br>





&nbsp;&nbsp;const KeyFromValuen&amp; kn=KeyFromValuen());
</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 构造一个 <code>composite_key</code>，保存各个键提取器对象的拷贝。
</blockquote>






<code>composite_key(const key_extractor_tuple&amp; x);</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 构造一个 <code>composite_key，保存 x 中各个键提取器的拷贝。</code>
</blockquote>






<code>const key_extractor_tuple&amp; key_extractors()const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> 一个 tuple 的常量性引用，其中持有 <code>composite_key</code> 内部保存的各个键提取器。
</blockquote>





  
<code>key_extractor_tuple&amp; key_extractors();</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> 一个 tuple 的引用，其中持有 <code>composite_key</code> 内部保存的各个键提取器。
</blockquote>






<code>template&lt;typename ChainedPtr&gt;<br>





result_type operator()(const ChainedPtr&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>ChainedPtr</code> 为 result_type 的 <a href="#chained_pointers">链式指针</a>。<br>





  <span style="font-weight: bold;">返回</span><b>:</b> 一个取决于
  <code>*this</code> 和 <code>y</code> <code>的 result_type 对象</code>, 其中 <code>y</code> 为 <code>x 所指的对象。</code>
</blockquote>






<code>result_type operator()(const value_type&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> 一个取决于
  <code>*this</code> 和 x <code>的 result_type 对象。</code>
</blockquote>






<code>result_type operator()(const reference_wrapper&lt;const value_type&gt;&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b>  一个取决于
  <code>*this</code> 和 x<code>.get()</code> <code>的 result_type 对象。</code>
</blockquote>






<code>result_type operator()(const reference_wrapper&lt;value_type&gt;&amp; x)const;</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b>  一个取决于
  <code>*this</code> 和 x<code>.get()</code> <code>的 result_type 对象。</code>
</blockquote>






<h3><a name="composite_key_result">类模板 <code>composite_key_result</code></a></h3>






<p>这是一个不透明的类型，composite_key 实例返回这个类型的值作为提取到的键。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_result</span>
<span class="special">{</span>
  <b>no public interface available</b>
<span class="special">};</span>

<span class="comment">// comparison:</span>
  
<span class="comment">// <b>OP</b> is any of =,&lt;,!=,&gt;,&gt;=,&lt;=</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey2</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span> <b><i>OP</i></b><span class="special">(</span>
  <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey1</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey2</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span> <b><i>OP</i></b><span class="special">(</span>
  <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span> <b><i>OP</i></b><span class="special">(</span>
  <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">);</span>
  </pre>




</blockquote>






<code>CompositeKey</code> 为与 <code>composite_key_result</code> 相关的 <code>composite_key</code> 实例。由组合键返回的
<code>composite_key_result</code> 类型的对象必须是<span style="font-style: italic;">临时的</span>，即它们不能被保存或复制。<code>composite_key_result</code> 并不保证符合
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">
<code>Default Constructible</code></a> 或
<a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>.
类型 <code>composite_key_result&lt;CompositeKey&gt;</code> 的每个对象都是与返回它的 <code>CompositeKey</code> 内部关联的，而 <code>CompositeKey::value_type</code> 类型的对象则被提供给组合键。


<h4><a name="ckey_result_notation">记号</a></h4>






<p>给定一个 <code>x</code>，类型为 <code>composite_key_result&lt;CompositeKey&gt;</code>,
我们有以下记号:
</p>




<ul>





  <li><code>ck(x)</code> 为与 x 相关的 <code>CompositeKey</code> 对象,</li>





  <li><code>v(x)</code> 为与 x 相关的 <code>CompositeKey::value_type</code>
    对象,</li>





  <li><code>k<sub>i</sub>(x) = ck(x).key_extractors().get&lt;i&gt;()</code>,
    即 <code>ck(x)</code> 的第 i 个键提取器,</li>





  <li><code>x<sub>i</sub> = k<sub>i</sub>(x)(v(x))</code>, 即以第 i 个键提取器从 v(x) 取出的键值,</li>





  <li><code>length(x)</code> 为&nbsp;<code>ck(x) 的键提取器数量。</code></li>





</ul>


另外，如果 <code>y</code> 是多个值的 tuple, 我们定义:
<ul>





  <li><code>y<sub>i</sub>=y.get&lt;i&gt;()</code>,</li>





  <li><code>length(y)</code> 为 <code>y</code> 的元素数量。</li>





</ul>







<h4>比较操作</h4>






<code>template&lt;typename CompositeKey1,typename CompositeKey2&gt;<br>





bool operator==(<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey1&gt;&amp; x,<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey2&gt;&amp; y);<br>





template&lt;typename CompositeKey,typename Value0,...,typename Valuen&gt;<br>





bool operator==(<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey&gt;&amp; x,<br>





&nbsp;&nbsp;const tuple&lt;Value0,...,Valuen&gt;&amp; y);<br>





template&lt;typename Value0,...,typename Valuen,typename CompositeKey&gt;<br>





bool operator==(<br>





&nbsp;&nbsp;const tuple&lt;Value0,...,Valuen&gt;&amp; x,<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey&gt;&amp; y);
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>length(x)==length(y)</code>. 表达式
  <code>x<sub>i</sub>==y<sub>i</sub></code> 对于 <code>[0,length(x))</code> 中的所有 i 有效。<br>


  <b>返回:</b> <code>true</code> 当且仅当
  
  
  
  
  <blockquote>
    <code>x<sub>i</sub>==y<sub>i</sub></code> 对于 <code>[0,length(x))</code> 中的所有 i 成立。
  </blockquote>





  <b>复杂度:</b>&nbsp;上述表达式的求值从 i==0 开始，不会执行比需要更多的键提取操作和比较操作。求值在结果能确定为 false 时就结束。
</blockquote>






<code>template&lt;typename CompositeKey1,typename CompositeKey2&gt;<br>





bool operator&lt;(<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey1&gt;&amp; x,<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey2&gt;&amp; y);<br>





template&lt;typename CompositeKey,typename Value0,...,typename Valuen&gt;<br>





bool operator&lt;(<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey&gt;&amp; x,<br>





&nbsp;&nbsp;const tuple&lt;Value0,...,Valuen&gt;&amp; y);<br>





template&lt;typename Value0,...,typename Valuen,typename CompositeKey&gt;<br>





bool operator&lt;(<br>





&nbsp;&nbsp;const tuple&lt;Value0,...,Valuen&gt;&amp; x,<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey&gt;&amp; y);
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> 表达式
  <code>x<sub>i</sub>&lt;y<sub>i</sub></code> and
  <code>y<sub>i</sub>&lt;x<sub>i</sub></code> 对于 <code>[0,length(x))</code> 中的所有 i 有效。<br>


  <b>返回:</b> <code>true</code> 当且仅当存在位于区间 <code>[0,min(length(x),length(y)))</code> 中的
  <code>j</code> 满足
  
  
  
  
  <blockquote>
    <code>!(x<sub>i</sub>&lt;y<sub>i</sub>) &amp;&amp; !(y<sub>i</sub>&lt;x<sub>i</sub>)</code>，<code>i</code> 为 <code>[0,j) 中的所有值</code>, 且<br>





    <code>&nbsp;&nbsp;x<sub>j</sub>&lt;y<sub>j</sub></code>.
  </blockquote>





  <span style="font-weight: bold;">复杂度</span><b>:</b> 上述表达式的求值从 i==0 开始，不会执行比需要更多的键提取操作和比较操作。求值在结果能确定为 false 时就结束。
</blockquote>






<code>template&lt;typename CompositeKey1,typename CompositeKey2&gt;<br>





bool operator <b><i>OP</i></b>(<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey1&gt;&amp; x,<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey2&gt;&amp; y);<br>





template&lt;typename CompositeKey,typename Value0,...,typename Valuen&gt;<br>





bool operator <b><i>OP</i></b>(<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey&gt;&amp; x,<br>





&nbsp;&nbsp;const tuple&lt;Value0,...,Valuen&gt;&amp; y);<br>





template&lt;typename Value0,...,typename Valuen,typename CompositeKey&gt;<br>





bool operator <b><i>OP</i></b>(<br>





&nbsp;&nbsp;const tuple&lt;Value0,...,Valuen&gt;&amp; x,<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey&gt;&amp; y);
</code>

<p>
(<code><b><i>OP</i></b></code> is any of <code>!=</code>, <code>&gt;</code>,
<code>&gt;=</code>, <code>&lt;=</code>.)
</p>






<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> 以下表达式有效(对于特定的
  <code><b><i>OP</i></b></code>)。<br>


  <b>返回:</b> <code>true</code> 当且仅当
  
  
  
  
  <blockquote>
    <code>!(x==y)</code> (<code><b><i>OP</i></b></code> is <code>!=</code>),<br>





    <code>&nbsp;&nbsp;y&lt;&nbsp;x&nbsp;</code> (<code><b><i>OP</i></b></code> is <code>&gt;&nbsp;</code>),<br>





    <code>!(x&lt;&nbsp;y)</code> (<code><b><i>OP</i></b></code> is <code>&gt;=</code>),<br>





    <code>!(y&lt;&nbsp;x)</code> (<code><b><i>OP</i></b></code> is <code>&lt;=</code>).
  </blockquote>





</blockquote>






<h3><a name="ckey_result_equality">等价性</a></h3>






<h4><a name="composite_key_equal_to">类模板 <code>composite_key_equal_to</code></a></h4>






<p>
<code>composite_key_equal_to</code> 测试两个
<code>composite_key_result</code> 实例之间或
<code>composite_key_result</code> 实例与 tuple 之间的等价性，测试使用内部保存的等价谓词集。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Pred0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Predn</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_equal_to</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Pred0</span><span class="special">,...,</span><span class="identifier">Predn</span><span class="special">&gt;</span> <span class="identifier">key_eq_tuple</span><span class="special">;</span>

  <span class="identifier">composite_key_equal_to</span><span class="special">(</span>
    <span class="keyword">const</span> <span class="identifier">Pred0</span><span class="special">&amp;</span> <span class="identifier">p0</span><span class="special">=</span><span class="identifier">Pred0</span><span class="special">(),</span>
    <span class="special">...</span>
    <span class="keyword">const</span> <span class="identifier">Predn</span><span class="special">&amp;</span> <span class="identifier">pn</span><span class="special">=</span><span class="identifier">Predn</span><span class="special">());</span>

  <span class="identifier">composite_key_equal_to</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">key_eq_tuple</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>

  <span class="keyword">const</span> <span class="identifier">key_eq_tuple</span><span class="special">&amp;</span> <span class="identifier">key_eqs</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">key_eq_tuple</span><span class="special">&amp;</span>       <span class="identifier">key_eqs</span><span class="special">()</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey2</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey1</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey2</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>
<code>Pred0</code>, ... , <code>Predn</code> 为 <code>composite_key_equal_to 中保存的等价谓词。它们都必须符合</code> <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">
<code>Binary Predicate</code></a>. 至少需要提供一个等价谓词。<code>composite_key_equal_to</code> 实例中的等价谓词最大数量由实现定义。<code>composite_key_equal_to</code> 是
<a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>. 如果其每个 Predi 都是 
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">
<code>Default Constructible</code></a> 则它也是 
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">
<code>Default Constructible</code></a>.
</p>






<p>注意，形式上并不要求 <code>Predi</code> 类型一定要是等价谓词。但是，只有这样 <code>composite_key_equal_to</code> 的语义才是正确定义的，有关解释请见
<a href="#ckey_result_semantics"><code>composite_key_result 的语义</code></a>。
</p>






<h4>记号</h4>






<p>以下我们使用为 <code>composite_key_result</code> 定义的相同 <a href="#ckey_result_notation">记号</a><code></code>。

</p>




<h4><code>composite_key_equal_to</code> 的成员</h4>






<code>composite_key_equal_to(<br>





&nbsp;&nbsp;const Pred0&amp; p0=Pred0(),<br>





&nbsp;&nbsp;...<br>





&nbsp;&nbsp;const Predn&amp; pn=Predn());
</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 构造一个 <code>composite_key_equal_to</code>，保存所提供的等价谓词的拷贝。
</blockquote>






<code>composite_key_equal_to(const key_eq_tuple&amp; x);</code>

<blockquote>
  <b>效果:</b> 构造一个 <code>composite_key_equal_to，保存 x 中的等价谓词的拷贝。</code>
</blockquote>






<code>const key_eq_tuple&amp; key_eqs()const;</code>

<blockquote>
  <b>返回:</b> 一个 tuple 的常量引用，持有
  <code>composite_key_equal_to</code> 内部所存的等价谓词。
</blockquote>





  
<code>key_eq_tuple&amp; key_eqs();</code>

<blockquote>
  <span style="font-weight: bold;">返回</span><b>:</b> 一个 tuple 的引用，持有
  <code>composite_key_equal_to</code> 内部所存的等价谓词。
</blockquote>






<code>
template&lt;typename CompositeKey1,typename CompositeKey2&gt;<br>





bool operator()(<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey1&gt; &amp; x,<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey2&gt; &amp; y)const;<br>





template&lt;typename CompositeKey,typename Value0,...,typename Valuen&gt;<br>





bool operator()(<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey&gt;&amp; x,<br>





&nbsp;&nbsp;const tuple&lt;Value0,...,Valuen&gt;&amp; y)const;<br>





template&lt;typename Value0,...,typename Valuen,typename CompositeKey&gt;<br>





bool operator()(<br>





&nbsp;&nbsp;const tuple&lt;Value0,...,Valuen&gt;&amp; x,<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey&gt;&amp; y)const;<br>





</code>

<blockquote>
  <b>要求:</b> <code>length(x)==length(y)</code>. 表达式
  <code>key_eqs().get&lt;i&gt;()(x<sub>i</sub>,y<sub>i</sub>)</code> 和
  <code>key_eqs().get&lt;i&gt;()(y<sub>i</sub>,x<sub>i</sub>)</code>
对于 <code>[0,length(x)) 中的所有 i 有效。<br>


  </code><span style="font-weight: bold;">返回</span><b>:</b> <code>true</code> 当且仅当 
  
  
  
  
  <blockquote>
    <code>key_eqs().get&lt;i&gt;()(x<sub>i</sub>,y<sub>i</sub>)</code> 对于 <code>[0,length(x))</code> 中的所有 i 成立。<br>





  </blockquote>





  <b>复杂度:</b> 上述表达式的求值从 i==0 开始，不会执行比需要更多的键提取操作和比较操作。求值在结果能确定为 false 时就结束。
</blockquote>






<h4><a name="composite_key_result_equal_to">类模板 <code>composite_key_result_equal_to</code></a></h4>






<p>
<code>composite_key_result_equal_to</code> 是
<code>composite_key_equal_to</code> 的一个特例，其中所有比较谓词实例化为 <code>std::equal_to</code>.
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKeyResult</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_result_equal_to</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">CompositeKeyResult</span>  <span class="identifier">first_argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">first_argument_type</span> <span class="identifier">second_argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">bool</span>                <span class="identifier">result_type</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey2</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey1</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey2</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>
<code>CompositeKeyResult</code> 必须是
<code>composite_key_result</code> 对于类型 <code>composite_key&lt;KeyFromValue0,...,KeyFromValuen&gt;</code> 的实例。
<code>composite_key_result_equal_to&lt;CompositeKeyResult&gt;::operator()</code> 等价于
<code>composite_key_equal_to&lt;Pred0,...,Predn&gt;::operator()</code>, 其中
</p>




<blockquote>
  <code>Predi = std::equal_to&lt;KeyFromValuei::result_type&gt;</code> ，<code>i = 0,...,n</code>.
</blockquote>







<p>除了
<code>composite_key_equal_to 的要求以外，</code><code>每个 Predi</code> 还必须是
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">
<code>Default Constructible</code></a>. <code>composite_key_result_equal_to</code> 是 <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">
<code>Default Constructible</code></a> 和
<a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>.
</p>






<h4><a name="equal_to_composite_key_result"><code>std::equal_to</code> 对 <code>composite_key</code> 结果的特化</a></h4>






<p>
<code>std::equal_to&lt;CompositeKeyResult&gt;</code>, 其中 <code>CompositeKeyResult</code>
为 <code>composite_key_result 的实例，具有与</code> <code>composite_key_result_equal_to&lt;CompositeKeyResult&gt;</code> 相同的接口和功能。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">std</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <br>    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span>
      <span class="identifier">CompositeKey</span><span class="special">&gt;</span>                           <span class="identifier">first_argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">first_argument_type</span>                 <span class="identifier">second_argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">bool</span>                                <span class="identifier">result_type</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey2</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey1</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey2</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>

<span class="special">}</span> <span class="comment">// namespace std</span>
  </pre>




</blockquote>






<h3><a name="ckey_result_comparison">比较</a></h3>






<h4><a name="composite_key_compare">类模板 <code>composite_key_compare</code></a></h4>






<p>
<code>composite_key_compare</code> 在 <code>composite_key_result</code>
实例间或 <code>composite_key_result</code>
实例与 tuple 间进行比较，使用内部保存的比较谓词集。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Compare0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Comparen</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_compare</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Compare0</span><span class="special">,...,</span><span class="identifier">Comparen</span><span class="special">&gt;</span> <span class="identifier">key_comp_tuple</span><span class="special">;</span>

  <span class="identifier">composite_key_compare</span><span class="special">(</span>
    <span class="keyword">const</span> <span class="identifier">Compare0</span><span class="special">&amp;</span> <span class="identifier">c0</span><span class="special">=</span><span class="identifier">Compare0</span><span class="special">(),</span>
    <span class="special">...</span>
    <span class="keyword">const</span> <span class="identifier">Comparen</span><span class="special">&amp;</span> <span class="identifier">cn</span><span class="special">=</span><span class="identifier">Comparen</span><span class="special">());</span>

  <span class="identifier">composite_key_compare</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">key_comp_tuple</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>

  <span class="keyword">const</span> <span class="identifier">key_comp_tuple</span><span class="special">&amp;</span> <span class="identifier">key_comps</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">key_comp_tuple</span><span class="special">&amp;</span>       <span class="identifier">key_comps</span><span class="special">()</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey2</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey1</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey2</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">Value</span><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">Value</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>
<code>Compare0</code>, ... , <code>Comparen</code> 为 <code>composite_key_compare</code> 中保存的比较谓词类型。它们必须是 <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">
<code>Binary Predicate二元谓词</code></a>。至少要提供一个比较谓词。一个 <code>composite_key_compare</code> 实例中的比较谓词最大数量由实现定义。<code>composite_key_compare</code> 是
<a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>.
如果其中每一个 <code>Comparei</code> 都是 
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">
<code>Default Constructible</code></a>，则它也是 
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">
<code>Default Constructible</code></a><a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code></code></a>.
</p>






<p>注意，形式上并不要求&nbsp;<code>Compare</code><code>i</code> 类型的行为一定要是比较谓词。但是，只有这样 
<code>composite_key_</code><code>compare</code> 的语义才是正确定义的，有关解释请见
<a href="#ckey_result_semantics"><code>composite_key_result的语义</code></a>.
</p>






<h4>记号</h4>






<p>以下我们使用为 <code>composite_key_result</code> 定义的相同 <a href="#ckey_result_notation">记号</a><code></code>。

</p>




<h4><code>composite_key_compare</code> 的成员</h4>






<code>composite_key_compare(<br>





&nbsp;&nbsp;const Compare0&amp; c0=Compare0(),<br>





&nbsp;&nbsp;...<br>





&nbsp;&nbsp;const Comparen&amp; cn=Comparen());
</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 构造一个 
  <code>composite_key_</code><code>compare</code>，保存所提供的比较谓词的拷贝。
</blockquote>






<code>composite_key_compare(const key_comp_tuple&amp; x);</code>

<blockquote>
  <b>效果:</b> 构造一个 <code>composite_key_</code><code>compare</code><code>，保存 x 中的等价谓词的拷贝。</code>
</blockquote>






<code>const key_comp_tuple&amp; key_comps()const;</code>

<blockquote>
  <b>返回:</b> 一个 tuple 的常量引用，持有 <code>composite_key_</code><code>compare</code> 内部所存的等价谓词。
</blockquote>





  
<code>key_comp_tuple&amp; key_comps();</code>

<blockquote>
  <b>返回:</b> 一个 tuple 的引用，持有 <code>composite_key_</code><code>compare</code> 内部所存的等价谓词。
</blockquote>






<code>
template&lt;typename CompositeKey1,typename CompositeKey2&gt;<br>





bool operator()(<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey1&gt; &amp; x,<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey2&gt; &amp; y)const;<br>





template&lt;typename CompositeKey,typename Value0,...,typename Valuen&gt;<br>





bool operator()(<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey&gt;&amp; x,<br>





&nbsp;&nbsp;const tuple&lt;Value0,...,Valuen&gt;&amp; y)const;<br>





template&lt;typename Value0,...,typename Valuen,typename CompositeKey&gt;<br>





bool operator()(<br>





&nbsp;&nbsp;const tuple&lt;Value0,...,Valuen&gt;&amp; x,<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey&gt;&amp; y)const;<br>





</code>

<blockquote>
  <b>要求:</b> 表达式 
  <code>key_comps().get&lt;i&gt;()(x<sub>i</sub>,y<sub>i</sub>)</code> 和 
  <code>key_comps().get&lt;i&gt;()(y<sub>i</sub>,x<sub>i</sub>)</code> 对于 
  <code>[0,</code><code>min(length(x),length(y))</code><code>) 中的所有 i 有效。<br>

  </code><span style="font-weight: bold;">返回</span><b>:</b> <code>true</code> 当且仅当存在某个位于区间 
  <code>[0,</code><code>min(length(x),length(y))</code><code>) 的 j，满足</code> 
  
  <blockquote><code>!key_comps().get&lt;i&gt;()(x<sub>i</sub>,y<sub>i</sub>) &amp;&amp; !key_comps().get&lt;i&gt;()(y<sub>i</sub>,x<sub>i</sub>)</code>
对于 <code>[0,j) 中的所有 i 成立</code>, 并且<br>





    <code>&nbsp;key_comps().get&lt;j&gt;()(x<sub>j</sub>,y<sub>j</sub>)</code>.<br>

  </blockquote>

  <b>复杂度:</b> 上述表达式的求值从 
i==0 开始，不会执行比需要更多的键提取操作和比较操作。求值在结果能确定为 false 时就结束。
</blockquote>






<code>
template&lt;typename CompositeKey,typename Value&gt;<br>





bool operator()(<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey&gt;&amp; x,const Value&amp; y)const;
</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b>
  
  
  
  
  <blockquote>
    
    
    
    
    <pre><span class="keyword">return</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">x</span><span class="special">,</span><span class="identifier">make_tuple</span><span class="special">(</span><span class="identifier">cref</span><span class="special">(</span><span class="identifier">y</span><span class="special">)));</span>
    </pre>




  </blockquote>




  <br>





</blockquote>






<code>
template&lt;typename Value,typename CompositeKey&gt;<br>





bool operator()(<br>





&nbsp;&nbsp;const Value&amp; x,const composite_key_result&lt;CompositeKey&gt;&amp; y)const;
</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b>
  
  
  
  
  <blockquote>
    
    
    
    
    <pre><span class="keyword">return</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">make_tuple</span><span class="special">(</span><span class="identifier">cref</span><span class="special">(</span><span class="identifier">x</span><span class="special">)),</span><span class="identifier">y</span><span class="special">);</span>
    </pre>




  </blockquote>




  <br>





</blockquote>






<h4><a name="composite_key_result_less">类模板 <code>composite_key_result_less</code></a></h4>






<p>
<code>composite_key_result_less</code> 是 <code>composite_key_</code><code>compare</code> 的一个特例，其中所有比较谓词实例化为 <code>std::less</code>.
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKeyResult</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_result_less</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">CompositeKeyResult</span>  <span class="identifier">first_argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">first_argument_type</span> <span class="identifier">second_argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">bool</span>                <span class="identifier">result_type</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey2</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey1</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey2</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">Value</span><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">Value</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>
<code>CompositeKeyResult</code> 必须是 <code>composite_key_result</code> 对于类型 
<code>composite_key&lt;KeyFromValue0,...,KeyFromValuen&gt;</code> 的实例。 
<code>composite_key_result_</code><code>less</code><code>&lt;CompositeKeyResult&gt;::operator()</code> 
等价于
<code>composite_key_compare&lt;Compare0,...,Comparen&gt;::operator()</code>, 其中
</p>




<blockquote>
  <code>Comparei = std::less&lt;KeyFromValuei::result_type&gt;</code> ，<code>i = 0,...,n</code>.
</blockquote>







<p>除了 <code>composite_key_</code><code>compare</code><code> 的要求以外，</code><code>每个 Comparei</code> 还必须是 <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default 
Constructible</code></a>. <code>composite_key_result_</code><code>less</code> 是 <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default 
Constructible</code></a> 和 <a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>.
</p>






<h4><a name="composite_key_result_greater">类模板 <code>composite_key_result_greater</code></a></h4>






<p>
<code>composite_key_result</code> 是 <code>composite_key_</code><code>compare</code> 的一个特例，其中所有比较谓词实例化为 <code>std::greater</code>.
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKeyResult</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_result_greater</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">CompositeKeyResult</span>  <span class="identifier">first_argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">first_argument_type</span> <span class="identifier">second_argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">bool</span>                <span class="identifier">result_type</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey2</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey1</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey2</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">Value</span><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">Value</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>
<code>CompositeKeyResult</code> 必须是 <code>composite_key_result</code> 对于类型 
<code>composite_key&lt;KeyFromValue0,...,KeyFromValuen&gt;</code> 的实例。 
<code>composite_key_result_</code><code>greater</code><code>&lt;CompositeKeyResult&gt;::operator()</code> 
等价于 <code>composite_key_</code><code>compare&lt;Compare0,...,Comparen&gt;</code><code>::operator()</code>, 其中
</p>




<blockquote>
  <code>Comparei = std::greater&lt;KeyFromValuei::result_type&gt;</code> ，<code>i = 0,...,n</code>.
</blockquote>







<p>除了 <code>composite_key_</code><code>compare</code><code> 的要求以外，</code><code>每个 Comparei</code> 还必须是 <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default 
Constructible</code></a>. <code>composite_key_result_</code><code>greater</code> 是 <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">
<code>Default Constructible</code></a> 和
<a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>.
</p>






<h4><a name="less_composite_key_result"><code>std::less</code> 对
<code>composite_key</code> 特化的结果</a></h4>






<p>
<code>std::less&lt;CompositeKeyResult&gt;</code>, 其中 <code>CompositeKeyResult</code> 为 <code>composite_key_result </code><code>的实例，具有与</code> 
<code>composite_key_result_</code><code>less</code><code>&lt;CompositeKeyResult&gt;</code> 相同的接口和功能。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">std</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{</span>
  <span class="keyword">typedef</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span>
      <span class="identifier">CompositeKey</span><span class="special">&gt;</span>                           <span class="identifier">first_argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">first_argument_type</span>                 <span class="identifier">second_argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">bool</span>                                <span class="identifier">result_type</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey2</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey1</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey2</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">Value</span><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">Value</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>

<span class="special">}</span> <span class="comment">// namespace std</span>
  </pre>




</blockquote>






<h4><a name="greater_composite_key_result"><code>std::greater</code> 对
<code>composite_key</code> 结果的特化</a></h4>






<p>
<code>std::greater&lt;CompositeKeyResult&gt;</code>, 其中 <code>CompositeKeyResult</code> 为 <code>composite_key_result </code><code>的实例，具有与</code> 
<code>composite_key_result_</code><code>greater</code><code>&lt;CompositeKeyResult&gt;</code> 相同的接口和功能。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">std</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">greater</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{</span>
  <span class="keyword">typedef</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span>
      <span class="identifier">CompositeKey</span><span class="special">&gt;</span>                           <span class="identifier">first_argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">first_argument_type</span>                 <span class="identifier">second_argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">bool</span>                                <span class="identifier">result_type</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey2</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey1</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey2</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">Value</span><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">Value</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
    <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>

<span class="special">}</span> <span class="comment">// namespace std</span>
  </pre>




</blockquote>






<h3><a name="ckey_result_hashing">散列</a></h3>






<h4><a name="composite_key_hash">类模板 <code>composite_key_hash</code></a></h4>






<p>
<code>composite_key_hash</code> 基于一组散列函数对 <code>composite_key_result</code>
实例生成散列值。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Hash0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Hashn</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_hash</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Hash0</span><span class="special">,...,</span><span class="identifier">Hashn</span><span class="special">&gt;</span> <span class="identifier">key_hasher_tuple</span><span class="special">;</span>

  <span class="identifier">composite_key_hash</span><span class="special">(</span>
    <span class="keyword">const</span> <span class="identifier">Hash0</span><span class="special">&amp;</span> <span class="identifier">h0</span><span class="special">=</span><span class="identifier">Hash0</span><span class="special">(),</span>
    <span class="special">...</span>
    <span class="keyword">const</span> <span class="identifier">Hashn</span><span class="special">&amp;</span> <span class="identifier">hn</span><span class="special">=</span><span class="identifier">Hashn</span><span class="special">());</span>

  <span class="identifier">composite_key_hash</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">key_hasher_tuple</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>

  <span class="keyword">const</span> <span class="identifier">key_hasher_tuple</span><span class="special">&amp;</span> <span class="identifier">key_hash_functions</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">key_hasher_tuple</span><span class="special">&amp;</span>       <span class="identifier">key_hash_functions</span><span class="special">()</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>
<code>Hash0</code>, ... , <code>Hashn</code> 为保存在 <code>composite_key_hash 中的散列函数。它们必须为</code>
<a href="http://www.sgi.com/tech/stl/UnaryFunction.html"><code>Unary Function</code></a>，返回一个类型为 <code>std::size_t</code> 的值，值位于
<code>[0, std::numeric_limits&lt;std::size_t&gt;::max())</code> 范围内。至少要提供一个散列函数。一个 <code>composite_key_hash</code> 实例中的散列函数最大数量为实现定义。<code>composite_key_hash</code> 是
<a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>.
如果其中的每个 Hashi 都是 
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">
<code>Default Constructible</code></a>，则它也是 
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">
<code>Default Constructible</code></a>.
</p>






<h4>记号</h4>






<p>以下我们使用为 <code>composite_key_result</code> 定义的相同 <a href="#ckey_result_notation">记号</a><code></code>。

</p>




<h4><code>composite_key_hash</code> 的成员</h4>






<code>composite_key_hash(<br>





&nbsp;&nbsp;const Hash0&amp; h0=Hash0(),<br>





&nbsp;&nbsp;...<br>





&nbsp;&nbsp;const Hashn&amp; hn=Hashn());
</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 构造一个 <code>composite_key_</code><code>hash</code>，保存所提供的散列函数的拷贝。
</blockquote>






<code>composite_key_hash(const key_hasher_tuple&amp; x);</code>

<blockquote>
  <b>效果:</b> 构造一个 <code>composite_key_hash</code><code>，保存 x 
中的散列函数的拷贝。</code>
</blockquote>






<code>const key_hasher_tuple&amp; key_hash_functions()const;</code>

<blockquote>
  <b>返回:</b> 一个 tuple 的常量引用，持有 <code>composite_key_</code><code>hash</code> 
内部所存的散列函数。
</blockquote>





  
<code>key_hasher_tuple&amp; key_hash_functions();</code>

<blockquote>
  <b>返回:</b> 一个 tuple 的引用，持有 <code>composite_key_</code><code>hash</code> 
内部所存的散列函数。
</blockquote>






<code>
template&lt;typename CompositeKey&gt;<br>





bool operator()(<br>





&nbsp;&nbsp;const composite_key_result&lt;CompositeKey&gt;&amp; x)const;<br>





template&lt;typename Value0,...,typename Valuen&gt;<br>





bool operator()(<br>





&nbsp;&nbsp;const tuple&lt;Value0,...,Valuen&gt;&amp; x)const;
</code>

<blockquote>
  <b>要求:</b> <code>length(x)==length(key_hash_functions())</code>. 且表达式 
  <code>key_</code><code>hash_functions</code><code>().get&lt;i&gt;()(x<sub>i</sub>)</code> 对于 
  <code>[0,</code><code>length(x)</code><code>) 中的所有 i 
有效。<br>

  </code><span style="font-weight: bold;">返回</span><b>:</b> 
  <code>一个位于</code>
  <code>[0, std::numeric_limits&lt;std::size_t&gt;::max())</code> 内的值，该值只依赖于数值 tuple
  
  
  
  
  <blockquote>
(<code>key_hash_functions().get&lt;0&gt;()(x<sub>0</sub>)</code>, ... ,
    <code>key_hash_functions().get&lt;N&gt;()(x<sub>N</sub>)</code>), 其中 <code>N=length(x)-1</code>.
  </blockquote>





</blockquote>






<h4><a name="composite_key_result_hash">类模板 <code>composite_key_result_hash</code></a></h4>






<p>
<code>composite_key_result_hash</code> 是 <code>composite_key_</code><code>hash</code> 的一个特例，其中所有散列函数实例化为&nbsp;<a href="../../../functional/hash/index.html"><code>boost::hash</code></a>.
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKeyResult</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">composite_key_result_hash</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">CompositeKeyResult</span> <span class="identifier">argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span>        <span class="identifier">result_type</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="keyword">operator</span><span class="special">()(</span>
     <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
  </pre>




</blockquote>






<p>
<code>CompositeKeyResult</code> 必须是 <code>composite_key_result</code> 对于类型 
<code>composite_key&lt;KeyFromValue0,...,KeyFromValuen&gt;</code> 的实例。 
<code>composite_key_result_</code><code>hash</code><code>&lt;CompositeKeyResult&gt;::operator()</code> 
等价于 <code>composite_key_</code><code>hash</code><code>&lt;</code><code>Hash0,...,Hashn</code><code>&gt;::operator()</code>, 
其中
</p>




<blockquote>
  <code>Hashi = boost::hash&lt;KeyFromValuei::result_type&gt;</code> ，<code>i = 0,...,n</code>.
</blockquote>







<p>除了 <code>composite_key_</code><code>hash</code><code> 的要求以外，</code><code>每个&nbsp;</code><code>Hash</code><code>i</code> 还必须是 <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default 
Constructible</code></a>. <code>composite_key_result</code><code>_hash</code> 是 <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">
<code>Default Constructible</code></a> 和
<a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>.
</p>






<h4><a name="hash_composite_key_result"></a><a href="../../../functional/hash/index.html"><code>boost::hash</code></a> 对 <code>composite_key</code> 结果的特化</h4>






<p>
<code>boost::hash&lt;CompositeKeyResult&gt;</code>, 其中 <code>CompositeKeyResult</code> 为 <code>composite_key_result 
</code><code>的实例，具有与</code> 
<code>composite_key_result_</code><code>hash</code><code>&lt;CompositeKeyResult&gt;</code> 
相同的接口和功能。
</p>






<blockquote>
  
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">hash</span><span class="special">&lt;</span><span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;</span> <span class="identifier">argument_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span>                                     <span class="identifier">result_type</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompositeKey</span><span class="special">&gt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">multi_index</span><span class="special">::</span><span class="identifier">composite_key_result</span><span class="special">&lt;</span><span class="identifier">CompositeKey</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value0</span><span class="special">,...,</span><span class="keyword">typename</span> <span class="identifier">Valuen</span><span class="special">&gt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="keyword">const</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">Value0</span><span class="special">,...,</span><span class="identifier">Valuen</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>

<span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>




</blockquote>






<h3><a name="ckey_result_semantics"><code>composite_key_result 的语义</code></a></h3>






<p><code>composite_key_result</code> 对象的等价性、比较和散列操作的设计基于以下原理：一个 <code>composite_key_result</code>
可被视为一个 "虚拟" 的 tuple,
其中每个元素对应于一个基本键提取器的结果。因此，每一个给定的操作都可以分解为多个基本操作的组合。这种映射保持了与基本操作相关的属性；例如，它定义
了一个真的等价关系，如果基本谓词可以归纳为等价关系。我们可以用以下形式方法来说明这一事实。
</p>






<p>考虑用类型 <code>Pred0</code>, ... , <code>Predn 来实例化一个</code> <code>composite_key_equal_to</code>，每个
<code>Predi</code> 可归纳为类型 Ti 的等价关系，且 <code>CompositeKey</code> 为形如
<code>composite_key&lt;Value,KeyFromValue0,...,KeyFromValuej&gt;</code> 的一个类型,
其中对于 <code>j &lt;= n</code>, 有
</p>




<blockquote>
  <code>KeyFromValuei::result_type = Ti</code>,&nbsp;<code>i = 0,...,j</code>.
</blockquote>

那么，<code>composite_key_equal_to</code> 可归纳为类型 <code>composite_key_result&lt;CompositeKey&gt; 的元素的等价关系；即两个对象是等价的，如果它的所有键提取器值都是等价的。另外，给定一个</code>
<code>composite_key_hash&lt;Hash0,...,Hashj&gt; 实例，以下类型</code>为
(<code>composite_key_hash</code>, <code>composite_key_equal_to</code>)
对于 <code>composite_key_result&lt;CompositeKey&gt; 的 </code><a href="hash_indices.html#lookup"><code>Compatible Keys兼容键</code></a>:
<blockquote>
  <code>tuple&lt;Q0,...,Qj&gt;</code>,<br>





  <code>composite_key_result&lt;composite_key&lt;K0,...,Kj&gt; &gt;</code>, 其中
  <code>Ki::result_type = Qi</code> ，<code>i = 0,...,j</code>.
</blockquote>

每个 <code>Qi</code> 要么是 <code>Ti</code>，要么是
(<code>Hashi</code>, <code>Predi</code>)
的 <a href="hash_indices.html#lookup"><code>Compatible Key兼容键</code></a>。

<p>作为比较，考虑以 <code>Compare0</code>, ... , <code>Comparen</code> 实例化一个 <code>composite_key_compare</code>，每个
<code>Comparei</code> 都是类型 Ti 的
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html"><code>严格弱序</code></a><code>。那么，对于和上述同样定义的一个</code>
<code>CompositeKey</code> 类型，<code>composite_key_compare</code> 是类型 <code>composite_key_result&lt;CompositeKey&gt; 元素的</code>
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html"><code>严格弱序</code></a><code></code>, 而且顺序的推导是字典顺的。另外，以下类型为
<code>composite_key_compare</code> 对于
<code>composite_key_result&lt;CompositeKey&gt;</code>
<a href="ord_indices.html#set_operations"><code>Compatible Keys兼容键</code></a>:
</p>




<blockquote>
  <code>tuple&lt;Q0,...,Qk&gt;</code>, <code>k &lt;= n</code><br>





  <code>composite_key_result&lt;composite_key&lt;K0,...,Kk&gt; &gt;</code>, 其中
  <code>Ki::result_type = Qi</code> ，<code>i = 0,...,k</code>.
</blockquote>
其中 
<ul>
  <li>对于 <code>i = 0,...,min(j,k)-1</code>, <code>Qi</code> 要么是 
    <code>Ti</code>，要么不会比 <code>Ti</code> <span style="font-style: italic;">更粗糙</span>(<code>Qi</code> 是 
    <code>Comparei</code> 的 
    <a href="ord_indices.html#set_operations"><code>Compatible Key兼容键</code></a> 且没有两个不同的 <code>Ti</code> 
等价于单个 <code>Qi</code>)； 
  </li>
  <li><code>Qm</code> (with <code>m = min(j,k)</code>) 要么是 <code>Tm</code>，要么是 <code>Comparem</code> 的 <a href="ord_indices.html#set_operations"><code>Compatible Key兼容键</code></a>。 </li>
</ul>
这种情况下，只对前面的&nbsp; <code>1+min(j,k)</code> 个元素进行字典序比较。


<p><code>composite_key_result 的</code>等价性和比较操作也有同样的特性。但是注意，等价性只对有相同长度的对象定义，而比较则只在较短的长度上进行。因此，x==y 所得到的等值类是 <code>!(x&lt;y)&amp;&amp;!(y&lt;x) 所得到的类的子集。</code>
</p>






<hr>

<div class="prev_link"><a href="rnd_indices.html"><img src="../prev.gif" alt="random access indices" border="0"><br>

随机访问索引
</a></div>





<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.MultiIndex reference" border="0"><br>





Boost.MultiIndex 参考
</a></div>





<div class="next_link"><a href="../compiler_specifics.html"><img src="../next.gif" alt="compiler specifics" border="0"><br>

编译器的特性
</a></div>




<br style="" clear="all">






<br>
<p>Revised August 2nd 2007</p>

<p>&copy; Copyright 2003-2007 Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz. Distributed under the Boost 
Software License, Version 1.0. (See accompanying file <a href="../../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>) 
</p>
</body>
</html>
