<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>


  
  <meta http-equiv="Content-Language" content="en-us">


  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


  
  <meta name="GENERATOR" content="Microsoft FrontPage 6.0">


  
  <meta name="ProgId" content="FrontPage.Editor.Document">


  
  <link rel="stylesheet" type="text/css" href="../../../boost.css">

  
  <title>The Boost Statechart Library - Reference</title></head>

<body link="#0000ff" vlink="#800080">


<table summary="header" border="0" cellpadding="7" cellspacing="0" width="100%">


  <tbody>


    <tr>


      <td valign="top" width="300">
      
      <h3><a href="../../../index.htm"><img alt="C++ Boost" src="../../../boost.png" border="0" height="86" width="277"></a></h3>


      </td>


      <td valign="top">
      
      <h1 align="center">Boost Statechart 库</h1>


      
      <h2 align="center">Reference 参考</h2>


      </td>


    </tr>


  
  </tbody>
</table>


<hr>
<h2>Contents 目录</h2>


<dl class="page-index">


  <dt><a href="#Concepts">Concepts 概念</a></dt>


  <dd><a href="#Scheduler">Scheduler 调度器</a></dd>


  <dd><a href="#FifoWorker">FifoWorker 先入先出工作者</a></dd>


  <dd><a href="#ExceptionTranslator">ExceptionTranslator
异常转换器</a></dd>


  <dd><a href="#StateBase">StateBase 状态基</a></dd>


  <dd><a href="#SimpleState">SimpleState 简单状态</a></dd>


  <dd><a href="#State">State 状态</a></dd>


  <dd><a href="#Event">Event 事件</a></dd>


  <dt><a href="#state_machine.hpp">state_machine.hpp</a></dt>


  <dd><a href="#ClassTemplatestate_machine">Class
template <code>state_machine</code></a></dd>


  <dt><a href="#asynchronous_state_machine.hpp">asynchronous_state_machine.hpp</a></dt>


  <dd><a href="#ClassTemplateasynchronous_state_machine">Class
template <code>asynchronous_state_machine</code></a></dd>


  <dt><a href="#event_processor.hpp">event_processor.hpp</a></dt>


  <dd><a href="#ClassTemplateevent_processor">Class
template <code>event_processor</code></a></dd>


  <dt><a href="#fifo_scheduler.hpp">fifo_scheduler.hpp</a></dt>


  <dd><a href="#ClassTemplatefifo_scheduler">Class
template <code>fifo_scheduler</code></a></dd>


  <dt><a href="#exception_translator.hpp">exception_translator.hpp</a></dt>


  <dd><a href="#ClassTemplateexception_translator">Class
template <code>exception_translator</code></a></dd>


  <dt><a href="#null_exception_translator.hpp">null_exception_translator.hpp</a></dt>


  <dd><a href="#Classnull_exception_translator">Class
    <code>null_exception_translator</code></a></dd>


  <dt>&nbsp;</dt>


  <dt><a href="#simple_state.hpp">simple_state.hpp</a></dt>


  <dd><a href="#Enumhistory_mode">Enum <code>history_mode</code></a></dd>


  <dd><a href="#ClassTemplatesimple_state">Class
template <code>simple_state</code></a></dd>


  <dt><a href="#state.hpp">state.hpp</a></dt>


  <dd><a href="#ClassTemplatestate">Class template <code>state</code></a></dd>


  <dt><a href="#shallow_history.hpp">shallow_history.hpp</a></dt>


  <dd><a href="#ClassTemplateshallow_history">Class
template <code>shallow_history</code></a></dd>


  <dt><a href="#deep_history.hpp">deep_history.hpp</a></dt>


  <dd><a href="#ClassTemplatedeep_history">Class
template <code>deep_history</code></a></dd>


  <dt>&nbsp;</dt>


  <dt><a href="#event_base.hpp">event_base.hpp</a></dt>


  <dd><a href="#Classevent_base">Class <code>event_base</code></a></dd>


  <dt><a href="#event.hpp">event.hpp</a></dt>


  <dd><a href="#ClassTemplateevent">Class template <code>event</code></a></dd>


  <dt>&nbsp;</dt>


  <dt><a href="#transition.hpp">transition.hpp</a></dt>


  <dd><a href="#ClassTemplatetransition">Class
template <code>transition</code></a></dd>


  <dt><a href="#in_state_reaction.hpp">in_state_reaction.hpp</a></dt>


  <dd><a href="#ClassTemplatein_state_reaction">Class
template in_state_reaction</a></dd>


  <dt><a href="#termination.hpp">termination.hpp</a></dt>


  <dd><a href="#ClassTemplatetermination">Class
template <code>termination</code></a></dd>


  <dt><a href="#deferral.hpp">deferral.hpp</a></dt>


  <dd><a href="#ClassTemplatedeferral">Class
template <code>deferral</code></a></dd>


  <dt><a href="#custom_reaction.hpp">custom_reaction.hpp</a></dt>


  <dd><a href="#ClassTemplatecustom_reaction">Class
template <code>custom_reaction</code></a></dd>


  <dt><a href="#result.hpp">result.hpp</a></dt>


  <dd><a href="#Classresult">Class <code>result</code></a></dd>


</dl>


<hr>
<h1><a name="Concepts" id="Concepts">Concepts
概念</a></h1>


<h2><a name="Scheduler" id="Scheduler">Scheduler</a>
concept 调度器概念</h2>


<p>A Scheduler type defines the following:<br>


调度器类型定义以下内容：</p>


<ul>


  <li>What is passed to the constructors of <code><a href="#ClassTemplateevent_processor">event_processor&lt;&gt;</a></code>
subtypes and how the lifetime of such objects is managed</li>


  <li>传递什么给 <code><a href="reference.html#ClassTemplateevent_processor">event_processor&lt;&gt;</a></code>
子类型的构造函数，以及如果管理这类对象的生存期</li>


  <li>Whether or not multiple <code>event_processor&lt;&gt;</code>
subtype objects can share the same queue and scheduler thread</li>


  <li>多个 <code>event_processor&lt;&gt;</code>
子类型对象是否可以共享同一个队列和调度线程</li>


  <li>How events are added to the schedulers' queue</li>


  <li>事件如何被加入到调度器的队列中</li>


  <li>Whether and how to wait for new events when the schedulers'
queue runs empty</li>


  <li>当调度器队列为空时，是否以及如何等待新的事件</li>


  <li>Whether and what type of locking is used to ensure
thread-safety</li>


  <li>是否使用以及使用何种类型的锁来保证线程安全</li>


  <li>Whether it is possible to queue events for no longer
existing <code>event_processor&lt;&gt;</code>
subtype objects and what happens when such an event is processed</li>


  <li>是否可以为不再存在的 <code>event_processor&lt;&gt;</code>
子类型对象进行事件排队，以及在处理此类事件时会发生什么</li>


  <li>What happens when one of the serviced <code>event_processor&lt;&gt;</code>
subtype objects propagates an exception</li>


  <li>当所服务的 <code>event_processor&lt;&gt;</code>
子类型对象之一抛出异常时，会发生什么</li>


</ul>


<p>For a Scheduler type <code>S</code> and an object
<code>cpc</code> of type <code>const
S::processor_context</code> the following expressions must be
well-formed and have the indicated results:<br>


对于一个调度器类型 <code>S</code> 以及 <code>const
S::processor_context</code> 类型的一个对象 <code>cpc</code>，
以下表达式必须是有效的，并且有所示结果：</p>


<table summary="Scheduler concept" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="24%"><b>Expression 表达式</b></td>


      <td width="25%"><b>Type 类型</b></td>


      <td width="48%"><b>Result 结果</b></td>


    </tr>


    <tr>


      <td width="24%"><code>cpc.my_scheduler()</code></td>


      <td width="25%"><code>S &amp;</code></td>


      <td width="48%">A reference to the scheduler<br>


引向调度器的一个引用</td>


    </tr>


    <tr>


      <td width="24%"><code>cpc.my_handle()</code></td>


      <td width="25%"><code>S::processor_handle</code></td>


      <td width="48%">The handle identifying the <code>event_processor&lt;&gt;</code>
subtype object<br>


标识 <code>event_processor&lt;&gt;</code> 子类型对象的句柄</td>


    </tr>


  
  </tbody>
</table>


<p>To protect against abuse, all members of <code>S::processor_context</code>
should be declared private. As a result, <code>event_processor&lt;&gt;</code>
must be a friend of <code>S::processor_context</code>.<br>


为预防滥用，<code>S::processor_context</code> 的所有成员均被声明为私有。因此，<code>event_processor&lt;&gt;</code>
必须是 <code>S::processor_context</code> 的友元。</p>


<h2><a name="FifoWorker" id="FifoWorker">FifoWorker</a>
concept 先入先出工作者概念</h2>


<p>A FifoWorker type defines the following:<br>


先入先出工作者的类型定义了以下内容：</p>


<ul>


  <li>Whether and how to wait for new work items when the
internal work queue runs empty</li>


  <li>当内部工作队列清空时，是否以及如何等待新的工作项</li>


  <li>Whether and what type of locking is used to ensure
thread-safety</li>


  <li>是否使用以及使用何种类型的锁来保证线程安全</li>


</ul>


<p>For a FifoWorker type <code>F</code>, an object <code>f</code>
of that type, a <code>const</code> object <code>cf</code>
of that type, a parameterless function object <code>w</code>
of arbitrary type and an <code>unsigned long</code> value <code>n</code>
the following expressions/statements must be well-formed and have the
indicated results:<br>


对于一个先入先出工作者类型 <code>F</code>, 该类型的一个对象 <code>f</code>,
该类型的一个 <code>const</code> 对象 <code>cf</code>,
一个任意类型的无参函数对象 <code>w</code> 以及一个 <code>unsigned
long</code> 值 <code>n</code>，以下表达式/语句必须有效，并且具有所示结果：</p>


<table summary="FifoWorker concept" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="36%"><b>Expression/Statement 表达式/语句</b></td>


      <td width="10%"><b>Type 类型</b></td>


      <td width="52%"><b>Effects/Result 作用/结果</b></td>


    </tr>


    <tr>


      <td width="36%"><code>F::work_item</code></td>


      <td width="10%"><code>boost::function0&lt;<br>


&nbsp; void &gt;</code></td>


      <td width="52%">&nbsp;</td>


    </tr>


    <tr>


      <td width="36%"><code>F()</code> or <code>F(
false )</code></td>


      <td width="10%"><code>F</code></td>


      <td width="52%">Constructs a <b>non-blocking</b>
(see below) object of the FifoWorker type. In single-threaded builds
the second expression is not well-formed<br>


构造先入先出工作者类型的一个<span style="font-weight: bold;">非阻塞</span>(见
后)对象。在单线程构建中，第二个表达式是无效的</td>


    </tr>


    <tr>


      <td width="36%"><code>F( true )</code></td>


      <td width="10%"><code>F</code></td>


      <td width="52%">Constructs a <b>blocking</b>
(see below) object of the FifoWorker type. Not well-formed in
single-threaded builds<br>


构造先入先出工作者类型的一个<span style="font-weight: bold;">阻塞</span>(见
后)对象。在单线程构建中该表达式无效</td>


    </tr>


    <tr>


      <td width="36%"><code>f.queue_work_item( w );</code></td>


      <td width="10%">&nbsp;</td>


      <td width="52%">Constructs and queues an object of
type <code>F::work_item</code>, passing <code>w</code>
as the only argument<br>


构造 <code>F::work_item</code> 类型的一个对象并排队，以 <code>w</code>
作为唯一的参数</td>


    </tr>


    <tr>


      <td width="36%"><code>f.terminate();</code></td>


      <td width="10%">&nbsp;</td>


      <td width="52%">Creates and queues an object of type
      <code>F::work_item</code> that, when later executed
in <code>operator()()</code>, leads to a modification of
internal state so that <code>terminated()</code>
henceforth returns <code>true<br>


创建</code> <code>F::work_item</code><code>
类型的一个对象并排队，稍后在</code> <code>operator()()</code><code>
中执行时，引起内部状态的改变，使得</code> <code>terminated()</code><code>
返回</code> <code>true</code></td>


    </tr>


    <tr>


      <td width="36%"><code>cf.terminated();</code></td>


      <td width="10%"><code>bool</code></td>


      <td width="52%"><code>true</code> if <code>terminate()</code>
has been called and the resulting work item has been executed in <code>operator()()</code>.
Returns <code>false</code> otherwise<br>


如果 <code>terminate()</code> 已被调用且得到的工作项已在 <code>operator()()</code>
中执行，则返回 <code>true</code>。否则返回<code>false</code>
。<br>


      <br>


      <b>Must only be called from the thread that also calls <code>operator()()<br>


      </code></b><b>必须从调用 <code>operator()()
的线程进行调用</code></b></td>


    </tr>


    <tr>


      <td width="36%"><code>f( n );</code></td>


      <td width="10%"><code>unsigned long</code></td>


      <td width="52%"> Enters a loop that, with each
cycle, dequeues and calls <code>operator()()</code> on the
oldest work item in the queue.<br>


进入一个循环，在该循环的每个周期中，将工作项从队列中取出并以之调用 <code>operator()()</code>.
      
      <p>The loop is left and the number of executed work items
returned if one or more of the following conditions are met:<br>


如果遇到以下条件中的一个或多个，循环停止并返回已执行的工作项数量：</p>


      
      <ul>


        <li><code>f.terminated() == true</code></li>


        <li>The application is single-threaded and the internal
queue is empty<br>


应用程序为单线程且内部队列为空</li>


        <li>The application is multi-threaded and the internal
queue is empty and the worker was created as non-blocking<br>


应用程序为多线程且内部队列为空且工作者是以非阻塞方式创建</li>


        <li><code>n != 0</code> and the number of
work items that have been processed since <code>operator()()</code>
was called equals <code>n</code><br>


          <code>n != 0</code> 且从 <code>operator()()</code>
被调用以来已处理的工作项数量等于 <code>n</code></li>


      
      </ul>


      
      <p>If the queue is empty and none of the above conditions
are met then the thread calling <code>operator()()</code>
is put into a wait state until <code>f.queue_work_item()</code>
is called from another thread.<br>


如果队列为空且以上条件都不满足，则调用 <code>operator()()</code>
的线程将进入等待状态，直至从另一个线程调用 <code>f.queue_work_item()</code> 为止。<br>


      <br>


      <b>Must only be called from exactly one thread</b><b><br>


必须只从一个线程进行调用</b></p>


      </td>


    </tr>


    <tr>


      <td width="36%"><code>f();</code></td>


      <td width="10%"><code>unsigned long</code></td>


      <td width="52%">Has exactly the same semantics as <code>f(
n );</code> with <code>n == 0</code> (see above)<br>


与 <code>f(
n );</code> 其中 <code>n == 0</code> (见上)具有完全相同的语义</td>


    </tr>


  
  </tbody>
</table>


<h2><a name="ExceptionTranslator" id="ExceptionTranslator">ExceptionTranslator</a>
concept 异常转换器概念</h2>


<p>An ExceptionTranslator type defines how C++ exceptions
occurring during state machine operation are translated to exception
events.<br>


异常转换器类型定义了在状态机操作期间发生的C++异常如何被转换为异常事件。</p>


<p>For an ExceptionTranslator object <code>et</code>,
a parameterless function object <code>a</code> of
arbitrary type returning <code><a href="#Classresult">result</a></code>
and a function object <code>eh</code> of arbitrary type
taking a <code>const <a href="#Classevent_base">event_base</a>
&amp;</code> parameter and returning <code><a href="#Classresult">result</a></code> the
following expression must be well-formed and have the indicated results:<br>


对于一个异常转换器对象 <code>et</code>,
一个返回 <code><a href="reference.html#Classresult">result</a></code>
的任意类型的无参函数对象 <code>a</code> 以及一个接受 <code>const <a href="reference.html#Classevent_base">event_base</a>
&amp;</code> 参数并返回 <code><a href="reference.html#Classresult">result</a></code>
的任意类型的函数对象 <code>eh</code>，以下表达式必须是有效的，并且具有所示的结果：</p>


<table summary="ExceptionTranslator concept" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="299"><b>Expression 表达式</b></td>


      <td width="101"><b>Type 类型</b></td>


      <td width="1129"><b>Effects/Result 作用/结果</b></td>


    </tr>


    <tr>


      <td width="299"><code>et( a, eh );</code></td>


      <td width="101"><code>result</code></td>


      <td width="1129">
      
      <ol>


        <li>Attempts to execute <code>return a();</code><br>


尝试执行 <code>return a();</code></li>


        <li>If <code>a()</code> propagates an
exception, the exception is caught<br>


如果 <code>a()</code>
抛出一个异常，则捕获该异常</li>


        <li>Inside the catch block calls <code>eh</code>,
passing a suitable stack-allocated model of the <a href="#Event">Event</a>
concept<br>


在 catch 块中调用 <code>eh</code>,
传入一个适当的、在栈上分配的、符合 <a href="reference.html#Event">事件</a>
概念的对象</li>


        <li>Returns the result returned by <code>eh</code><br>


返回 <code>eh</code> 返回的结果<code></code></li>


      
      </ol>


      </td>


    </tr>


  
  </tbody>
</table>


<h2><a name="StateBase" id="StateBase">StateBase</a>
concept 状态基概念</h2>


<p>A StateBase type is the common base of all states of a given
state machine type. <code>state_machine&lt;&gt;::state_base_type</code>
is a model of the StateBase concept.<br>


状态基类型是一个给定的状态机类型的所有状态的公共基类。<code>state_machine&lt;&gt;::state_base_type</code>
符合 StateBase 概念。</p>


<p>For a StateBase type <code>S</code> and a <code>const</code>
object <code>cs</code> of that type the following
expressions must be well-formed and have the indicated results:<br>


对于一个状态基类型 <code>S</code> 以及该类型的一个 <code>const</code>
对象 <code>cs</code>，以下表达式必须是有效的，并且具有所示的结果：</p>


<table summary="StateBase concept" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="26%"><b>Expression 表达式</b></td>


      <td width="12%"><b>Type 类型</b></td>


      <td width="60%"><b>Result 结果</b></td>


    </tr>


    <tr>


      <td width="26%"><code>cs.outer_state_ptr()</code></td>


      <td width="12%"><code>const S *</code></td>


      <td width="60%"><code>0</code> if <code>cs</code>
is an <a href="definitions.html#OutermostState">outermost
state</a>, a pointer to the direct outer state of <code>cs</code>
otherwise<code><br>


为 0</code> 如果 <code>cs</code>
是 <a href="definitions.html#OutermostState">最外层状态</a>，
否则为指向 <code>cs</code>
的直接外层状态的指针</td>


    </tr>


    <tr>


      <td width="25%"><code>cs.dynamic_type()</code></td>


      <td width="12%"><code>S::id_type</code></td>


      <td width="60%">A value unambiguously identifying
the most-derived type of <code>cs</code>. <code>S::id_type</code>
values are comparable with <code>operator==()</code> and <code>operator!=()</code>.
An unspecified collating order can be established with <code>std::less&lt;
S::id_type &gt;</code>. In contrast to <code>typeid(
cs )</code>, this function is available even on platforms that do
not support C++ RTTI (or have been configured to not support it)<br>


一个明确标识 <code>cs</code> 的最底层类型的值。<code>S::id_type</code>
的值可以用 <code>operator==()</code> 和 <code>operator!=()</code>
来比较。未指定的比较顺序可以由 <code>std::less&lt;
S::id_type &gt;</code> 制定。与 <code>typeid(
cs )</code> 相比，这个函数在不支持 C++ RTTI&nbsp;(或被配置为不支持它)的平台上也可以使用</td>


    </tr>


    <tr>


      <td width="25%"><code>cs.custom_dynamic_type_ptr&lt;<br>


&nbsp; Type &gt;()</code></td>


      <td width="12%"><code>const Type *</code></td>


      <td width="60%">A pointer to the custom type
identifier or <code>0</code>. If <code>!= 0</code>,
      <code>Type</code> must match the type of the
previously set pointer. This function is only available if <a href="configuration.html#ApplicationDefinedMacros">BOOST_STATECHART_USE_NATIVE_RTTI</a>
is not defined<br>


一个指向定制的类型标识符的指针或为 <code>0</code>. 如果 <code>!= 0</code>，
则 <code>Type</code> 必须与之前设置的指针类型匹配。该函数只有在 <a href="configuration.html#ApplicationDefinedMacros">BOOST_STATECHART_USE_NATIVE_RTTI</a>
未定义时有效</td>


    </tr>


  
  </tbody>
</table>


<h2><a name="SimpleState" id="SimpleState">SimpleState</a>
concept 简单状态概念</h2>


<p>A SimpleState type defines one state of a particular state
machine.<br>


简单状态类型定义了特定状态机的一个状态。</p>


<p>For a SimpleState type <code>S</code> and a
pointer <code>pS</code> pointing to an object of type <code>S</code>
allocated with <code>new</code> the following
expressions/statements must be well-formed and have the indicated
effects/results:<br>


对于一个简单状态类型 <code>S</code> 以及指向一个用 <code>new</code>
分配的 <code>S</code> 类型对象的一个指针 <code>pS</code>，以
下表达式必须有效，并且具有所示的作用/结果：</p>


<table summary="SimpleState concept" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="28%"><b>Expression/Statement 表达式/语句</b></td>


      <td width="29%"><b>Type 类型</b></td>


      <td width="42%"><b>Effects/Result/Notes
作用/结果/说明</b></td>


    </tr>


    <tr>


      <td width="28%"><code><a href="#ClassTemplatesimple_state">simple_state</a>&lt;<br>


&nbsp; S, C, I, h &gt; * pB =<br>


&nbsp;&nbsp;&nbsp; pS;</code></td>


      <td width="29%">&nbsp;</td>


      <td width="42%"><code>simple_state&lt; S,
C, I, h &gt;</code> must be an unambiguous public base of <code>S</code>.
See <code><a href="#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
documentation for the requirements and semantics of <code>C</code>,
      <code>I</code> and <code>h<br>


      </code><code>simple_state&lt; S,
C, I, h &gt;</code> 必须是 <code>S</code>
的一个明确的公有基类。有关 <code>C</code>, <code>I</code>
和 <code>h</code> 的要求和语义请见 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
的文档<code></code></td>


    </tr>


    <tr>


      <td width="28%"><code>new S()</code></td>


      <td width="29%"><code>S *</code></td>


      <td width="42%">Enters the state <code>S</code>.
Certain functions must not be called from <code>S::S()</code>,
see <a href="#ClassTemplatesimple_state"><code>simple_state&lt;&gt;</code></a>
documentation for more information<br>


进入状态 <code>S</code>.
某些函数必须不能由 <code>S::S()</code> 调用，更多信息请见 <a href="reference.html#ClassTemplatesimple_state"><code>simple_state&lt;&gt;</code></a>
的文档</td>


    </tr>


    <tr>


      <td width="28%"><code>pS-&gt;exit();</code></td>


      <td width="29%">&nbsp;</td>


      <td width="42%">Exits the state <code>S</code>
(first stage). The definition of an<code></code>
member function within models of the SimpleState concept is optional
since <code>simple_state&lt;&gt;</code> already
defines the following public member: <code>void exit() {}</code>.
      <code>exit()</code> is not called when a state is
exited while an exception is pending, see <code><a href="#simple_state::terminate">simple_state&lt;&gt;::terminate()</a></code>
for more information<br>


退出状态 <code>S</code>
(第一阶段)。符合简单状态概念的类型的 <code>exit</code> 成员函数是可选定义的，因为 <code>simple_state&lt;&gt;</code>
已经定义了以下公有成员：<code>void exit() {}</code>.
当一个状态已退出而有一个异常未决时，<code>exit()</code> 不会被调用，更多信息请见 <code><a href="reference.html#simple_state::terminate">simple_state&lt;&gt;::terminate()</a></code></td>


    </tr>


    <tr>


      <td width="28%"><code>delete pS;</code></td>


      <td width="29%">&nbsp;</td>


      <td width="42%">Exits the state <code>S</code>
(second stage)<br>


退出状态 <code>S</code>
(第二阶段)</td>


    </tr>


    <tr>


      <td width="28%"><code>S::reactions</code></td>


      <td width="29%">An <code>mpl::list&lt;&gt;</code>
that is either empty or contains instantiations of the <code><a href="#ClassTemplatecustom_reaction">custom_reaction</a></code>,
      <code><a href="#ClassTemplatein_state_reaction">in_state_reaction</a></code>,
      <code><a href="#ClassTemplatedeferral">deferral</a></code>,
      <code><a href="#ClassTemplatetermination">termination</a></code>
or <code><a href="#ClassTemplatetransition">transition</a></code>
class templates. If there is only a single reaction then it can also be
      <code>typedef</code>ed directly, without wrapping it
into an <code>mpl::list&lt;&gt;<br>


      </code>一个 <code>mpl::list&lt;&gt;</code>，
要么为空，要么包含 <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction</a></code>,
      <code><a href="reference.html#ClassTemplatein_state_reaction">in_state_reaction</a></code>,
      <code><a href="reference.html#ClassTemplatedeferral">deferral</a></code>,
      <code><a href="reference.html#ClassTemplatetermination">termination</a></code>
或 <code><a href="reference.html#ClassTemplatetransition">transition</a></code>
类模板的实例。如果只有一个反应，则它也可以直接被 <code>typedef</code>，而无需用 <code>mpl::list&lt;&gt;</code>
来包装<code></code></td>


      <td width="42%">The declaration of a <code>reactions</code>
member <code>typedef</code> within models of the
SimpleState concept is optional since <code>simple_state&lt;&gt;</code>
already defines the following public member: <code>typedef
mpl::list&lt;&gt; reactions;<br>


      </code>对符合简单状态的概念声明一个 <code>reactions</code>
成员 <code>typedef</code>，这是可选的，因为 <code>simple_state&lt;&gt;</code>
已经定义了以下公有成员：<code>typedef
mpl::list&lt;&gt; reactions;</code></td>


    </tr>


  
  </tbody>
</table>


<h2><a name="State" id="State">State</a>
concept 状态概念</h2>


<p>A State is a <b>refinement</b> of <a href="#SimpleState">SimpleState</a> (that is, except
for the default constructor a State type must also satisfy SimpleState
requirements). For a State type <code>S</code>, a pointer <code>pS</code>
of type <code>S *</code> pointing to an object of type <code>S</code>
allocated with <code>new</code>, and an object <code>mc</code>
of type <code>state&lt; S, C, I, h &gt;</code><code>::my_context</code>
the following expressions/statements must be well-formed:<br>


状态是 <a href="reference.html#SimpleState">简单状态</a>
的精化(除了缺省构造函数以外，状态类型必须满足简单状态的所有要求)。对于一个状态类型 <code>S</code>,&amp;
nbsp;指向一个由 <code>new</code> 分配的 <code>S</code>
类型对象的类型为 <code>S *</code> 的一个指针 <code>pS</code>，
以及 <code>state&lt; S, C, I, h &gt;</code><code>::my_context</code>
类型的一个对象 <code>mc</code>，以下表达式/语句必须有效：</p>


<table summary="State concept" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="28%"><b>Expression/Statement 表达式/语句</b></td>


      <td width="29%"><b>Type 类型</b></td>


      <td width="42%"><b>Effects/Result/Notes
作用/结果/说明</b></td>


    </tr>


    <tr>


      <td width="28%"><code><a href="#ClassTemplatestate">state</a>&lt; S, C, I,
h &gt; *<br>


&nbsp; pB = pS;</code></td>


      <td width="29%">&nbsp;</td>


      <td width="42%"><code>state&lt; S, C, I, h
&gt;</code> must be an unambiguous public base of <code>S</code>.
See <code><a href="#ClassTemplatestate">state&lt;&gt;</a></code>
documentation for the requirements and semantics of <code>C</code>,
      <code>I</code> and <code>h<br>


      </code><code>state&lt; S, C, I, h
&gt;</code> 必须是 <code>S</code> 的一个明确的公有基类。有关 <code>C</code>,
      <code>I</code> 和 <code>h</code> 的要求和语义请见
      <code><a href="reference.html#ClassTemplatestate">state&lt;&gt;</a></code>
的文档<code></code></td>


    </tr>


    <tr>


      <td width="28%"><code>new S( mc )</code></td>


      <td width="29%"><code>S *</code></td>


      <td width="42%">Enters the state <code>S</code>.
No restrictions exist regarding the functions that can be called from <code>S::S()</code>
(in contrast to the constructors of models of the SimpleState concept).
      <code>mc</code> must be forwarded to <code>state&lt;
S, C, I, h &gt;::state()<br>


      </code>进入状态 <code>S</code>.
对于可以在 <code>S::S()</code>
中调用的函数没有限制(与简单状态概念的构造函数不同)。<code>mc</code> 必须被前转至 <code>state&lt;
S, C, I, h &gt;::state()</code></td>


    </tr>


  
  </tbody>
</table>


<h2><a name="Event" id="Event">Event</a>
concept 事件概念</h2>


<p>A Event type defines an event for which state machines can
define reactions.<br>


事件类型定义了一个事件，状态机可以为之定义反应。</p>


<p>For a Event type <code>E</code> and a pointer <code>pCE</code>
of type <code>const E *</code> pointing to an object of
type <code>E</code> allocated with <code>new</code>
the following expressions/statements must be well-formed and have the
indicated effects/results:<br>


对于一个事件类型 <code>E</code> 以及指向一个由 <code>new</code>
分配的 <code>E</code> 类型对象的类型为 <code>const E *</code>
的一个指针 <code>pCE</code>，以下表达式/语句必须有效，并且具有所示的作用/结果：</p>


<table summary="Event concept" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="28%"><b>Expression/Statement 表达式/语句</b></td>


      <td width="29%"><b>Type 类型</b></td>


      <td width="42%"><b>Effects/Result/Notes
作用/结果/说明</b></td>


    </tr>


    <tr>


      <td width="28%"><code>const <a href="#ClassTemplateevent">event</a>&lt; E
&gt; * pCB = pCE;</code></td>


      <td width="29%">&nbsp;</td>


      <td width="42%"><code>event&lt; E &gt;</code>
must be an unambiguous public base of <code>E<br>


      </code><code>event&lt; E &gt;</code>
必须是 <code>E</code> 的一个明确的公有基类<code></code></td>


    </tr>


    <tr>


      <td width="28%"><code>new E( *pCE )</code></td>


      <td width="29%"><code>E *</code></td>


      <td width="42%">Makes a copy of <code>pE<br>


      </code>构造 <code>pE</code> 的一个拷贝<code></code></td>


    </tr>


  
  </tbody>
</table>


<h1>Header &lt;boost/statechart/<a name="state_machine.hpp" id="state_machine.hpp">state_machine.hpp</a>&gt;</h1>


<h2><a name="ClassTemplatestate_machine" id="ClassTemplatestate_machine">Class template <code>state_machine&nbsp;</code>类
模板 <code>state_machine</code></a></h2>


<p>This is the base class template of all synchronous state
machines.<br>


这是所有同步状态机的基类模板。</p>


<h3>Class template <code>state_machine</code>
parameters 类模板 <code>state_machine</code> 的参数</h3>


<table summary="state_machine parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="15%"><b>Template parameter 模板参数</b></td>


      <td width="51%"><b>Requirements 要求</b></td>


      <td width="18%"><b>Semantics 语义</b></td>


      <td width="19%"><b>Default 缺省值</b></td>


    </tr>


    <tr>


      <td width="15%"><code>MostDerived</code></td>


      <td width="51%">The most-derived subtype of this
class template<br>


该类模板的最底层子类型</td>


      <td width="18%">&nbsp;</td>


      <td width="19%">&nbsp;</td>


    </tr>


    <tr>


      <td width="15%"><code>InitialState</code></td>


      <td width="51%">A model of the <a href="#SimpleState">SimpleState</a> or <a href="#State">State</a> concepts. The <code>Context</code>
argument passed to the <code><a href="#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
or <code><a href="#ClassTemplatestate">state&lt;&gt;</a></code>
base of&nbsp; <code>InitialState</code> must be <code>MostDerived</code>.
That is, <code>InitialState</code> must be an <a href="definitions.html#OutermostState">outermost state</a>
of this state machine<br>


符合 <a href="reference.html#SimpleState">简单状态</a> 或 <a href="reference.html#State">状态</a> 概念的类型。传给&nbsp; <code>InitialState</code>
的 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
or <code><a href="reference.html#ClassTemplatestate">state&lt;&gt;</a></code>
基类的 <code>Context</code>
参数必须为 <code>MostDerived</code>.
即，<code>InitialState</code> 必须是该状态机的一个 <a href="definitions.html#OutermostState">最外层状态</a></td>


      <td width="18%">The state that is entered when <code>state_machine&lt;&gt;<br>


::initiate()</code> is called<br>


调用 <code>state_machine&lt;&gt;<br>


::initiate()</code> 时进入的状态</td>


      <td width="19%">&nbsp;</td>


    </tr>


    <tr>


      <td width="15%"><code>Allocator</code></td>


      <td width="51%">A model of the standard Allocator
concept<br>


符合标准分配器概念的类型</td>


      <td width="18%"><code>Allocator::rebind&lt;&gt;::other</code>
is used to allocate and deallocate all <code>simple_state</code>
subtype objects and internal objects of dynamic storage duration<br>


      <code>Allocator::rebind&lt;&gt;::other</code>
被用于所有 <code>simple_state</code>
子类型对象以及动态存储过程中的内部对象的分配和释放</td>


      <td width="19%"><code>std::allocator&lt;
void &gt;</code></td>


    </tr>


    <tr>


      <td width="15%"><code>ExceptionTranslator</code></td>


      <td width="51%">A model of the ExceptionTranslator
concept<br>


符合异常转换器概念的类型</td>


      <td width="18%">see <a href="#ExceptionTranslator">ExceptionTranslator</a>
concept<br>


请见 <a href="reference.html#ExceptionTranslator">异常转换器</a>
概念</td>


      <td width="19%"><code>null_exception_translator</code></td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>state_machine</code>
synopsis 类模板 <code>state_machine</code> 摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt;<br> class MostDerived,<br> class InitialState,<br> class Allocator = std::allocator&lt; void &gt;,<br> class ExceptionTranslator = null_exception_translator &gt;<br> class state_machine : noncopyable<br> {<br> public:<br> typedef MostDerived outermost_context_type;<br><br> void <a href="#initiate">initiate</a>();<br> void <a href="#terminate">terminate</a>();<br> bool <a href="#terminated">terminated</a>() const;<br><br> void <a href="#process_event">process_event</a>( const <a href="#Classevent_base">event_base</a> &amp; );<br><br> template&lt; class Target &gt;<br> Target <a href="#state_cast">state_cast</a>() const;<br> template&lt; class Target &gt;<br> Target <a href="#state_downcast">state_downcast</a>() const;<br><br> // a model of the <a href="#StateBase">StateBase</a> concept <br> // 符合 <a href="reference.html#StateBase">状态基</a> 的概念<br> typedef <i>implementation-defined</i> state_base_type;<br> // a model of the standard Forward Iterator concept<br> // 符合标准的前向迭代器的概念<br> typedef <i>implementation-defined</i> state_iterator;<br><br> state_iterator <a href="#state_begin">state_begin</a>() const;<br> state_iterator <a href="#state_end">state_end</a>() const;<br><br> void <a href="#unconsumed_event">unconsumed_event</a>( const <a href="#Classevent_base">event_base</a> &amp; ) {}<br><br> protected:<br> <a href="#state_machine">state_machine</a>();<br> <a href="#state_machinedtor">~state_machine</a>();<br><br> void <a href="#post_event2">post_event</a>(<br> const intrusive_ptr&lt; const <a href="#Classevent_base">event_base</a> &gt; &amp; );<br> void <a href="#post_event3">post_event</a>( const <a href="#Classevent_base">event_base</a> &amp; );<br> };<br>}<br>}<br></pre>


<h3>Class template <code>state_machine</code>
constructor and destructor 类模板 <code>state_machine</code>
的构造函数和析构函数</h3>


<pre><a name="state_machine" id="state_machine">state_machine</a>();<br></pre>


<p><b>Effects</b>: Constructs a non-running state
machine<br>


<b>作用：</b>构造一个未运行的状态机</p>


<pre><a name="state_machinedtor" id="state_machinedtor">~state_machine</a>();<br></pre>


<p><b>Effects</b>: Destructs the currently active
outermost state and all its direct and indirect inner states. Innermost
states are destructed first. Other states are destructed as soon as all
their direct and indirect inner states have been destructed. The inner
states of each state are destructed according to the number of their
orthogonal region. The state in the orthogonal region with the highest
number is always destructed first, then the state in the region with
the second-highest number and so on<br>


<b>作用：</b>析构当前活动的最外层状态以及它的所有直接和间接内层状态。最内层状态首先被析构。其它状态在其所有直接和
间接状态被析构后立即析构。每个状态的内层状态按照它们的正交区域号码顺序来析构。具有最大号码的正交区域中的状态首先析构，然后析构次大号码区域中的状
态，依次类推</p>


<p><b>Note</b>: Does not attempt to call any <code>exit</code>
member functions<br>


<b>注意：</b>不要试图调用任何 <code>exit</code>
成员函数</p>


<h3>Class template <code>state_machine</code>
modifier functions 类模板 <code>state_machine</code>
的可写函数</h3>


<pre>void <a name="initiate" id="initiate">initiate</a>();<br></pre>


<p><b>Effects</b>:<b><br>


作用：</b></p>


<ol>


  <li>Calls <code>terminate()</code><br>


调用 <code>terminate()</code></li>


  <li>Constructs a function object <code>action</code>
with a parameter-less <code>operator()()</code> returning <code><a href="#Classresult">result</a></code>
that<br>


构造一个函数对象 <code>action</code>，带有一个返回 <code><a href="reference.html#Classresult">result</a></code>
的无参 <code>operator()()</code> 满足
    
    <ol type="a">


      <li>enters (constructs) the state specified with the <code>InitialState</code>
template parameter<br>


进入(构造)由 <code>InitialState</code>
模板参数指定的状态</li>


      <li>enters the tree formed by the direct and indirect inner
initial states of <code>InitialState</code> depth first.
The inner states of each state are entered according to the number of
their orthogonal region. The state in orthogonal region 0 is always
entered first, then the state in region 1 and so on<br>


进入以深度优先方式形成的 <code>InitialState</code>
的直接及间接初始状态树。每个状态的内层状态根据其正交区域号码顺序进入。正交区域0中的状态首先被进入，然后是区域1，等等</li>


    
    </ol>


  </li>


  <li>Constructs a function object <code>exceptionEventHandler</code>
with an <code>operator()()</code> returning <code>result</code>
and accepting an exception event parameter that processes the passed
exception event, with the following differences to the processing of
normal events:<br>


构造一个函数对象 <code>exceptionEventHandler</code>，带
有一个返回 <code>result</code> 且接受一个异常事件参数的 <code>operator()()</code>，
它处理传入的异常事件，与普通事件的处理有以下区别：
    
    <ul type="disc">


      <li>From the moment when the exception has been thrown
until right after the execution of the exception event reaction, states
that need to be exited are only destructed but no <code>exit</code>
member functions are called<br>


从异常被抛出的一刻起，直至异常事件反应执行完成，需要退出的状态只能析构但不调用 <code>exit</code>
成员函数</li>


      <li><a href="definitions.html#Reaction">Reaction</a>
search always starts with the outermost <a href="definitions.html#UnstableState">unstable state</a><br>


        <a href="definitions.html#Reaction">反应</a>
的查找总是从最外层的 <a href="definitions.html#UnstableState">不稳定状态</a>
开始 </li>


      <li>As for normal events, reaction search moves outward
when the current state cannot handle the event. However, if there is no
outer state (an <a href="definitions.html#OutermostState">outermost
state</a> has been reached) the reaction search is considered
unsuccessful. That is, exception events will never be dispatched to
orthogonal regions other than the one that caused the exception event<br>


和普通
事件一样，在当前状态不能处理该事件时，就向外查找可用反应。但是，如果没有外层状态(即已到达 <a href="definitions.html#OutermostState">最外层状态</a>)，则认为反应
查找失败。即，异常事件不会被分派到引发异常事件以外的正交区域</li>


      <li>Should an exception be thrown during exception event
reaction search or reaction execution then the exception is propagated
out of the <code>exceptionEventHandler</code> function
object (that is, <code>ExceptionTranslator</code> is <b>not</b>
used to translate exceptions thrown while processing an exception event)<br>


在
异常事件反应查找或反应执行期间，如果抛出异常，则该异常被传播到 <code>exceptionEventHandler</code>
函数对象之外(即，在处理异常事件期间，不会使用 <code>ExceptionTranslator</code>
来对异常的抛出进行转换)</li>


      <li>If no reaction could be found for the exception event
or if the state machine is not stable after processing the exception
event, the original exception is rethrown. Otherwise, a <code><a href="#Classresult">result</a></code> object is
returned equal to the one returned by <code>simple_state&lt;&gt;::discard_event()</code><br>


如
果找不到异常事件的反应，或者在异常事件处理后状态机是不稳定的，则重新抛出原来的异常。否则，返回由 <code>simple_state&lt;&gt;::discard_event()</code>
返回的 <code><a href="reference.html#Classresult">result</a></code>
对象<code></code></li>


    
    </ul>


  </li>


  <li>Passes <code>action</code> and <code>exceptionEventHandler</code>
to <code>ExceptionTranslator::operator()()</code>. If <code>ExceptionTranslator::operator()()</code>
throws an exception, the exception is propagated to the caller. If the
caller catches the exception, the currently active outermost state and
all its direct and indirect inner states are destructed. Innermost
states are destructed first. Other states are destructed as soon as all
their direct and indirect inner states have been destructed. The inner
states of each state are destructed according to the number of their
orthogonal region. The state in the orthogonal region with the highest
number is always destructed first, then the state in the region with
the second-highest number and so on. Continues with step 5 otherwise
(the return value is discarded)<br>


将 <code>action</code> 和 <code>exceptionEventHandler</code>
传给 <code>ExceptionTranslator::operator()()</code>. 如果 <code>ExceptionTranslator::operator()()</code>
抛出一个异常，则该异常被传播给调用者。如果调用者捕获了该异常，则当前活动的最外层状态及其所有直接和间接内层状态被析构。最内层状态首先被析构。其它
状态在其所有直接和间接内层状态被析构后立即析构。每个状态的内层状态根据其正交区域号码的顺序进行析构。最大号码的正交区域中的状态首先被析构，然后是
次大号码的区域中的状态，依次类推。否则继续第5步(返回值被忽略)</li>


  <li>Processes all posted events (see <code>process_event()</code>).
Returns to the caller if there are no more posted events<br>


处理所有被发送的事件(请见 <code>process_event()</code>)。
如果没有其它事件，则返回至调用者</li>


</ol>


<p><b>Throws</b>: Any exceptions propagated from <code>ExceptionTranslator::operator()()</code>.
Exceptions never originate in the library itself but only in code
supplied through template parameters:<b><br>


抛出：</b>由 <code>ExceptionTranslator::operator()()</code>
传出的任意异常。库本身不会引起异常，除了由模板参数所提供的代码以外：</p>


<ul>


  <li><code>Allocator::rebind&lt;&gt;::other::allocate()</code></li>


  <li>state constructors 状态的构造函数</li>


  <li><code>react</code> member functions&nbsp;<code>react</code>
成员函数</li>


  <li><code>exit</code> member functions&nbsp;<code>exit</code>
成员函数</li>


  <li>transition-actions 转换动作</li>


</ul>


<pre>void <a name="terminate" id="terminate">terminate</a>();<br></pre>


<p><b>Effects</b>:<br>


<b>作用：</b></p>


<ol>


  <li>Constructs a function object <code>action</code>
with a parameter-less <code>operator()()</code> returning <code><a href="#Classresult">result</a></code> that <a href="#simple_state::terminate">terminates</a> the
currently active outermost state, discards all remaining events and
clears all history information<br>


构造一个函数对象 <code>action</code>，
带一个无参的 <code>operator()()</code>，返回 <code><a href="reference.html#Classresult">result</a></code>，<a href="reference.html#simple_state::terminate">终止</a>当前活
动的最外层状态，忽略所有剩余的事件并清除所有历史信息</li>


  <li>Constructs a function object <code>exceptionEventHandler</code>
with an <code>operator()()</code> returning <code><a href="#Classresult">result</a></code> and
accepting an exception event parameter that processes the passed
exception event, with the following differences to the processing of
normal events:<br>


构造一个函数对象 <code>exceptionEventHandler</code>，带
一个 <code>operator()()</code>，返回 <code><a href="reference.html#Classresult">result</a></code>
且接受一个异常事件参数，它处理传入的异常事件，与普通的事件处理有以下区别：
    
    <ul type="disc">


      <li>From the moment when the exception has been thrown
until right after the execution of the exception event reaction, states
that need to be exited are only destructed but no <code>exit</code>
member functions are called<br>


从异常被抛出的一刻起，直至异常事件反应执行完成，需要退出的状态只能析构但不调用 <code>exit</code>
成员函数</li>


      <li><a href="definitions.html#Reaction">Reaction</a>
search always starts with the outermost <a href="definitions.html#UnstableState">unstable state</a><br>


        <a href="definitions.html#Reaction">反应</a>
的查找总是从最外层的 <a href="definitions.html#UnstableState">不稳定状态</a>
开始</li>


      <li>As for normal events, reaction search moves outward
when the current state cannot handle the event. However, if there is no
outer state (an <a href="definitions.html#OutermostState">outermost
state</a> has been reached) the reaction search is considered
unsuccessful. That is, exception events will never be dispatched to
orthogonal regions other than the one that caused the exception event<br>


和普通
事件一样，在当前状态不能处理该事件时，就向外查找可用反应。但是，如果没有外层状态(即已到达 <a href="definitions.html#OutermostState">最外层状态</a>)，则认为反应
查找失败。即，异常事件不会被分派到引发异常事件以外的正交区域</li>


      <li>Should an exception be thrown during exception event
reaction search or reaction execution then the exception is propagated
out of the <code>exceptionEventHandler</code> function
object (that is, <code>ExceptionTranslator</code> is <b>not</b>
used to translate exceptions thrown while processing an exception event)<br>


在
异常事件反应查找或反应执行期间，如果抛出异常，则该异常被传播到 <code>exceptionEventHandler</code>
函数对象之外(即，在处理异常事件期间，不会使用 <code>ExceptionTranslator</code>
来对异常的抛出进行转换)</li>


      <li>If no reaction could be found for the exception event
or if the state machine is not stable after processing the exception
event, the original exception is rethrown. Otherwise, a <code><a href="#Classresult">result</a></code> object is
returned equal to the one returned by <code>simple_state&lt;&gt;::discard_event()</code><code></code><br>


如
果找不到异常事件的反应，或者在异常事件处理后状态机是不稳定的，则重新抛出原来的异常。否则，返回由 <code>simple_state&lt;&gt;::discard_event()</code>
返回的 <code><a href="reference.html#Classresult">result</a></code>
对象</li>


    
    </ul>


  </li>


  <li>Passes <code>action</code> and <code>exceptionEventHandler</code>
to <code>ExceptionTranslator::operator()()</code>. If <code>ExceptionTranslator::operator()()</code>
throws an exception, the exception is propagated to the caller. If the
caller catches the exception, the currently active outermost state and
all its direct and indirect inner states are destructed. Innermost
states are destructed first. Other states are destructed as soon as all
their direct and indirect inner states have been destructed. The inner
states of each state are destructed according to the number of their
orthogonal region. The state in the orthogonal region with the highest
number is always destructed first, then the state in the region with
the second-highest number and so on. Otherwise, returns to the caller<br>


将 <code>action</code> 和 <code>exceptionEventHandler</code>
传给 <code>ExceptionTranslator::operator()()</code>. 如果 <code>ExceptionTranslator::operator()()</code>
抛出一个异常，则该异常被传播给调用者。如果调用者捕获了该异常，则当前活动的最外层状态及其所有直接和间接内层状态被析构。最内层状态首先被析构。其它
状态在其所有直接和间接内层状态被析构后立即析构。每个状态的内层状态根据其正交区域号码的顺序进行析构。最大号码的正交区域中的状态首先被析构，然后是
次大号码的区域中的状态，依次类推。否则返回到调用者</li>


</ol>


<p><b>Throws</b>: Any exceptions propagated from <code>ExceptionTranslator::operator()</code>.
Exceptions never originate in the library itself but only in code
supplied through template parameters:<b><br>


抛出：</b>由 <code>ExceptionTranslator::operator()()</code>
传出的任意异常。库本身不会引起异常，除了由模板参数所提供的代码以外：</p>


<ul>


  <li><code>Allocator::rebind&lt;&gt;::other::allocate()</code></li>


  <li>state constructors 状态的构造函数</li>


  <li><code>react</code> member functions&nbsp;<code>react</code>
成员函数</li>


  <li><code>exit</code> member functions&nbsp;<code>exit</code>
成员函数</li>


  <li>transition-actions 转换动作</li>


</ul>


<pre>void <a name="process_event" id="process_event">process_event</a>( const <a href="#Classevent_base">event_base</a> &amp; );<br></pre>


<p><b>Effects</b>:<br>


<b>作用：</b></p>


<ol>


  <li>Selects the passed event as the current event (henceforth
referred to as <code>currentEvent</code>)<br>


将传入的事件选定为当前事件(自此被 <code>currentEvent</code> 所引向)</li>


  <li>Starts a new <a href="definitions.html#Reaction">reaction</a>
search<br>


开始一个新的<a href="definitions.html#Reaction">反应</a>查
找</li>


  <li>Selects an arbitrary but in this reaction search not yet
visited state from all the currently active <a href="definitions.html#InnermostState">innermost states</a>.
If no such state exists then continues with step 10<br>


从所有当前活动的 <a href="definitions.html#InnermostState">最内层状态</a>
中选择任意一个本次反应查找未访问过的状态。如果不存在这样的状态，则跳至第10步</li>


  <li>Constructs a function object <code>action</code>
with a parameter-less <code>operator()()</code> returning <code><a href="#Classresult">result</a></code> that does
the following:<br>


构造一个函数对象 <code>action</code>，
带一个无参的 <code>operator()()</code>，返回 <code><a href="reference.html#Classresult">result</a></code>，
做
以下事情：
    
    <ol type="a">


      <li>Searches a reaction suitable for <code>currentEvent</code>,
starting with the current innermost state and moving outward until a
state defining a reaction for the event is found. Returns <code>simple_state&lt;&gt;::forward_event()</code>
if no reaction has been found<br>


查找一个适用于 <code>currentEvent</code>
的反应，从当前最内层状态开始向外层移动，直至找到一个对该事件定义了反应的状态。如果找不到反应则返回 <code>simple_state&lt;&gt;::forward_event()</code></li>


      <li>Executes the found reaction. If the reaction result is
equal to the return value of <code>simple_state&lt;&gt;::forward_event()</code>
then resumes the reaction search (step a). Returns the reaction result
otherwise<br>


执行找到的反应。如果反应的执行结果等于 <code>simple_state&lt;&gt;::forward_event()</code>
的返回值，则重新开始反应查找(步骤a)。否则返回反应结果</li>


    
    </ol>


  </li>


  <li>Constructs a function object <code>exceptionEventHandler</code>
returning <code><a href="#Classresult">result</a></code>
and accepting an exception event parameter that processes the passed
exception event, with the following differences to the processing of
normal events:<br>


构造一个函数对象 <code>exceptionEventHandler</code>，返回 <code><a href="reference.html#Classresult">result</a></code>
且接受一个异常事件参数，它处理传入的异常事件，与普通的事件处理有以下区别：
    
    <ul type="disc">


      <li>From the moment when the exception has been thrown
until right after the execution of the exception event reaction, states
that need to be exited are only destructed but no <code>exit</code>
member functions are called<br>


从异常被抛出的一刻起，直至异常事件反应执行完成，需要退出的状态只能析构但不调用 <code>exit</code>
成员函数</li>


      <li>If the state machine is stable when the exception event
is processed then exception event reaction search starts with the
innermost state that was last visited during the last normal event
reaction search (the exception event was generated as a result of this
normal reaction search)<br>


如果在处理异常事件时状态机是稳定的，则异常事件的反应查找从在最后一次普通事件反应查找期间最后访问的最内层状态开始(异常事件是作为这次普通反应查找
的结果而生成的)</li>


      <li>If the state machine is <a href="definitions.html#UnstableStateMachine">unstable</a>
when the exception event is processed then exception event reaction
search starts with the outermost <a href="definitions.html#UnstableState">unstable state</a><br>


如果在处理异常事件时状态机是 <a href="definitions.html#UnstableStateMachine">不
稳定的</a>，则异常事件的反应查找从最外层的 <a href="definitions.html#UnstableState">不稳定状态</a> 开始</li>


      <li>As for normal events, reaction search moves outward
when the current state cannot handle the event. However, if there is no
outer state (an <a href="definitions.html#OutermostState">outermost
state</a> has been reached) the reaction search is considered
unsuccessful. That is, exception events will never be dispatched to
orthogonal regions other than the one that caused the exception event<br>


和普通
事件一样，在当前状态不能处理该事件时，就向外查找可用反应。但是，如果没有外层状态(即已到达 <a href="definitions.html#OutermostState">最外层状态</a>)，则认为反应
查找失败。即，异常事件不会被分派到引发异常事件以外的正交区域</li>


      <li>Should an exception be thrown during exception event
reaction search or reaction execution then the exception is propagated
out of the <code>exceptionEventHandler</code> function
object (that is, <code>ExceptionTranslator</code> is <b>not</b>
used to translate exceptions thrown while processing an exception event)<br>


在
异常事件反应查找或反应执行期间，如果抛出异常，则该异常被传播到 <code>exceptionEventHandler</code>
函数对象之外(即，在处理异常事件期间，不会使用 <code>ExceptionTranslator</code>
来对异常的抛出进行转换)</li>


      <li>If no reaction could be found for the exception event
or if the state machine is not stable after processing the exception
event, the original exception is rethrown. Otherwise, a <code><a href="#Classresult">result</a></code> object is
returned equal to the one returned by <code>simple_state&lt;&gt;::discard_event()</code><code></code><code></code><br>


如
果找不到异常事件的反应，或者在异常事件处理后状态机是不稳定的，则重新抛出原来的异常。否则，返回由 <code>simple_state&lt;&gt;::discard_event()</code>
返回的 <code><a href="reference.html#Classresult">result</a></code>
对象</li>


    
    </ul>


  </li>


  <li>Passes <code>action</code> and <code>exceptionEventHandler</code>
to <code>ExceptionTranslator::operator()()</code>. If <code>ExceptionTranslator::operator()()</code>
throws an exception, the exception is propagated to the caller. If the
caller catches the exception, the currently active outermost state and
all its direct and indirect inner states are destructed. Innermost
states are destructed first. Other states are destructed as soon as all
their direct and indirect inner states have been destructed. The inner
states of each state are destructed according to the number of their
orthogonal region. The state in the orthogonal region with the highest
number is always destructed first, then the state in the region with
the second-highest number and so on. Otherwise continues with step 7<br>


将 <code>action</code> 和 <code>exceptionEventHandler</code>
传给 <code>ExceptionTranslator::operator()()</code>. 如果 <code>ExceptionTranslator::operator()()</code>
抛出一个异常，则该异常被传播给调用者。如果调用者捕获了该异常，则当前活动的最外层状态及其所有直接和间接内层状态被析构。最内层状态首先被析构。其它
状态在其所有直接和间接内层状态被析构后立即析构。每个状态的内层状态根据其正交区域号码的顺序进行析构。最大号码的正交区域中的状态首先被析构，然后是
次大号码的区域中的状态，依次类推。否则继续第7步</li>


  <li>If the return value of <code>ExceptionTranslator::operator()()</code>
is equal to the one of <code>simple_state&lt;&gt;::forward_event()</code>
then continues with step 3<br>


如果 <code>ExceptionTranslator::operator()()</code>
的返回值等于 <code>simple_state&lt;&gt;::forward_event()</code>
之一，就继续步骤3</li>


  <li>If the return value of <code>ExceptionTranslator::operator()()</code>
is equal to the one of <code>simple_state&lt;&gt;::defer_event()</code>
then the return value of <code>currentEvent.<a href="#intrusive_from_this">intrusive_from_this</a>()</code>
is stored in a state-specific queue. Continues with step 11<br>


如果 <code>ExceptionTranslator::operator()()</code>
的返回值等于 <code>simple_state&lt;&gt;::defer_event()</code>
之一，则将 <code>currentEvent.<a href="reference.html#intrusive_from_this">intrusive_from_this</a>()</code>
的返回值保存在一个状态相关的队列中。继续步骤11</li>


  <li>If the return value of <code>ExceptionTranslator::operator()()</code>
is equal to the one of <code>simple_state&lt;&gt;::discard_event()</code>
then continues with step 11<br>


如果 <code>ExceptionTranslator::operator()()</code>
的返回值等于 <code>simple_state&lt;&gt;::discard_event()</code>
之一，则继续步骤11</li>


  <li>Calls <code>static_cast&lt; MostDerived *
&gt;( this )-&gt;unconsumed_event( currentEvent )</code>.
If <code>unconsumed_event()</code> throws an exception,
the exception is propagated to the caller. Such an exception never
leads to the destruction of any states (in contrast to exceptions
propagated from <code>ExceptionTranslator::operator()()</code>)<br>


调
用 <code>static_cast&lt; MostDerived *
&gt;( this )-&gt;unconsumed_event( currentEvent )</code>.
如果 <code>unconsumed_event()</code>
抛出异常，则该异常被传播到调用者。这种异常不会导致任何状态的析构(与由 <code>ExceptionTranslator::operator()()</code>
传出的异常相比较而言)</li>


  <li>If the posted events queue is non-empty then dequeues the
first event, selects it as <code>currentEvent</code> and
continues with step 2. Returns to the caller otherwise<br>


如果事件队列非空，则将第一个事件出
列，将它选为 <code>currentEvent</code> 并继续步骤2。否则返回到调用者</li>


</ol>


<p><b>Throws</b>: Any exceptions propagated from <code>MostDerived::unconsumed_event()</code>
or <code>ExceptionTranslator::operator()</code>.
Exceptions never originate in the library itself but only in code
supplied through template parameters:<b><br>


抛出：</b>由 <code>MostDerived::unconsumed_event()</code>
或 <code>ExceptionTranslator::operator()()</code>
传出的任意异常。库本身不会引起异常，除了由模板参数所提供的代码以外：
</p>


<ul>


  <li><code>Allocator::rebind&lt;&gt;::other::allocate()</code></li>


  <li>state constructors 状态的构造函数</li>


  <li><code>react</code> member functions&nbsp;<code>react</code>
成员函数</li>


  <li><code>exit</code> member functions&nbsp;<code>exit</code>
成员函数</li>


  <li>transition-actions 转换动作</li>


  <li><code>MostDerived::unconsumed_event()</code></li>


</ul>


<pre>void <a name="post_event2" id="post_event2">post_event</a>(<br> const intrusive_ptr&lt; const <a href="#Classevent_base">event_base</a> &gt; &amp; );<br></pre>


<p><b>Effects</b>: Pushes the passed event into the
posted events queue<b><br>


作用：</b>将传入的事件压入事件队列<br>


<b>Throws</b>: Any exceptions propagated from <code>Allocator::allocate()</code><br>


<b>抛出：</b>由 <code>Allocator::allocate()</code>
传出的任意异常<code></code></p>


<pre>void <a name="post_event3" id="post_event3">post_event</a>( const <a href="#Classevent_base">event_base</a> &amp; evt );<br></pre>


<p><b>Effects</b>: <code>post_event(
evt.intrusive_from_this() );</code><b><br>


作用：</b><code>post_event(
evt.intrusive_from_this() );</code><br>


<b>Throws</b>: Any exceptions propagated from <code>Allocator::allocate()</code><code></code><br>


<b>抛出：</b>由 <code>Allocator::allocate()</code>
传出的任意异常</p>


<pre>void <a name="unconsumed_event" id="unconsumed_event">unconsumed_event</a>( const <a href="#Classevent_base">event_base</a> &amp; evt );<br></pre>


<p><b>Effects</b>: None<br>


<b>作用：</b>无<br>


<b>Note</b>: This function (or, if present, the equally
named derived class member function) is called by <a href="#process_event">process_event</a>() whenever a
dispatched event did not trigger a reaction, see <a href="#process_event">process_event</a>() effects,
point 10 for more information.<br>


<b>注意：</b>该函数(或派生类的同名成员函数，如果有的话)由 <a href="reference.html#process_event">process_event</a>()
在一个被分派事件没有触发反应时调用，更多信息请见 <a href="reference.html#process_event">process_event</a>()
作用的第10点。</p>


<h3>Class template <code>state_machine</code>
observer functions 类模板 <code>state_machine</code>
observer 的函数</h3>


<pre>bool <a name="terminated" id="terminated">terminated</a>() const;<br></pre>


<p><b>Returns</b>: <code>true</code>, if
the machine is terminated. Returns <code>false</code>
otherwise<br>


<b>返回：</b><code>true</code>, 如果状态机已被终止。否则返回 <code>false</code>&nbsp;<br>


<b>Note</b>: Is equivalent to <code>state_begin() ==
state_end()</code><br>


<b>说明：</b>等价于 <code>state_begin() ==
state_end()</code></p>


<pre>template&lt; class Target &gt;<br>Target <a name="state_cast" id="state_cast">state_cast</a>() const;<br></pre>


<p><b>Returns</b>: Depending on the form of <code>Target</code>
either a reference or a pointer to <code>const</code> if
at least one of the currently active states can successfully be <code>dynamic_cast</code>
to <code>Target</code>. Returns <code>0</code>
for pointer targets and throws <code>std::bad_cast</code>
for reference targets otherwise. <code>Target</code> can
take either of the following forms: <code>const Class *</code>
or <code>const Class &amp;</code><br>


<b>返回：</b>根据 <code>Target</code>
的形式，如果至少有一个当前活动的状态可以成功地 <code>dynamic_cast</code> 为 <code>Target</code>
则返回相应的 <code>const</code> 引用或 <code>const</code>
指针。否则，对于指针类型返回 <code>0</code>，而对于引用类型则抛出 <code>std::bad_cast</code>.
<code>Target</code> 可以是以下形式：<code>const Class *</code>
或 <code>const Class &amp;<br>


</code><b>Throws</b>: <code>std::bad_cast</code>
if <code>Target</code>
is a reference type and none of the active states can be <code>dynamic_cast</code>
to Target<b><br>


抛出：</b><code>std::bad_cast</code> 如果 <code>Target</code>
是引用类型且没有一个活动状态可以 <code>dynamic_cast</code> 为 Target<br>


<b>说明：</b>查找的顺序与 <code><a href="reference.html#process_event">process_event</a>()</code>
相同<code></code></p>


<pre>template&lt; class Target &gt;<br>Target <a name="state_downcast" id="state_downcast">state_downcast</a>() const;<br></pre>


<p><b>Requires</b>: For reference targets the
compiler must support partial specialization of class templates,
otherwise a compile-time error will result. The type denoted by <code>Target</code>
must be a model of the <a href="#SimpleState">SimpleState</a>
or <a href="#State">State</a> concepts<b><br>


要求：</b>对于引用类型的目标，编译器必须支持类模板偏特化，否则会导致编译期错误。<code>Target</code>
所代表的类型必须符合 <a href="reference.html#SimpleState">简单状态</a>
或 <a href="reference.html#State">状态</a> 概念<br>


<b>Returns</b>: Depending on the form of <code>Target</code>
either a reference or a pointer to <code>const</code> if <code>Target</code>
is equal to the most-derived type of a currently active state. Returns <code>0</code>
for pointer targets and throws <code>std::bad_cast</code>
for reference targets otherwise. <code>Target</code> can
take either of the following forms: <code>const Class *</code>
or <code>const Class &amp;<br>


</code><b>返回：</b>根据 <code>Target</code>
的形式，如果 <code>Target</code>
等于当前活动状态的最底层类型，则返回相应的 <code>const</code> 引用或 <code>const</code>
指针。否则，对于指针类型返回 <code>0</code>，而对于引用类型则抛出 <code>std::bad_cast</code>.
<code>Target</code> 可以是以下形式：<code>const Class *</code>
或 <code>const Class &amp;</code><code></code><br>


<b>Throws</b>: <code>std::bad_cast</code> if <code>Target</code>
is a reference type and none of the active states has a most derived
type equal to <code>Target</code><b><br>


抛出：</b><code>std::bad_cast</code> 如果 <code>Target</code>
为引用类型且没有一个活动状态的最底层类型与 <code>Target</code> 相同<code></code><br>


<b>Note</b>: The search sequence is the same as for <code><a href="#process_event">process_event</a>()</code><br>


<b>说明：</b>查找的顺序与 <code><a href="reference.html#process_event">process_event</a>()</code>
相同<code></code></p>


<pre>state_iterator <a name="state_begin" id="state_begin">state_begin</a>() const;<br></pre>


<pre>state_iterator <a name="state_end" id="state_end">state_end</a>() const;<br></pre>


<p><b>Return</b>: Iterator objects, the range [<code>state_begin()</code>,
<code>state_end()</code>) refers to all currently active <a href="definitions.html#InnermostState">innermost states</a>.
For an object <code>i</code> of type <code>state_iterator</code>,
<code>*i</code> returns a <code>const
state_base_type &amp;</code> and <code>i.operator-&gt;()</code>
returns a <code>const state_base_type *<br>


</code><b>返回：</b>迭代器对象，区间 [<code>state_begin()</code>,
<code>state_end()</code>) 引向所有当前活动的 <a href="definitions.html#InnermostState">最内层状态</a>。对于 <code>state_iterator</code>
类型的对象 <code>i</code>,
<code>*i</code> 返回一个 <code>const
state_base_type &amp;</code> 且 <code>i.operator-&gt;()</code>
返回一个 <code>const state_base_type *</code><br>


<b>Note</b>: The position of a given innermost state in the
range is arbitrary. It may change with each call to a modifier
function. Moreover, all iterators are invalidated whenever a modifier
function is called<br>


<b>说明：</b>给定的某个最内层状态在该区间中的位置是任意的。该位置在每次调用可变函数时可能会改变。此外，在可变函数
被调用后，所有迭代器都会变为无效</p>


<h1>Header &lt;boost/statechart/<br>


<a name="asynchronous_state_machine.hpp" id="asynchronous_state_machine.hpp">asynchronous_state_machine.hpp</a>&gt;</h1>


<h2><a name="ClassTemplateasynchronous_state_machine" id="ClassTemplateasynchronous_state_machine">Class template <code>asynchronous_state_machine
类模板</code> <code>asynchronous_state_machine</code></a></h2>


<p>This is the base class template of all asynchronous state
machines.<br>


这是所有异步状态机的基类模板。</p>


<h3>Class template <code>asynchronous_state_machine</code>
parameters 类模板 <code>asynchronous_state_machine</code> 的参数</h3>


<table summary="asynchronous_state_machine parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="15%"><b>Template parameter 模板参数</b></td>


      <td width="51%"><b>Requirements 要求</b></td>


      <td width="18%"><b>Semantics 语义</b></td>


      <td width="19%"><b>Default 缺省值</b></td>


    </tr>


    <tr>


      <td width="15%"><code>MostDerived</code></td>


      <td width="51%">The most-derived subtype of this
class template<br>


该类模板的最底层子类型</td>


      <td width="18%">&nbsp;</td>


      <td width="19%">&nbsp;</td>


    </tr>


    <tr>


      <td width="15%"><code>InitialState</code></td>


      <td width="51%">A model of the <a href="#SimpleState">SimpleState</a> or <a href="#State">State</a> concepts. The <code>Context</code>
argument passed to the <code><a href="#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
or <code><a href="#ClassTemplatestate">state&lt;&gt;</a></code>
base of <code>InitialState</code> must be <code>MostDerived</code>.
That is, <code>InitialState</code> must be an <a href="definitions.html#OutermostState">outermost state</a>
of this state machine<br>


符合 <a href="reference.html#SimpleState">简单状态</a> 或 <a href="reference.html#State">状态</a> 概念的类型。<code>InitialState</code>
的 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
或 <code><a href="reference.html#ClassTemplatestate">state&lt;&gt;</a></code>
基类的 <code>Context</code>
参数必须为 <code>MostDerived</code>.
即，<code>InitialState</code> 必须是该状态机的一个 <a href="definitions.html#OutermostState">最外层状态</a></td>


      <td width="18%">The state that is entered when the
state machine is initiated through the <code>Scheduler</code>
object<br>


当状态机被 <code>Scheduler</code> 对象初始化时进入的状态</td>


      <td width="19%">&nbsp;</td>


    </tr>


    <tr>


      <td width="15%"><code>Scheduler</code></td>


      <td width="51%">A model of the Scheduler concept<br>


符合调度器概念的类型</td>


      <td width="18%">请见 <a href="#Scheduler">调
度器</a>
概念</td>


      <td width="19%"><code>fifo_scheduler&lt;&gt;</code></td>


    </tr>


    <tr>


      <td width="15%"><code>Allocator</code></td>


      <td width="51%">A model of the standard Allocator
concept<br>


符合标准分配器概念的类型</td>


      <td width="18%">&nbsp;</td>


      <td width="19%"><code>std::allocator&lt;
void &gt;</code></td>


    </tr>


    <tr>


      <td width="15%"><code>ExceptionTranslator</code></td>


      <td width="51%">A model of the ExceptionTranslator
concept<br>


符合异常转换器概念的类型</td>


      <td width="18%">see <a href="#ExceptionTranslator">ExceptionTranslator</a>
concept<br>


请见 <a href="reference.html#ExceptionTranslator">异常转换器</a>
概念</td>


      <td width="19%"><code>null_exception_translator</code></td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>asynchronous_state_machine</code>
synopsis 类模板 <code>asynchronous_state_machine</code> 的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt;<br> class MostDerived,<br> class InitialState,<br> class Scheduler = fifo_scheduler&lt;&gt;,<br> class Allocator = std::allocator&lt; void &gt;,<br> class ExceptionTranslator = null_exception_translator &gt;<br> class asynchronous_state_machine :<br> public state_machine&lt;<br> MostDerived, InitialState, Allocator, ExceptionTranslator &gt;,<br> public event_processor&lt; Scheduler &gt;<br> {<br> protected:<br> typedef asynchronous_state_machine my_base;<br><br> asynchronous_state_machine(<br> typename event_processor&lt; Scheduler &gt;::my_context ctx );<br> ~asynchronous_state_machine(); <br> };<br>}<br>}<br></pre>


<h3>Class template <code>asynchronous_state_machine</code>
constructor and destructor 类模板 <code>asynchronous_state_machine</code>
的构造函数和析构函数</h3>


<pre>asynchronous_state_machine(<br> typename event_processor&lt; Scheduler &gt;::my_context ctx );<br></pre>


<p><b>Effects</b>: Constructs a non-running
asynchronous state machine<br>


<b>作用：</b>构造一个未运行的异步状态机<br>


<b>Note</b>: Users cannot create <code>asynchronous_state_machine&lt;&gt;</code>
subtype objects directly. This can only be done through an object of
the <code>Scheduler</code> class<br>


<b>说明：</b>用户不能直接创建 <code>asynchronous_state_machine&lt;&gt;</code>
子类型对象。只能通过 <code>Scheduler</code> 类的对象来完成这一工作</p>


<pre>~asynchronous_state_machine();<br></pre>


<p><b>Effects</b>: Destructs the state machine<br>


<b>作用：</b>析构一个状态机<br>


<b>Note</b>: Users cannot destruct <code>asynchronous_state_machine&lt;&gt;</code>
subtype objects directly. This can only be done through an object of
the <code>Scheduler</code> class<br>


<b>说明：</b>用户不能直接析构 <code>asynchronous_state_machine&lt;&gt;</code>
子类型对象。只能通过 <code>Scheduler</code> 类的对象来完成这一工作</p>


<h1>Header &lt;boost/statechart/<a name="event_processor.hpp" id="event_processor.hpp">event_processor.hpp</a>&gt;</h1>


<h2><a name="ClassTemplateevent_processor" id="ClassTemplateevent_processor">Class template <code>event_processor
类模板</code> <code>event_processor</code></a></h2>


<p>This is the base class template of all types that process
events. <code>asynchronous_state_machine&lt;&gt;</code>
is just one possible event processor implementation.<br>


这是所有处理事件的类型的基类模板。<code>asynchronous_state_machine&lt;&gt;</code>
只是一个可能的事件处理器实现。</p>


<h3>Class template <code>event_processor</code>
parameters 类模板 <code>event_processor</code> 的参数</h3>


<table summary="event_processor parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="15%"><b>Template parameter 模板参数</b></td>


      <td width="51%"><b>Requirements 要求</b></td>


      <td width="18%"><b>Semantics 语义</b></td>


      <td width="19%"><b>Default 缺省值</b></td>


    </tr>


    <tr>


      <td width="15%"><code>Scheduler</code></td>


      <td width="51%">A model of the Scheduler concept<br>


符合调度器概念的类型</td>


      <td width="18%">see <a href="#Scheduler">Scheduler</a>
concept<br>


请见 <a href="reference.html#Scheduler">Scheduler</a>
概念</td>


      <td width="19%">&nbsp;</td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>event_processor</code>
synopsis 类模板 <code>event_processor</code> 的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt; class Scheduler &gt;<br> class event_processor<br> {<br> public:<br> virtual <a href="#event_processordtor">~event_processor</a>();<br><br> Scheduler &amp; <a href="#my_scheduler">my_scheduler</a>() const;<br><br> typedef typename Scheduler::processor_handle<br> processor_handle;<br> processor_handle <a href="#my_handle">my_handle</a>() const;<br><br> void <a href="#event_processor::initiate">initiate</a>();<br> void <a href="#event_processor::process_event">process_event</a>( const event_base &amp; evt );<br> void <a href="#event_processor::terminate">terminate</a>();<br><br> protected:<br> typedef const typename Scheduler::processor_context &amp;<br> my_context;<br> <a href="#event_processor">event_processor</a>( my_context ctx );<br><br> private:<br> virtual void initiate_impl() = 0;<br> virtual void process_event_impl(<br> const event_base &amp; evt ) = 0;<br> virtual void terminate_impl() = 0;<br> };<br>}<br>}<br></pre>


<h3>Class template <code>event_processor</code>
constructor and destructor 类模板 <code>event_processor</code>
的构造函数和析构函数</h3>


<pre><a name="event_processor" id="event_processor">event_processor</a>( my_context ctx );<br></pre>


<p><b>Effects</b>: Constructs an event processor
object and stores copies of the reference returned by <code>myContext.my_scheduler()</code>
and the object returned by <code>myContext.my_handle()</code><b><br>


作用：</b>构造一个事件处理器对象，并保存由 <code>myContext.my_scheduler()</code>
返回的引用和由 <code>myContext.my_handle()</code> 返回的对象的拷贝<code></code><br>


<b>Note</b>: Users cannot create <code>event_processor&lt;&gt;</code>
subtype objects directly. This can only be done through an object of
the <code>Scheduler</code> class<br>


<b>说明：</b>用户不能直接创建 <code>event_processor&lt;&gt;</code>
子类型的对象。只能通过 <code>Scheduler</code> 类的对象来完成这一工作</p>


<pre>virtual <a name="event_processordtor" id="event_processordtor">~event_processor</a>();<br></pre>


<p><b>Effects</b>: Destructs an event processor object<br>


<b>作用：</b>析构一个事件处理器对象<br>


<b>Note</b>: Users cannot destruct <code>event_processor&lt;&gt;</code>
subtype objects directly. This can only be done through an object of
the <code>Scheduler</code> class<br>


<b>说明：</b>用户不能直接析构 <code>event_processor&lt;&gt;</code>
子类型的对象。只能通过 <code>Scheduler</code> 类的对象来完成这一工作</p>


<h3>Class template <code>event_processor</code>
modifier functions 类模板 <code>event_processor</code>
的可变函数</h3>


<pre>void <a name="event_processor::initiate" id="event_processor::initiate">initiate</a>();<br></pre>


<p><b>Effects</b>: <code>initiate_impl();</code><br>


<b>作用：</b><code>initiate_impl();<br>


</code><b>Throws</b>: Any exceptions propagated from
the implementation of <code>initiate_impl()</code><br>


<b>抛出：</b>由 <code>initiate_impl()</code>
的实现所传出的任意异常<code></code></p>


<pre>void <a name="event_processor::process_event" id="event_processor::process_event">process_event</a>( const event_base &amp; evt );<br></pre>


<p><b>Effects</b>: <code>process_event_impl(
evt );<br>


</code><b>作用：</b><code>process_event_impl(
evt );<br>


</code><b>Throws</b>: Any exceptions propagated from
the implementation of <code>process_event_impl()</code><br>


<b>抛出：</b>由 <code>process_event_impl()</code>
的实现所传出的任意异常<code></code></p>


<pre>void <a name="event_processor::terminate" id="event_processor::terminate">terminate</a>();<br></pre>


<p><b>Effects</b>: <code>terminate_impl();<br>


</code><b>作用：</b><code>terminate_impl();<br>


</code><b>Throws</b>: Any exceptions propagated from
the implementation of <code>terminate_impl()</code><br>


<b>抛出：</b>由 <code>terminate_impl()</code>
的实现所传出的任意异常<code></code></p>


<h3>Class template <code>event_processor</code>
observer functions 类模板 <code>event_processor</code>
的常性函数</h3>


<pre>Scheduler &amp; <a name="my_scheduler" id="my_scheduler">my_scheduler</a>() const;<br></pre>


<p><b>Returns</b>: The <code>Scheduler</code>
reference obtained in the constructor<br>


<b>返回：</b>由构造函数获得的 <code>Scheduler</code>
引用</p>


<pre>processor_handle <a name="my_handle" id="my_handle">my_handle</a>() const;<br></pre>


<p><b>Returns</b>: The <code>processor_handle</code>
object obtained in the constructor<b><br>


返回：</b>由构造函数获得的 <code>processor_handle</code> 对象</p>


<h1>Header &lt;boost/statechart/<a name="fifo_scheduler.hpp" id="fifo_scheduler.hpp">fifo_scheduler.hpp</a>&gt;</h1>


<h2><a name="ClassTemplatefifo_scheduler" id="ClassTemplatefifo_scheduler">Class template <code>fifo_scheduler
类模板</code> <code>fifo_scheduler</code></a></h2>


<p>This class template is a model of the <a href="#Scheduler">Scheduler</a>
concept.<br>


该类模板符合 <a href="reference.html#Scheduler">调度器</a>
概念。</p>


<h3>Class template <code>fifo_scheduler</code>
parameters 类模板 <code>fifo_scheduler</code> 的参数</h3>


<table summary="fifo_scheduler parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="15%"><b>Template parameter 模板参数</b></td>


      <td width="28%"><b>Requirements 要求</b></td>


      <td width="26%"><b>Semantics 语义</b></td>


      <td width="29%"><b>Default 缺省值</b></td>


    </tr>


    <tr>


      <td width="15%"><code>FifoWorker</code></td>


      <td width="28%">A model of the FifoWorker concept<br>


符合先入先出工作者概念的类型</td>


      <td width="26%">see <a href="#FifoWorker">FifoWorker</a>
concept<br>


请见 <a href="reference.html#FifoWorker">先入先出工作者</a>
概念</td>


      <td width="29%"><code>fifo_worker&lt;&gt;</code></td>


    </tr>


    <tr>


      <td width="15%"><code>Allocator</code></td>


      <td width="28%">A model of the standard Allocator
concept<br>


符合标准的分配器概念的类型</td>


      <td width="26%">&nbsp;</td>


      <td width="29%"><code>std::allocator&lt;
void &gt;</code></td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>fifo_scheduler</code>
synopsis 类模板 <code>fifo_scheduler</code> 的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt;<br> class FifoWorker = fifo_worker&lt;&gt;,<br> class Allocator = std::allocator&lt; void &gt; &gt;<br> class fifo_scheduler : noncopyable<br> {<br> public:<br> <a href="#fifo_scheduler::fifo_scheduler">fifo_scheduler</a>( bool waitOnEmptyQueue = false );<br><br> typedef <i>implementation-defined</i> processor_handle;<br><br> class processor_context : noncopyable<br> {<br> processor_context(<br> fifo_scheduler &amp; scheduler,<br> const processor_handle &amp; theHandle );<br><br> fifo_scheduler &amp; my_scheduler() const;<br> const processor_handle &amp; my_handle() const;<br><br> friend class fifo_scheduler;<br> friend class event_processor&lt; fifo_scheduler &gt;;<br> };<br><br> template&lt; class Processor &gt;<br> processor_handle <a href="#create_processor">create_processor</a>();<br> template&lt; class Processor, typename Param1 &gt;<br> processor_handle <a href="#create_processor1">create_processor</a>( Param1 param1 );<br><br> // More create_processor overloads 更多 create_processor 重载<br><br> void <a href="#destroy_processor">destroy_processor</a>( processor_handle processor );<br><br> void <a href="#initiate_processor">initiate_processor</a>( processor_handle processor );<br> void <a href="#terminate_processor">terminate_processor</a>( processor_handle processor );<br><br> typedef intrusive_ptr&lt; const event_base &gt; event_ptr_type;<br><br> void <a href="#queue_event">queue_event</a>(<br> const processor_handle &amp; processor,<br> const event_ptr_type &amp; pEvent );<br><br> typedef typename FifoWorker::work_item work_item;<br><br> void <a href="#queue_work_item">queue_work_item</a>( const work_item &amp; item );<br><br> void <a href="#fifo_scheduler::terminate">terminate</a>();<br> bool <a href="#fifo_scheduler::terminated">terminated</a>() const;<br><br> unsigned long <a href="#operatorfuncall">operator()</a>(<br> unsigned long maxEventCount = 0 );<br> };<br>}<br>}<br></pre>


<h3>Class template <code>fifo_scheduler</code>
constructor 类模板 <code>fifo_scheduler</code> 的构造函数</h3>


<pre><a name="fifo_scheduler::fifo_scheduler" id="fifo_scheduler::fifo_scheduler">fifo_scheduler</a>( bool waitOnEmptyQueue = false );<br></pre>


<p><b>Effects</b>: Constructs a <code>fifo_scheduler&lt;&gt;</code>
object. In multi-threaded builds, <code>waitOnEmptyQueue</code>
is forwarded to the constructor of a data member of type <code>FifoWorker</code>.
In single-threaded builds, the <code>FifoWorker</code>
data member is default-constructed<br>


<b>作用：</b>构造一个 <code>fifo_scheduler&lt;&gt;</code>
对象。在多线程构建中，<code>waitOnEmptyQueue</code>
被前转至一个类型为 <code>FifoWorker</code> 的数据成员的构造函数。在单线程构建中，<code>FifoWorker</code>
数据成员是缺省构造的<br>


<b>Note</b>: In single-threaded builds the <code>fifo_scheduler&lt;&gt;</code>
constructor does not accept any parameters and <code>operator()()</code>
thus always returns to the caller when the event queue is empty<b><br>


说明：</b>在单线程构造中，<code>fifo_scheduler&lt;&gt;</code>
构造函数不接受任何参数，所以当事件队列为空时，<code>operator()()</code> 总是返回至调用者</p>


<h3>Class template <code>fifo_scheduler</code>
modifier functions 类模板 <code>fifo_scheduler</code>
的可变函数</h3>


<pre>template&lt; class Processor &gt;<br>processor_handle <a name="create_processor" id="create_processor">create_processor</a>();<br></pre>


<p><b>Requires</b>: The <code>Processor</code>
type must be a direct or indirect subtype of the <a href="#ClassTemplateevent_processor"><code>event_processor</code></a>
class template<b><br>


要求：</b>类型 <code>Processor</code>
必须是 <a href="reference.html#ClassTemplateevent_processor"><code>event_processor</code></a>
类模板的直接或间接子类<br>


<b>Effects</b>: Creates and passes to <code>FifoWorker::queue_work_item()</code>
an object of type <code>FifoWorker::work_item</code> that,
when later executed in <code>FifoWorker::operator()()</code>,
leads to a call to the constructor of <code>Processor</code>,
passing an appropriate <code>processor_context</code>
object as the only argument<br>


<b>作用：</b>创建一个 <code>FifoWorker::work_item</code>
类型的对象并传递给 <code>FifoWorker::queue_work_item()</code>，稍后执行 <code>FifoWorker::operator()()</code>
时，调用 <code>Processor</code> 的构造函数，传入一个适当的 <code>processor_context</code>
对象作为唯一的参数<br>


<b>Returns</b>: A <code>processor_handle</code>
object that henceforth identifies the created event processor object<br>


<b>返回：</b>一个 <code>processor_handle</code>
对象，用于标识被创建的事件处理器对象<br>


<b>Throws</b>: Any exceptions propagated from <code>FifoWorker::work_item()</code>
and <code>FifoWorker::queue_work_item()</code><br>


<b>抛出：</b>从 <code>FifoWorker::work_item()</code>
和 <code>FifoWorker::queue_work_item()</code> 传出的任意异常<code></code><br>


<b>Caution</b>: The current implementation of this function
makes an (indirect) call to global <code>operator new()</code>.
Unless global <code>operator new()</code> is replaced,
care must be taken when to call this function in applications with hard
real-time requirements<br>


<b>警告：</b>该函数的当前实现会(间接)调用全局的 <code>operator new()</code>.
除非全局 <code>operator new()</code>
被替换，否则在对实时性在严格要求的应用程序中必须小心调用该函数</p>


<pre>template&lt; class Processor, typename Param1 &gt;<br>processor_handle <a name="create_processor1" id="create_processor1">create_processor( Param1 param1 )</a>;<br></pre>


<p><b>Requires</b>: The <code>Processor</code>
type must be a direct or indirect subtype of the <a href="#ClassTemplateevent_processor"><code>event_processor</code></a>
class template<br>


<b>要求：</b>类型 <code>Processor</code>
必须是 <a href="reference.html#ClassTemplateevent_processor"><code>event_processor</code></a>
类模板的直接或间接子类<br>


<b>Effects</b>: Creates and passes to <code>FifoWorker::queue_work_item()</code>
an object of type <code>FifoWorker::work_item</code> that,
when later executed in <code>FifoWorker::operator()()</code>,
leads to a call to the constructor of <code>Processor</code>,
passing an appropriate <code>processor_context</code>
object and <code>param1</code> as arguments<br>


<b>作用：</b>创建一个 <code>FifoWorker::work_item</code>
类型的对象并传递给 <code>FifoWorker::queue_work_item()</code>，稍后执行 <code>FifoWorker::operator()()</code>
时，调用 <code>Processor</code> 的构造函数，传入一个适当的 <code>processor_context</code>
对象和 <code>param1</code> 作为参数<b><br>


Returns</b>: A <code>processor_handle</code>
object that henceforth identifies the created event processor object<br>


<b>返回：</b>一个 <code>processor_handle</code>
对象，用于标识被创建的事件处理器对象<br>


<b>Throws</b>: Any exceptions propagated from <code>FifoWorker::work_item()</code>
and <code>FifoWorker::queue_work_item()</code><code></code><br>


<b>抛出：</b>从 <code>FifoWorker::work_item()</code>
和 <code>FifoWorker::queue_work_item()</code> 传出的任意异常<b><br>


Note</b>: <code>boost::ref()</code> and <code>boost::cref()</code>
can be used to pass arguments by reference rather than by copy. <code>fifo_scheduler&lt;&gt;</code>
has 5 additional <code>create_processor&lt;&gt;</code>
overloads, allowing to pass up to 6 custom arguments to the
constructors of event processors<br>


<b>
说明：</b><code>boost::ref()</code> 和 <code>boost::cref()</code>
可用于以引用方式而不是拷贝的方式传递参数。<code>fifo_scheduler&lt;&gt;</code>
有5个额外的 <code>create_processor&lt;&gt;</code>
重载，允许传递最多6个定制的参数给事件处理器的构造函数<br>


<b>Caution</b>: The current implementation of this and all
other overloads make (indirect) calls to global <code>operator
new()</code>. Unless global <code>operator new()</code>
is replaced, care must be taken when to call these overloads in
applications with hard real-time requirements<br>


<b>警告：</b>该函数及所有其它重载的当前实现会(间接)调用全局的 <code>operator
new()</code>.
除非全局 <code>operator new()</code>
被替换，否则在对实时性在严格要求的应用程序中必须小心调用该函数</p>


<pre>void <a name="destroy_processor" id="destroy_processor">destroy_processor</a>( processor_handle processor );<br></pre>


<p><b>Requires</b>: <code>processor</code>
was obtained from a call to one of the <code>create_processor&lt;&gt;()</code>
overloads on the same <code>fifo_scheduler&lt;&gt;</code>
object<br>


<b>要求：</b><code>processor</code> 是通过调用 <code>create_processor&lt;&gt;()</code>
的一个对于同一个 <code>fifo_scheduler&lt;&gt;</code>
对象的重载而获得的<br>


<b>Effects</b>: Creates and passes to <code>FifoWorker::queue_work_item()</code>
an object of type <code>FifoWorker::work_item</code> that,
when later executed in <code>FifoWorker::operator()()</code>,
leads to a call to the destructor of the event processor object
associated with <code>processor</code>. The object is
silently discarded if the event processor object has been destructed
before<br>


<b>作用：</b>创建一个 <code>FifoWorker::work_item</code>
类型的对象并传递给 <code>FifoWorker::queue_work_item()</code>，稍后执行 <code>FifoWorker::operator()()</code>
时，引发对与 <code>Processor</code>
相关联的事件处理器对象的析构函数的调用。如果事件处理器对象在这之前已析构，则忽略该对象<br>


<b>Throws</b>: Any exceptions propagated from <code>FifoWorker::work_item()</code>
and <code>FifoWorker::queue_work_item()</code><code></code><code></code><br>


<b>抛出：</b>从 <code>FifoWorker::work_item()</code>
和 <code>FifoWorker::queue_work_item()</code> 传出的任意异常<br>


<b>Caution</b>: The current implementation of this function
leads to an (indirect) call to global <code>operator delete()</code>
(the call is made when the last <code>processor_handle</code>
object associated with the event processor object is destructed).
Unless global <code>operator delete()</code> is replaced,
care must be taken when to call this function in applications with hard
real-time requirements<br>


<b>警告：</b>该函数及所有其它重载的当前实现会(间接)调用全局的 <code>operator&nbsp;</code><code>delete</code><code>()</code>
(在最后一个与事件处理器对象相关联的 <code>processor_handle</code>
对象被析构时调用)。除非全局 <code>operator&nbsp;</code><code>delete</code><code>()</code>
被替换，否则在对实时性在严格要求的应用程序中必须小心调用该函数</p>


<pre>void <a name="initiate_processor" id="initiate_processor">initiate_processor</a>( processor_handle processor );<br></pre>


<p><b>Requires</b>: <code>processor</code>
was obtained from a call to one of the <code>create_processor()</code>
overloads on the same <code>fifo_scheduler&lt;&gt;</code>
object<br>


<b>要求：</b><code>processor</code> 是通过调用 <code>create_processor&lt;&gt;()</code>
的一个对于同一个 <code>fifo_scheduler&lt;&gt;</code>
对象的重载而获得的<br>


<b>Effects</b>: Creates and passes to <code>FifoWorker::queue_work_item()</code>
an object of type <code>FifoWorker::work_item</code> that,
when later executed in <code>FifoWorker::operator()()</code>,
leads to a call to <code><a href="#event_processor::initiate">initiate</a>()</code>
on the event processor object associated with <code>processor</code>.
The object is silently discarded if the event processor object has been
destructed before<br>


<b>作用：</b>创建一个 <code>FifoWorker::work_item</code>
类型的对象并传递给 <code>FifoWorker::queue_work_item()</code>，稍后执行 <code>FifoWorker::operator()()</code>
时，引发对与 <code>processor</code> 相关联的事件处理器的 <code><a href="reference.html#event_processor::initiate">initiate</a>()</code>
的调用。如果事件处理器对象在这之前已析构，则忽略该对象<br>


<b>Throws</b>: Any exceptions propagated from <code>FifoWorker::work_item()</code>
and <code>FifoWorker::queue_work_item()</code><code></code><code></code><code></code><br>


<b>抛出：</b>从 <code>FifoWorker::work_item()</code>
和 <code>FifoWorker::queue_work_item()</code> 传出的任意异常</p>


<pre>void <a name="terminate_processor" id="terminate_processor">terminate_processor</a>( processor_handle processor );<br></pre>


<p><b>Requires</b>: <code>processor</code>
was obtained from a call to one of the <code>create_processor&lt;&gt;()</code>
overloads on the same <code>fifo_scheduler&lt;&gt;</code>
object<br>


<b>要求：</b><code>processor</code> 是通过调用 <code>create_processor&lt;&gt;()</code>
的一个对于同一个 <code>fifo_scheduler&lt;&gt;</code>
对象的重载而获得的<br>


<b>Effects</b>: Creates and passes to <code>FifoWorker::queue_work_item()</code>
an object of type <code>FifoWorker::work_item</code> that,
when later executed in <code>FifoWorker::operator()()</code>,
leads to a call to <code><a href="#event_processor::terminate">terminate</a>()</code>
on the event processor object associated with <code>processor</code>.
The object is silently discarded if the event processor object has been
destructed before<br>


<b>作用：</b>创建一个 <code>FifoWorker::work_item</code>
类型的对象并传递给 <code>FifoWorker::queue_work_item()</code>，稍后执行 <code>FifoWorker::operator()()</code>
时，引发对与 <code>processor</code> 相关联的事件处理器的 <code><a href="reference.html#event_processor::terminate">terminate</a></code><code>()</code>
的调用。如果事件处理器对象在这之前已析构，则忽略该对象<br>


<b>Throws</b>: Any exceptions propagated from <code>FifoWorker::work_item()</code>
and <code>FifoWorker::queue_work_item()</code><code></code><code></code><code></code><code></code><br>


<b>抛出：</b>从 <code>FifoWorker::work_item()</code>
和 <code>FifoWorker::queue_work_item()</code> 传出的任意异常</p>


<pre>void <a name="queue_event" id="queue_event">queue_event</a>(<br> const processor_handle &amp; processor,<br> const event_ptr_type &amp; pEvent );<br></pre>


<p><b>Requires</b>: <code>pEvent.get() != 0</code>
and <code>processor</code> was obtained from a call to one
of the <code>create_processor&lt;&gt;()</code>
overloads on the same <code>fifo_scheduler&lt;&gt;</code>
object<br>


<b>作用：</b><code>pEvent.get() != 0</code> 且 <code>processor</code>
是通过调用 <code>create_processor&lt;&gt;()</code>
的一个对于同一个 <code>fifo_scheduler&lt;&gt;</code>
对象的重载而获得的<br>


<b>Effects</b>: Creates and passes to <code>FifoWorker::queue_work_item()</code>
an object of type <code>FifoWorker::work_item</code> that,
when later executed in <code>FifoWorker::operator()()</code>,
leads to a call to <code><a href="#event_processor::process_event">process_event</a>(
*pEvent )</code> on the event processor object associated with <code>processor</code>.
The object is silently discarded if the event processor object has been
destructed before<br>


<b>作用：</b>创建一个 <code>FifoWorker::work_item</code>
类型的对象并传递给 <code>FifoWorker::queue_work_item()</code>，稍后执行 <code>FifoWorker::operator()()</code>
时，引发对与 <code>processor</code> 相关联的事件处理器的 <code><a href="reference.html#event_processor::process_event">process_event</a>(
*pEvent )</code><code></code>
的调用。如果事件处理器对象在这之前已析构，则忽略该对象<br>


<b>Throws</b>: Any exceptions propagated from <code>FifoWorker::work_item()</code>
and <code>FifoWorker::queue_work_item()</code><code></code><code></code><code></code><code></code><code></code><br>


<b>抛出：</b>从 <code>FifoWorker::work_item()</code>
和 <code>FifoWorker::queue_work_item()</code> 传出的任意异常</p>


<pre>void <a name="queue_work_item" id="queue_work_item">queue_work_item</a>( const work_item &amp; item );<br></pre>


<p><b>Effects</b>: <code>FifoWorker::queue_work_item(
item );</code><br>


<b>作用：</b><code>FifoWorker::queue_work_item(
item );</code><br>


<b>Throws</b>: Any exceptions propagated from the above call<code></code><code></code><code></code><code></code><code></code><code></code><br>


<b>抛出：</b>从以上调用中传出的任意异常</p>


<pre>void <a name="fifo_scheduler::terminate" id="fifo_scheduler::terminate">terminate</a>();<br></pre>


<p><b>Effects</b>: <code>FifoWorker::terminate()</code><br>


<b>作用：</b><code>FifoWorker::terminate()</code><br>


<b>Throws</b>: Any exceptions propagated from the above call<code></code><code></code><code></code><code></code><code></code><code></code><br>


<b>抛出：</b>从以上调用中传出的任意异常</p>


<pre>unsigned long <a name="operatorfuncall" id="operatorfuncall">operator()</a>( unsigned long maxEventCount = 0 );<br></pre>


<p><b>Requires</b>: Must only be called from exactly
one thread<b><br>


</b><b>要求：</b>只能用单个线程中调用<b><br>


</b><b>
Effects</b>: <code>FifoWorker::operator()( maxEventCount )</code><br>


<b>作用：</b><code>FifoWorker::operator()( maxEventCount
)</code><br>


<b>Returns</b>: The return value of the above call<br>


<b>返回：</b>以上调用的返回值<br>


<b>Throws</b>: Any exceptions propagated from the above call<code></code><code></code><code></code><code></code><code></code><code></code><br>


<b>抛出：</b>从以上调用中传出的任意异常</p>


<h3>Class template <code>fifo_scheduler</code>
observer functions 类模板 <code>fifo_scheduler</code>
的常性函数</h3>


<pre>bool <a name="fifo_scheduler::terminated" id="fifo_scheduler::terminated">terminated</a>() const;<br></pre>


<p><b>Requires</b>: Must only be called from the
thread that also calls <code>operator()()</code><br>


<b>要求：</b>只能从调用 <code>operator()()</code>
的线程中调用<code></code><br>


<b>Returns</b>: <code>FifoWorker::terminated();<br>


</code><b>返回：</b><code>FifoWorker::terminated();</code></p>


<h1>Header &lt;boost/statechart/<a name="exception_translator.hpp" id="exception_translator.hpp">exception_translator.hpp</a>&gt;</h1>


<h2><a name="ClassTemplateexception_translator" id="ClassTemplateexception_translator">Class template <code>exception_translator
类模板</code> <code>exception_translator</code></a></h2>


<p>This class template is a model of the <a href="#ExceptionTranslator">ExceptionTranslator</a>
concept.<br>


这个类模板符合 <a href="reference.html#ExceptionTranslator">异常转换器</a>
概念。</p>


<h3>Class template <code>exception_translator</code>
parameters 类模板 <code>exception_translator</code> 的参数</h3>


<table summary="exception_translator parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="12%"><b>Template parameter 模板参数</b></td>


      <td width="30%"><b>Requirements 要求</b></td>


      <td width="35%"><b>Semantics 语义</b></td>


      <td width="24%"><b>Default 缺省值</b></td>


    </tr>


    <tr>


      <td width="12%"><code>ExceptionEvent</code></td>


      <td width="30%">A model of the <a href="#Event">Event</a>
concept<br>


符合 <a href="reference.html#Event">事件</a>
概念的类型</td>


      <td width="35%">The type of event that is dispatched
when an exception is propagated into the framework<br>


当一个异常被传播到框架内时被分派的事件类型</td>


      <td width="24%"><code>exception_thrown</code></td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>exception_translator</code>
synopsis &amp; semantics 类模板 <code>exception_translator</code>
的摘要和语义</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> class exception_thrown : public event&lt; exception_thrown &gt; {};<br><br> template&lt; class ExceptionEvent = exception_thrown &gt;<br> class exception_translator<br> {<br> public:<br> template&lt; class Action, class ExceptionEventHandler &gt;<br> result operator()(<br> Action action,<br> ExceptionEventHandler eventHandler )<br> {<br> try<br> {<br> return action();<br> }<br> catch( ... )<br> {<br> return eventHandler( ExceptionEvent() );<br> }<br> }<br> };<br>}<br>}<br></pre>


<h1>Header &lt;boost/statechart/<br>


<a name="null_exception_translator.hpp" id="null_exception_translator.hpp">null_exception_translator.hpp</a>&gt;</h1>


<h2><a name="Classnull_exception_translator" id="Classnull_exception_translator">Class <code>null_exception_translator
类</code> <code>null_exception_translator</code></a></h2>


<p>This class is a model of the <a href="#ExceptionTranslator">ExceptionTranslator</a>
concept.<br>


这个类符合 <a href="reference.html#ExceptionTranslator">异常转换器</a>
概念。</p>


<h3>Class <code>null_exception_translator</code>
synopsis &amp; semantics 类 <code>null_exception_translator</code>
的摘要和语义</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> class null_exception_translator<br> {<br> public:<br> template&lt; class Action, class ExceptionEventHandler &gt;<br> result operator()(<br> Action action, ExceptionEventHandler )<br> {<br> return action();<br> }<br> };<br>}<br>}<br></pre>


<h1>Header &lt;boost/statechart/<a name="simple_state.hpp" id="simple_state.hpp">simple_state.hpp</a>&gt;</h1>


<h2><a name="Enumhistory_mode" id="Enumhistory_mode">Enum
<code>history_mode </code>枚举
<code>history_mode</code></a></h2>


<p>Defines the history type of a state.<br>


定义状态的历史类型。</p>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> enum history_mode<br> {<br> has_no_history,<br> has_shallow_history,<br> has_deep_history,<br> has_full_history // shallow &amp; deep 浅和深<br> };<br>}<br>}<br></pre>


<h2><a name="ClassTemplatesimple_state" id="ClassTemplatesimple_state">Class template <code>simple_state
类模板</code> <code>simple_state</code></a></h2>


<p>This is the base class template for all models of the <a href="#SimpleState">SimpleState</a> concept. Such
models must not call any of the following <code>simple_state&lt;&gt;</code>
member functions from their constructors:<br>


这是所有符合 <a href="reference.html#SimpleState">简单状态</a>
概念的类型的基类模板。这些类型必须不能从它们的构造函数中调用以下任意一个 <code>simple_state&lt;&gt;</code>
成员函数：</p>


<pre>void <b>post_event</b>(<br> const intrusive_ptr&lt; const event_base &gt; &amp; );<br>void <b>post_event</b>( const event_base &amp; );<br><br>template&lt;<br> class HistoryContext,<br> <i>implementation-defined-unsigned-integer-type<br></i> orthogonalPosition &gt;<br>void <b>clear_shallow_history</b>();<br>template&lt;<br> class HistoryContext,<br> <i>implementation-defined-unsigned-integer-type<br></i> orthogonalPosition &gt;<br>void <b>clear_deep_history</b>();<br><br>outermost_context_type &amp; <b>outermost_context</b>();<br>const outermost_context_type &amp; <b>outermost_context</b>() const;<br><br>template&lt; class OtherContext &gt;<br>OtherContext &amp; <b>context</b>();<br>template&lt; class OtherContext &gt;<br>const OtherContext &amp; <b>context</b>() const;<br><br>template&lt; class Target &gt;<br>Target <b>state_cast</b>() const;<br>template&lt; class Target &gt;<br>Target <b>state_downcast</b>() const;<br><br>state_iterator <b>state_begin</b>() const;<br>state_iterator <b>state_end</b>() const;<br></pre>


<p>States that need to call any of these member functions from
their constructors must derive from the <code><a href="#ClassTemplatestate">state</a></code>
class template.<br>


必须从其构造函数中调用以上某一个成员函数的状态，必须派生自 <code><a href="reference.html#ClassTemplatestate">state</a></code>
类模板。</p>


<h3>Class template <code>simple_state</code>
parameters 类模板 <code>simple_state</code> 的参数</h3>


<table summary="simple_state parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="15%"><b>Template parameter 模板参数</b></td>


      <td width="51%"><b>Requirements 要求</b></td>


      <td width="18%"><b>Semantics 语义</b></td>


      <td width="19%"><b>Default 缺省值</b></td>


    </tr>


    <tr>


      <td width="15%"><code>MostDerived</code></td>


      <td width="51%">The most-derived subtype of this
class template<br>


这个类模板的最底层子类型</td>


      <td width="18%">&nbsp;</td>


      <td width="19%">&nbsp;</td>


    </tr>


    <tr>


      <td width="15%"><code>Context</code></td>


      <td width="51%">A most-derived direct or indirect
subtype of the <code><a href="#ClassTemplatestate_machine">state_machine</a></code>
or <code><a href="#ClassTemplateasynchronous_state_machine">asynchronous_state_machine</a></code>
class templates or a model of the <a href="#SimpleState">SimpleState</a>
or <a href="#State">State</a> concepts or an
instantiation of the <code><a href="#ClassTemplatesimple_state">simple_state&lt;&gt;::orthogonal</a></code>
class template. Must be a complete type<br>


      <code><a href="reference.html#ClassTemplatestate_machine">state_machine</a></code>
或 <code><a href="reference.html#ClassTemplateasynchronous_state_machine">asynchronous_state_machine</a></code>
类模板的一个最底层直接或间接子类，或者是符合 <a href="reference.html#SimpleState">简
单状态</a> 或 <a href="reference.html#State">状态</a>
概念的一个类型，或者是 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;::orthogonal</a></code>
类模板的一个实例。必须是完整类型</td>


      <td width="18%">Defines the states' position in the
state hierarchy<br>


定义了该状态在状态层次中的位置</td>


      <td width="19%">&nbsp;</td>


    </tr>


    <tr>


      <td width="15%"><code>InnerInitial</code></td>


      <td width="51%">An <code>mpl::list&lt;&gt;</code>
containing models of the <a href="#SimpleState">SimpleState</a>
or <a href="#State">State</a> concepts or
instantiations of the <code><a href="#ClassTemplateshallow_history">shallow_history</a></code>
or <code><a href="#ClassTemplatedeep_history">deep_history</a></code>
class templates. If there is only a single inner initial state that is
not a template instantiation then it can also be passed directly,
without wrapping it into an <code>mpl::list&lt;&gt;</code>.
The <code>Context</code> argument passed to the <code><a href="#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
or <code><a href="#ClassTemplatestate">state&lt;&gt;</a></code>
base of&nbsp;each state in the list must correspond to the
orthogonal region it belongs to. That is, the first state in the list
must pass <code>MostDerived::orthogonal&lt; 0 &gt;</code>,
the second <code>MostDerived::orthogonal&lt; 1 &gt;</code>
and so forth. <code>MostDerived::orthogonal&lt; 0 &gt;</code>
and <code>MostDerived</code> are synonymous<br>


一个 <code>mpl::list&lt;&gt;</code>，其中包含有符合 <a href="reference.html#SimpleState">简单状态</a> 或 <a href="reference.html#State">状态</a> 概念的类型或&nbsp;<code><a href="reference.html#ClassTemplateshallow_history">shallow_history</a></code>
或 <code><a href="reference.html#ClassTemplatedeep_history">deep_history</a></code>
类模板的实例。如果只有单个内层初始状态，且不是模板实例，那么也可以直接传递该状态而无需用 <code>mpl::list&lt;&gt;</code>
来包装。列表中每个状态的 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
或 <code><a href="reference.html#ClassTemplatestate">state&lt;&gt;</a></code>
基类的 <code>Context</code> 参数必须与其所属的正交区域相符。即，列表中的第一个状态必须传入 <code>MostDerived::orthogonal&lt;
0 &gt;</code>,
第二个状态必须传入 <code>MostDerived::orthogonal&lt; 1 &gt;</code>
等等。 <code>MostDerived::orthogonal&lt; 0 &gt;</code>
和 <code>MostDerived</code> 同义</td>


      <td width="18%">Defines the inner initial state for
each orthogonal region. By default, a state does not have inner states<br>


定义每个正交区域的内层初始状态。缺省情况下，一个状态没有内层状态</td>


      <td width="19%"><i><code>unspecified<br>


      </code></i><i><code>未指定</code></i></td>


    </tr>


    <tr>


      <td width="15%"><code>historyMode</code></td>


      <td width="51%">One of the values defined in the <code><a href="#Enumhistory_mode">history_mode</a></code>
enumeration<br>


在 <code><a href="reference.html#Enumhistory_mode">history_mode</a></code>
枚举中定义的某个值</td>


      <td width="18%">Defines whether the state saves
shallow, deep or both histories upon exit<br>


定义该状态在退出时是否保存浅历史、深历史或两者均保存</td>


      <td width="19%"><code>has_no_history</code></td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>simple_state</code>
synopsis 类模板 <code>simple_state</code> 的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt;<br> class MostDerived,<br> class Context,<br> class InnerInitial = <i>unspecified</i>,<br> history_mode historyMode = has_no_history &gt;<br> class simple_state : <i>implementation-defined</i><br>{<br>public:<br>// by default, a state has no reactions <br>// 缺省情况下，状态不带反应<br>typedef mpl::list&lt;&gt; reactions;<br>// see template parameters 见模板参数<br>template&lt; <i>implementation-defined-unsigned-integer-type<br></i> innerOrthogonalPosition &gt;<br> struct orthogonal<br> {<br> // <i>implementation-defined 由具体实现定义</i><br>};<br>typedef typename Context::outermost_context_type<br>outermost_context_type;<br>outermost_context_type &amp; <a href="#outermost_context">outermost_context</a>();<br> const outermost_context_type &amp; <a href="#outermost_contextconst">outermost_context</a>() const;<br><br> template&lt; class OtherContext &gt;<br> OtherContext &amp; <a href="#context">context</a>();<br> template&lt; class OtherContext &gt;<br> const OtherContext &amp; <a href="#contextconst">context</a>() const;<br><br> template&lt; class Target &gt;<br> Target <a href="#simple_state::state_cast">state_cast</a>() const;<br> template&lt; class Target &gt;<br> Target <a href="#simple_state::state_downcast">state_downcast</a>() const;<br><br> // a model of the StateBase concept 符合状态基概念<br> typedef <i>implementation-defined</i> state_base_type;<br> // a model of the standard Forward Iterator concept <br> // 符合标准的前向迭代器概念<br> typedef <i>implementation-defined</i> state_iterator;<br><br> state_iterator <a href="#simple_state::state_begin">state_begin</a>() const;<br> state_iterator <a href="#simple_state::state_end">state_end</a>() const;<br><br> void <a href="#post_event0">post_event</a>(<br> const intrusive_ptr&lt; const <a href="#Classevent_base">event_base</a> &gt; &amp; );<br> void <a href="#post_event1">post_event</a>( const <a href="#Classevent_base">event_base</a> &amp; );<br><br> <a href="#Classresult">result</a> <a href="#discard_event">discard_event</a>();<br> <a href="#Classresult">result</a> <a href="#forward_event">forward_event</a>();<br> <a href="#Classresult">result</a> <a href="#defer_event">defer_event</a>();<br> template&lt; class DestinationState &gt;<br> <a href="#Classresult">result</a> <a href="#transit1">transit</a>();<br> template&lt;<br> class DestinationState,<br> class TransitionContext,<br> class Event &gt;<br> <a href="#Classresult">result</a> <a href="#transit2">transit</a>(<br> void ( TransitionContext::* )( const Event &amp; ),<br> const Event &amp; );<br> <a href="#Classresult">result</a> <a href="#simple_state::terminate">terminate</a>();<br><br> template&lt;<br> class HistoryContext,<br> <i>implementation-defined-unsigned-integer-type<br></i> orthogonalPosition &gt;<br> void <a href="#clear_shallow_history">clear_shallow_history</a>();<br> template&lt;<br> class HistoryContext,<br> <i>implementation-defined-unsigned-integer-type<br></i> orthogonalPosition &gt;<br> void <a href="#clear_deep_history">clear_deep_history</a>();<br><br> static id_type <a href="#static_type">static_type</a>();<br><br> template&lt; class CustomId &gt;<br> static const CustomId * <a href="#custom_static_type_ptr">custom_static_type_ptr</a>();<br><br> template&lt; class CustomId &gt;<br> static void <a href="#custom_static_type_ptr1">custom_static_type_ptr</a>( const CustomId * );<br><br> // see <a href="#transit1">transit</a>() or <a href="#simple_state::terminate">terminate</a>() effects <br> // 见 <a href="reference.html#transit1">transit</a>() 或 <a href="reference.html#simple_state::terminate">terminate</a>() 的作用<br> void exit() {}<br><br> protected:<br> <a href="#simple_state">simple_state</a>();<br> <a href="#simple_statedtor">~simple_state</a>();<br> };<br>}<br>}<br></pre>


<h3>Class template <code>simple_state</code>
constructor and destructor 类模板 <code>simple_state</code>
的构造函数和析构函数</h3>


<pre><a name="simple_state" id="simple_state">simple_state</a>();<br></pre>


<p><b>Effects</b>: Constructs a state object<br>


<b>作用：</b>构造一个状态对象</p>


<pre><a name="simple_statedtor" id="simple_statedtor">~simple_state</a>();<br></pre>


<p><b>Effects</b>: Pushes all events deferred by the
state into the posted events queue<br>


<b>作用：</b>将所有被该状态延迟的事件压入事件队列</p>


<h3>Class template <code>simple_state</code>
modifier functions 类模板 <code>simple_state</code> 的可变函数</h3>


<pre>void <a name="post_event0" id="post_event0">post_event</a>(<br> const intrusive_ptr&lt; const <a href="#Classevent_base">event_base</a> &gt; &amp; pEvt );<br></pre>


<p><b>Requires</b>: If called from a constructor of a
direct or indirect subtype then the most-derived type must directly or
indirectly derive from the <code>state</code> class
template<b>.</b> All direct and indirect callers must be
exception-neutral<b><br>


</b><b>要求：</b>如果从一个直接或间接子类的构造函数调用，则最底层类型必须直接或间接派生自 <code>state</code>
类模板。所有直接或间接的调用者都必须是异常中立的<b><br>


</b><b>Effects</b>: <a href="#outermost_context"><code>outermost_context</code></a><code>().<a href="#post_event2">post_event</a>( pEvt );</code><br>


<b>作用：</b><a href="reference.html#outermost_context"><code>outermost_context</code></a><code>().<a href="reference.html#post_event2">post_event</a>( pEvt
);</code><br>


<b>Throws</b>: Whatever the above call throws<br>


<b>抛出：</b>以上调用所抛出的任何异常</p>


<pre>void <a name="post_event1" id="post_event1">post_event</a>( const <a href="#Classevent_base">event_base</a> &amp; evt );<br></pre>


<p><b>Requires</b>: If called from a constructor of a
direct or indirect subtype then the most-derived type must directly or
indirectly derive from the <code>state</code> class
template<b>.</b> All direct and indirect callers must be
exception-neutral<b><br>


</b><b>要求：</b>如果从一个直接或间接子类的构造函数调用，则最底层类型必须直接或间接派生自 <code>state</code>
类模板。所有直接或间接的调用者都必须是异常中立的<b><br>


Effects</b>: <a href="#outermost_context"><code>outermost_context</code></a><code>().<a href="#post_event3">post_event</a>( evt );</code><code></code><br>


<b>作用：</b><a href="reference.html#outermost_context"><code>outermost_context</code></a><code>().<a href="reference.html#post_event2">post_event</a>( pEvt
);</code><br>


<b>Throws</b>: Whatever the above call throws<br>


<b>抛出：</b>以上调用所抛出的任何异常</p>


<pre><a href="#Classresult">result</a> <a name="discard_event" id="discard_event">discard_event</a>();<br></pre>


<p><b>Requires</b>: Must only be called from within <code>react</code>
member functions, which are called by <code><a href="#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>
instantiations. All direct and indirect callers must be
exception-neutral<b><br>


</b><b>要求：</b>只能从 <code>react</code>
成员函数内中调用，该成员函数由 <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>
实例调用。所有直接或间接的调用者都必须是异常中立的<br>


<b>Effects</b>: Instructs the state machine to discard the
current event and to continue with the processing of the remaining
events (see <code><a href="#process_event">state_machine&lt;&gt;::process_event</a>()</code>
for details)<br>


<b>作用：</b>指示状态机忽略当前事件，并继续处理其余事件(详情请见 <code><a href="reference.html#process_event">state_machine&lt;&gt;::process_event</a>()</code>)<br>


<b>Returns</b>: A <code><a href="#Classresult">result</a></code>
object. The user-supplied <code>react</code> member
function must return this object to its caller<br>


<b>返回：</b>一个 <code><a href="reference.html#Classresult">result</a></code>
对象。用户提供的 <code>react</code> 成员函数必须返回该对象给它的调用者</p>


<pre><a href="#Classresult">result</a> <a name="forward_event" id="forward_event">forward_event</a>();<br></pre>


<p><b>Requires</b>: Must only be called from within <code>react</code>
member functions, which are called by <code><a href="#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>
instantiations. All direct and indirect callers must be
exception-neutral<b><br>


</b><b>要求：</b>只能从 <code>react</code>
成员函数内中调用，该成员函数由 <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>
实例调用。所有直接或间接的调用者都必须是异常中立的<br>


<b>Effects</b>: Instructs the state machine to forward the
current event to the next state (see <code><a href="#process_event">state_machine&lt;&gt;::process_event</a>()</code>
for details)<br>


<b>作用：</b>指示状态机将当前事件前转到下一个状态(详情请见 <code><a href="reference.html#process_event">state_machine&lt;&gt;::process_event</a>()</code>)<br>


<b>Returns</b>: A <code><a href="#Classresult">result</a></code>
object. The user-supplied <code>react</code> member
function must return this object to its caller<br>


<b>返回：</b>一个 <code><a href="reference.html#Classresult">result</a></code>
对象。用户提供的 <code>react</code> 成员函数必须返回该对象给它的调用者</p>


<pre><a href="#Classresult">result</a> <a name="defer_event" id="defer_event">defer_event</a>();<br></pre>


<p><b>Requires</b>: Must only be called from within <code>react</code>
member functions, which are called by <code><a href="#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>
instantiations. All direct and indirect callers must be
exception-neutral<b><br>


</b><b>要求：</b>只能从 <code>react</code>
成员函数内中调用，该成员函数由 <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>
实例调用。所有直接或间接的调用者都必须是异常中立的<br>


<b>Effects</b>: Instructs the state machine to defer the
current event and to continue with the processing of the remaining
events (see <code><a href="#process_event">state_machine&lt;&gt;::process_event</a>()</code>
for details)<br>


<b>作用：</b>指示状态机延迟当前事件，并继续处理其余事件(详情请见 <code><a href="reference.html#process_event">state_machine&lt;&gt;::process_event</a>()</code>)<br>


<b>Returns</b>: A <code><a href="#Classresult">result</a></code>
object. The user-supplied <code>react</code> member
function must return this object to its caller<br>


<b>返回：</b>一个 <code><a href="reference.html#Classresult">result</a></code>
对象。用户提供的 <code>react</code> 成员函数必须返回该对象给它的调用者<br>


<b>Throws</b>: Any exceptions propagated from <code>Allocator::rebind&lt;&gt;::other::allocate()</code>
(the template parameter passed to the base class of <code>outermost_context_type</code>)<br>


<b>抛出：</b>从 <code>Allocator::rebind&lt;&gt;::other::allocate()</code>
(传给 <code>outermost_context_type</code> 的基类的模板参数)传出的任何异常</p>


<pre>template&lt; class DestinationState &gt;<br><a href="#Classresult">result</a> <a name="transit1" id="transit1">transit</a>();<br></pre>


<p><b>Requires</b>: Must only be called from within <code>react</code>
member functions, which are called by <code><a href="#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>
instantiations. All direct and indirect callers must be
exception-neutral<b><br>


</b><b>要求：</b>只能从 <code>react</code>
成员函数内中调用，该成员函数由 <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>
实例调用。所有直接或间接的调用者都必须是异常中立的<br>


<b>Effects</b>:&nbsp;<br>


<b>作用：</b></p>


<ol>


  <li>Exits all currently active direct and indirect inner states
of the innermost common context of this state and <code>DestinationState</code>.
Innermost states are exited first. Other states are exited as soon as
all their direct and indirect inner states have been exited. The inner
states of each state are exited according to the number of their
orthogonal region. The state in the orthogonal region with the highest
number is always exited first, then the state in the region with the
second-highest number and so on.<br>


退出该状态与 <code>DestinationState</code>
的最内层公共上下文的所有当前活动的直接及间接内层状态。首先退出最内层的状态。其它状态在其所有直接及间接内层状态退出后立即退出。每个状态的内层状态
根据
它们的正交区域号码顺序退出。最大号码的正交区域中的状态总是首先退出，然后是次大号码区域中的状态，依此类推。<br>


The process of exiting a state consists of the following steps: <br>


退出一个状态的过程包含以下步骤：
    
    <ol>


      <li>If there is an exception pending that has not yet been
handled successfully then only step 5 is executed<br>


如果有未决异常尚未成功处理，则只执行步骤5</li>


      <li>Calls the <code>exit</code> member
function (see <a href="#ClassTemplatesimple_state">synopsis</a>)
of the most-derived state object. If <code>exit()</code>
throws then steps 3 and 4 are not executed<br>


调用最底层的状态对象的 <code>exit</code>
成员函数(见 <a href="reference.html#ClassTemplatesimple_state">摘
要</a>)。如果 <code>exit()</code>
抛出异常，则不执行步骤3和4</li>


      <li>If the state has shallow history then shallow history
information is saved<br>


如果该状态带有浅历史，则保存浅历史信息</li>


      <li>If the state is an innermost state then deep history
information is saved for all direct and indirect outer states that have
deep history<br>


如果该状态为最内层状态，则为所有带有深历史的直接及间接外层状态保存深历史信息</li>


      <li>The state object is destructed<br>


该状态对象被析构</li>


    
    </ol>


  </li>


  <li>Enters (constructs) the state that is both a direct inner
state of the innermost common context and either the <code>DestinationState</code>
itself or a direct or indirect outer state of <code>DestinationState</code><br>


进
入(构造)以下状态，该状态既是最内层公共上下文的直接内层状态，同时也是 <code>DestinationState</code>
状态本身或 <code>DestinationState</code> 的一个直接或间接外层状态<code></code></li>


  <li>Enters (constructs) the tree formed by the direct and
indirect inner states of the previously entered state down to the <code>DestinationState</code>
and beyond depth first. The inner states of each state are entered
according to the number of their orthogonal region. The state in
orthogonal region 0 is always entered first, then the state in region 1
and so on<br>


进入(构造)由前一步所进入的状态向下直至 <code>DestinationState</code>
的所有直接和间接内层状态以深度优先方式所形成的树。每个状态的内层状态依据其正交区域号码的顺序进入。正交区域0中的状态总是首先进入，然后进入区域1
的状态，等等</li>


  <li>Instructs the state machine to discard the current event
and to continue with the processing of the remaining events (see <code><a href="#process_event">state_machine&lt;&gt;::process_event</a>()</code>
for details)<br>


指示状态机忽略当前事件，并继续处理其余事件(详情请见 <code><a href="reference.html#process_event">state_machine&lt;&gt;::process_event</a>()</code>)</li>


</ol>


<p><b>Returns</b>: A <code><a href="#Classresult">result</a></code> object.
The user-supplied <code>react</code> member function must
return this object to its caller<br>


<b>返回：</b>一个 <code><a href="reference.html#Classresult">result</a></code>
对象。用户提供的 <code>react</code> 成员函数必须返回该对象给它的调用者<br>


<b>Throws</b>: Any exceptions propagated from:<br>


<b>抛出：</b>从以下函数传出的任何异常：</p>


<ul>


  <li><code>Allocator::rebind&lt;&gt;::other::allocate()</code>
(the template parameter passed to the base class of <code>outermost_context_type</code>)
    <br>


    <code>Allocator::rebind&lt;&gt;::other::allocate()</code>
(传给 <code>outermost_context_type</code> 的基类的模板参数)</li>


  <li>state constructors&nbsp;<br>


state 构造函数</li>


  <li><code>exit</code> member functions&nbsp;<br>


    <code>exit</code>
成员函数</li>


</ul>


<p><b>Caution</b>: Inevitably destructs this state
before returning to the calling <code>react</code> member
function, which must therefore not attempt to access anything except
stack objects before returning to its caller<b><br>


警告：</b>在返回调用者 <code>react</code>
成员函数之前，该状态不可避免要被析构，因此在返回其调用者之前，不要尝试访问除了栈对象以外的任何东西</p>


<pre>template&lt;<br> class DestinationState,<br> class TransitionContext,<br> class Event &gt;<br><a href="#Classresult">result</a> <a name="transit2" id="transit2">transit</a>(<br> void ( TransitionContext::* )( const Event &amp; ),<br> const Event &amp; );<br></pre>


<p><b>Requires</b>: Must only be called from within <code>react</code>
member functions, which are called by <code><a href="#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>
instantiations. All direct and indirect callers must be
exception-neutral<b><br>


</b><b>要求：</b>只能从 <code>react</code>
成员函数内中调用，该成员函数由 <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>
实例调用。所有直接或间接的调用者都必须是异常中立的<br>


<b>Effects</b>:<b><br>


作用：</b>
</p>


<ol>


  <li>Exits all currently active direct and indirect inner states
of the innermost common context of this state and <code>DestinationState</code>.
Innermost states are exited first. Other states are exited as soon as
all their direct and indirect inner states have been exited. The inner
states of each state are exited according to the number of their
orthogonal region. The state in the orthogonal region with the highest
number is always exited first, then the state in the region with the
second-highest number and so on.<br>


退出该状态与 <code>DestinationState</code>
的最内层公共上下文的所有当前活动的直接及间接内层状态。首先退出最内层的状态。其它状态在其所有直接及间接内层状态退出后立即退出。每个状态的内层状态
根据
它们的正交区域号码顺序退出。最大号码的正交区域中的状态总是首先退出，然后是次大号码区域中的状态，依此类推。<br>


The process of exiting a state consists of the following steps:<br>


退出一个状态的过程包含以下步骤：
    
    <ol>


      <li>If there is an exception pending that has not yet been
handled successfully then only step 5 is executed<br>


如果有未决异常尚未成功处理，则只执行步骤5</li>


      <li>Calls the <code>exit</code> member
function (see <a href="#ClassTemplatesimple_state">synopsis</a>)
of the most-derived state object. If <code>exit()</code>
throws then steps 3 and 4 are not executed<br>


调用最底层的状态对象的 <code>exit</code>
成员函数(见 <a href="reference.html#ClassTemplatesimple_state">摘
要</a>)。如果 <code>exit()</code>
抛出异常，则不执行步骤3和4</li>


      <li>If the state has shallow history then shallow history
information is saved<br>


如果该状态带有浅历史，则保存浅历史信息</li>


      <li>If the state is an innermost state then deep history
information is saved for all direct and indirect outer states that have
deep history<br>


如果该状态为最内层状态，则为所有带有深历史的直接及间接外层状态保存深历史信息</li>


      <li>The state object is destructed<br>


该状态对象被析构</li>


    
    </ol>


  </li>


  <li>Executes the passed transition action, forwarding the
passed event<br>


执行传入的转换动作，并前转传入的事件</li>


  <li>Enters (constructs) the state that is both a direct inner
state of the innermost common context and either the <code>DestinationState</code>
itself or a direct or indirect outer state of <code>DestinationState</code><code></code><br>


进
入(构造)以下状态，该状态既是最内层公共上下文的直接内层状态，同时也是 <code>DestinationState</code>
状态本身或 <code>DestinationState</code> 的一个直接或间接外层状态</li>


  <li>Enters (constructs) the tree formed by the direct and
indirect inner states of the previously entered state down to the <code>DestinationState</code>
and beyond depth first. The inner states of each state are entered
according to the number of their orthogonal region. The state in
orthogonal region 0 is always entered first, then the state in region 1
and so on<br>


进入(构造)由前一步所进入的状态向下直至 <code>DestinationState</code>
的所有直接和间接内层状态以深度优先方式所形成的树。每个状态的内层状态依据其正交区域号码的顺序进入。正交区域0中的状态总是首先进入，然后进入区域1
的状态，等等</li>


  <li>Instructs the state machine to discard the current event
and to continue with the processing of the remaining events (see <code><a href="#process_event">state_machine&lt;&gt;::process_event</a>()</code>
for details)<br>


指示状态机忽略当前事件，并继续处理其余事件(详情请见 <code><a href="reference.html#process_event">state_machine&lt;&gt;::process_event</a>()</code>)</li>


</ol>


<p><b>Returns</b>: A <code><a href="#Classresult">result</a></code> object.
The user-supplied <code>react</code> member function must
return this object to its caller<br>


<b>返回：</b>一个 <code><a href="reference.html#Classresult">result</a></code>
对象。用户提供的 <code>react</code> 成员函数必须返回该对象给它的调用者<br>


<b>Throws</b>: Any exceptions propagated from:<br>


<b>抛出：</b>从以下函数传出的任何异常：</p>


<ul>


  <li><code>Allocator::rebind&lt;&gt;::other::allocate()</code>
(the template parameter passed to the base class of <code>outermost_context_type</code>)<br>


    <code>Allocator::rebind&lt;&gt;::other::allocate()</code>
(传给 <code>outermost_context_type</code> 的基类的模板参数)</li>


  <li>state constructors<br>


state 构造函数</li>


  <li><code>exit</code> member functions&nbsp;<br>


    <code>exit</code>
成员函数</li>


  <li>the transition action<br>


    <code></code>指定的转换函数</li>


</ul>


<p><b>Caution</b>: Inevitably destructs this state
before returning to the calling <code>react</code> member
function, which must therefore not attempt to access anything except
stack objects before returning to its caller<b><br>


警告：</b>在返回调用者 <code>react</code>
成员函数之前，该状态不可避免要被析构，因此在返回其调用者之前，不要尝试访问除了栈对象以外的任何东西</p>


<pre><a href="#Classresult">result</a> <a name="simple_state::terminate" id="simple_state::terminate">terminate</a>();<br></pre>


<p><b>Requires</b>: Must only be called from within <code>react</code>
member functions, which are called by <code><a href="#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>
instantiations. All direct and indirect callers must be
exception-neutral<b><br>


</b><b>要求：</b>只能从 <code>react</code>
成员函数内中调用，该成员函数由 <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction&lt;&gt;</a></code>
实例调用。所有直接或间接的调用者都必须是异常中立的<br>


<b>Effects</b>: Exits this state and all its direct and
indirect inner states. Innermost states are exited first. Other states
are exited as soon as all their direct and indirect inner states have
been exited. The inner states of each state are exited according to the
number of their orthogonal region. The state in the orthogonal region
with the highest number is always exited first, then the state in the
region with the second-highest number and so on.<br>


<b>作用：</b>退出该状态及其所有直接及间接内层状态。首先退出最内层的状态。其它状态在其所有直接及间接内层状态退出后
立即退出。每个状态的内层状态根据
它们的正交区域号码顺序退出。最大号码的正交区域中的状态总是首先退出，然后是次大号码区域中的状态，依此类推。<br>


The process of exiting a state consists of the following steps:<br>


退出一个状态的过程包含以下步骤：</p>


<ol>


  <li>If there is an exception pending that has not yet been
handled successfully then only step 5 is executed<br>


如果有未决异常尚未成功处理，则只执行步骤5</li>


  <li>Calls the <code>exit</code> member function
(see <a href="#ClassTemplatesimple_state">synopsis</a>)
of the most-derived state object. If <code>exit()</code>
throws then steps 3 and 4 are not executed<br>


调用最底层的状态对象的 <code>exit</code>
成员函数(见 <a href="reference.html#ClassTemplatesimple_state">摘
要</a>)。如果 <code>exit()</code>
抛出异常，则不执行步骤3和4</li>


  <li>If the state has shallow history then shallow history
information is saved<br>


如果该状态带有浅历史，则保存浅历史信息</li>


  <li>If the state is an innermost state then deep history
information is saved for all direct and indirect outer states that have
deep history<br>


如果该状态为最内层状态，则为所有带有深历史的直接及间接外层状态保存深历史信息</li>


  <li>The state object is destructed<br>


该状态对象被析构</li>


</ol>


<p>Also instructs the state machine to discard the current event
and to continue with the processing of the remaining events (see <code><a href="#process_event">state_machine&lt;&gt;::process_event</a>()</code>
for details)<br>


并同时指示状态机忽略当前事件，并继续处理其余事件(详情请见 <code><a href="reference.html#process_event">state_machine&lt;&gt;::process_event</a>()</code>)<br>


<b>Returns</b>: A <code><a href="#Classresult">result</a></code>
object. The user-supplied <code>react</code> member
function must return this object to its caller<br>


<b>返回：</b>一个 <code><a href="reference.html#Classresult">result</a></code>
对象。用户提供的 <code>react</code> 成员函数必须返回该对象给它的调用者<br>


<b>Throws</b>: Any exceptions propagated from:<br>


<b>抛出：</b>从以下函数传出的任何异常：</p>


<ul>


  <li><code>Allocator::rebind&lt;&gt;::other::allocate()</code>
(the template parameter passed to the base class of <code>outermost_context_type</code>,
used to allocate space to save history)<br>


    <code>Allocator::rebind&lt;&gt;::other::allocate()</code>
(传给 <code>outermost_context_type</code>
的基类的模板参数，用于分配空间以保存历史)</li>


  <li><code>exit</code> member functions<br>


    <code>exit</code>
成员函数</li>


</ul>


<p><b>Note</b>: If this state is the only currently
active inner state of its direct outer state then the direct outer
state is terminated also. The same applies recursively for all indirect
outer states<br>


<b>说明：</b>如果该状态是其直接外层状态中唯一的当前活动内层状态，则其直接外层状态也将被终止。相同规则会被反复应用
于所有间接外层状态<br>


<b>Caution</b>: Inevitably destructs this state before
returning to the calling <code>react</code> member
function, which must therefore not attempt to access anything except
stack objects before returning to its caller<b><br>


警告：</b>在返回调用者 <code>react</code>
成员函数之前，该状态不可避免要被析构，因此在返回其调用者之前，不要尝试访问除了栈对象以外的任何东西</p>


<pre>template&lt;<br> class HistoryContext,<br> <i>implementation-defined-unsigned-integer-type<br></i> orthogonalPosition &gt;<br>void <a name="clear_shallow_history" id="clear_shallow_history">clear_shallow_history</a>();<br></pre>


<p><b>Requires</b>: If called from a constructor of a
direct or indirect subtype then the most-derived type must directly or
indirectly derive from the <code>state</code> class
template. The <code>historyMode</code> argument passed to
the <code><a href="#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
or <code><a href="#ClassTemplatestate">state&lt;&gt;</a></code>
base of&nbsp;<code>HistoryContext</code> must be equal
to <code>has_shallow_history</code> or <code>has_full_history</code><b><br>


</b><b>要求：</b>如果从一个直接或间接子类的构造函数调用，则最底层类型必须直接或间接派生自 <code>state</code>
类模板。传给&nbsp;<code>HistoryContext</code> 的 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
或 <code><a href="reference.html#ClassTemplatestate">state&lt;&gt;</a></code>
基类的 <code>historyMode</code> 参数必须等于 <code>has_shallow_history</code>
或 <code>has_full_history</code><br>


<b>Effects</b>: Clears the shallow history of the
orthogonal region specified by <code>orthogonalPosition</code>
of the state specified by <code>HistoryContext</code><br>


<b>作用：</b>清除由 <code>HistoryContext</code>
指定的状态的 <code>orthogonalPosition</code> 所指定的正交区域的浅历史<code></code><br>


<b>Throws</b>: Any exceptions propagated from <code>Allocator::rebind&lt;&gt;::other::allocate()</code>
(the template parameter passed to the base class of <code>outermost_context_type</code>)<br>


<b>抛出：</b>从 <code>Allocator::rebind&lt;&gt;::other::allocate()</code>
(传给 <code>outermost_context_type</code> 的基类的模板参数)传出的任何异常</p>


<pre>template&lt;<br> class HistoryContext,<br> <i>implementation-defined-unsigned-integer-type<br></i> orthogonalPosition &gt;<br>void <a name="clear_deep_history" id="clear_deep_history">clear_deep_history</a>();<br></pre>


<p><b>Requires</b>: If called from a constructor of a
direct or indirect subtype then the most-derived type must directly or
indirectly derive from the <code>state</code> class
template. The <code>historyMode</code> argument passed to
the <code><a href="#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
or <code><a href="#ClassTemplatestate">state&lt;&gt;</a></code>
base of&nbsp;<code>HistoryContext</code> must be equal
to <code>has_deep_history</code> or <code>has_full_history</code><code></code><b><br>


</b><b>要求：</b>如果从一个直接或间接子类的构造函数调用，则最底层类型必须直接或间接派生自 <code>state</code>
类模板。传给&nbsp;<code>HistoryContext</code> 的 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
或 <code><a href="reference.html#ClassTemplatestate">state&lt;&gt;</a></code>
基类的 <code>historyMode</code> 参数必须等于 <code>has_</code><code>deep</code><code>_history</code>
或 <code>has_full_history</code><br>


<b>Effects</b>: Clears the deep history of the orthogonal
region specified by <code>orthogonalPosition</code> of the
state specified by <code>HistoryContext</code><code></code><br>


<b>作用：</b>清除由 <code>HistoryContext</code>
指定的状态的 <code>orthogonalPosition</code> 所指定的正交区域的深历史<br>


<b>Throws</b>: Any exceptions propagated from <code>Allocator::rebind&lt;&gt;::other::allocate()</code>
(the template parameter passed to the base class of <code>outermost_context_type</code>)<br>


<b>抛出：</b>从 <code>Allocator::rebind&lt;&gt;::other::allocate()</code>
(传给 <code>outermost_context_type</code> 的基类的模板参数)传出的任何异常</p>


<h3>Class template <code>simple_state</code>
observer functions 类模板 <code>simple_state</code> 的常性函数</h3>


<pre>outermost_context_type &amp; <a name="outermost_context" id="outermost_context">outermost_context</a>();<br></pre>


<p><b>Requires</b>: If called from a constructor of a direct or indirect subtype then the 
most-derived type must directly or indirectly derive from the <code>state</code> 
class template. If called from a destructor of a direct or indirect subtype then 
the <code>state_machine&lt;&gt;</code> subclass portion must still exist<code></code><code></code><b><br>


</b><b>要求：</b>如果从一个直接或间接子类的构造函数调用，则最底层类型必须直接或间接派生自 <code>state</code>
类模板。如果从一个直接或间接子类的析构函数调用，则 <code>state_machine&lt;&gt;</code> 的子类部分必须仍然存在。<b><br>


Returns</b>: A reference to the outermost context, which is
always the state machine this state belongs to<code></code><code></code><b><br>


</b><b>返回：</b>引向最外层上下文的一个引用，该上下文总是本状态所属的状态机</p>


<pre>const outermost_context_type &amp; <a name="outermost_contextconst" id="outermost_contextconst">outermost_context() const</a>;<br></pre>


<p><b>Requires</b>: If called from a constructor of a
direct or indirect subtype then the most-derived type must directly or
indirectly derive from the <code>state</code> class
template. If called from a destructor of a direct or indirect subtype then the 
<code>state_machine&lt;&gt;</code> subclass portion must still exist<code></code><code></code><b><br>


</b><b>要求：</b>如果从一个直接或间接子类的构造函数调用，则最底层类型必须直接或间接派生自 <code>state</code>
类模板。如果从一个直接或间接子类的析构函数调用，则 <code>state_machine&lt;&gt;</code> 的子类部分必须仍然存在。<b><br>


Returns</b>: A reference to the const outermost context, which is
always the state machine this state belongs to<code></code><code></code><b><br>


</b><b>返回：</b>引向 const 最外层上下文的一个引用，该上下文总是本状态所属的状态机</p>


<pre>template&lt; class OtherContext &gt;<br>OtherContext &amp; <a name="context" id="context">context</a>();<br></pre>


<p><b>Requires</b>: If called from a constructor of a
direct or indirect subtype then the most-derived type must directly or
indirectly derive from the <code>state</code> class
template. If called from a destructor of a direct or indirect subtype with a 
<code>state_machine&lt;&gt;</code> subtype as argument then the 
<code>state_machine&lt;&gt;</code> subclass portion must still exist<code></code><code></code><b><br>


</b><b>要求：</b>如果从一个直接或间接子类的构造函数调用，则最底层类型必须直接或间接派生自 <code>state</code>
类模板。如果从一个直接或间接子类的析构函数调用，则 <code>state_machine&lt;&gt;</code> 的子类部分必须仍然存在。<b><br>


Returns</b>: A reference to a direct or indirect context<code></code><code></code><b><br>


</b><b>返回：</b>引向直接或间接上下文的一个引用</p>


<pre>template&lt; class OtherContext &gt;<br>const OtherContext &amp; <a name="contextconst" id="contextconst">context() const</a>;<br></pre>


<p><b>Requires</b>: If called from a constructor of a
direct or indirect subtype then the most-derived type must directly or
indirectly derive from the <code>state</code> class
template. If called from a destructor of a direct or indirect subtype with a 
<code>state_machine&lt;&gt;</code> subtype as argument then the 
<code>state_machine&lt;&gt;</code> subclass portion must still exist<code></code><code></code><b><br>


</b><b>要求：</b>如果从一个直接或间接子类的构造函数调用，则最底层类型必须直接或间接派生自 <code>state</code>
类模板。如果从一个直接或间接子类的析构函数调用，则 <code>state_machine&lt;&gt;</code> 的子类部分必须仍然存在。<b><br>


Returns</b>: A reference to a const direct or indirect context<code></code><code></code><b><br>


</b><b>返回：</b>引向 const 直接或间接上下文的一个引用</p>


<pre>template&lt; class Target &gt;<br>Target <a name="simple_state::state_cast" id="simple_state::state_cast">state_cast</a>() const;<br></pre>


<p><b>Requires</b>: If called from a constructor of a
direct or indirect subtype then the most-derived type must directly or
indirectly derive from the <code>state</code> class
template<code></code><code></code><b><br>


</b><b>要求：</b>如果从一个直接或间接子类的构造函数调用，则最底层类型必须直接或间接派生自 <code>state</code>
类模板。<b><br>


Returns</b>: Has exactly the same semantics as <code><a href="#state_cast">state_machine&lt;&gt;::state_cast</a>&lt;&gt;()</code><br>


<b>返回：</b>具有与 <code><a href="reference.html#state_cast">state_machine&lt;&gt;::state_cast</a>&lt;&gt;()</code>
完全相同的语义<code></code><br>


<b>Throws</b>: Has exactly the same semantics as <code><a href="#state_cast">state_machine&lt;&gt;::state_cast</a>&lt;&gt;()</code><b><br>


</b><b>抛出：</b>具有与 <code><a href="reference.html#state_cast">state_machine&lt;&gt;::state_cast</a>&lt;&gt;()</code>
完全相同的语义<code></code><b><br>


</b><b>Note</b>: The result is <b>unspecified</b>
if this
function is called when the machine is <a href="definitions.html#UnstableStateMachine">unstable</a><br>


<b>说明：</b>如果调用该函数时状态机是 <a href="definitions.html#UnstableStateMachine">不稳定</a>
的，则结果<span style="font-weight: bold;">未有规定</span></p>


<pre>template&lt; class Target &gt;<br>Target <a name="simple_state::state_downcast" id="simple_state::state_downcast">state_downcast</a>() const;<br></pre>


<p><b>Requires</b>: If called from a constructor of a
direct or indirect subtype then the most-derived type must directly or
indirectly derive from the <code>state</code> class
template. Moreover, <code><a href="#state_downcast">state_machine&lt;&gt;::state_downcast</a>&lt;&gt;()</code>
requirements also apply<code></code><code></code><b><br>


</b><b>要求：</b>如果从一个直接或间接子类的构造函数调用，则最底层类型必须直接或间接派生自 <code>state</code>
类模板。此外，还要求具有 <code><a href="reference.html#state_downcast">state_machine&lt;&gt;::state_downcast</a>&lt;&gt;()</code>&nbsp;<br>


<b>Returns</b>: Has exactly the same semantics as <code><a href="#state_downcast">state_machine&lt;&gt;::state_downcast</a>&lt;&gt;()</code><code></code><br>


<b>返回：</b>具有与 <code><a href="reference.html#state_downcast">state_machine&lt;&gt;::state_downcast</a>&lt;&gt;()</code><code></code>
完全相同的语义<br>


<b>Throws</b>: Has exactly the same semantics as <code><a href="#state_downcast">state_machine&lt;&gt;::state_downcast</a>&lt;&gt;()</code><code></code><code></code><br>


<b>抛出：</b>具有与 <code><a href="reference.html#state_downcast">state_machine&lt;&gt;::state_downcast</a>&lt;&gt;()</code><code></code>
完全相同的语义<b><br>


Note</b>: The result is <b>unspecified</b> if this
function is called when the machine is <a href="definitions.html#UnstableStateMachine">unstable</a><br>


<b>说明：</b>如果调用该函数时状态机是 <a href="definitions.html#UnstableStateMachine">不稳定</a>
的，则结果<span style="font-weight: bold;">未有规定</span></p>


<pre>state_iterator <a name="simple_state::state_begin" id="simple_state::state_begin">state_begin</a>() const;<br></pre>


<pre>state_iterator <a name="simple_state::state_end" id="simple_state::state_end">state_end</a>() const;<br></pre>


<p><b>Require</b>: If called from a constructor of a
direct or indirect subtype then the most-derived type must directly or
indirectly derive from the <code>state</code> class
template<code></code><code></code><b><br>


</b><b>要求：</b>如果从一个直接或间接子类的构造函数调用，则最底层类型必须直接或间接派生自 <code>state</code>
类模板。<b><br>


Return</b>: Have exactly the same semantics as <code><a href="#state_begin">state_machine&lt;&gt;::state_begin</a>()</code>
and <code><a href="#state_end">state_machine&lt;&gt;::state_end</a>()</code><code></code><code></code><br>


<b>返回：</b>具有与 <code><a href="reference.html#state_begin">state_machine&lt;&gt;::state_begin</a>()</code>
和 <code><a href="reference.html#state_end">state_machine&lt;&gt;::state_end</a>()</code>
完全相同的语义<br>


<b>Note</b>: The result is <b>unspecified</b>
if these functions are called when the machine is <a href="definitions.html#UnstableStateMachine">unstable</a><br>


<b>说明：</b>如果调用该函数时状态机是 <a href="definitions.html#UnstableStateMachine">不稳定</a>
的，则结果<span style="font-weight: bold;">未有规定</span></p>


<h3>Class template <code>simple_state</code> static
functions 类模板 <code>simple_state</code> 的静态函数</h3>


<pre>static id_type <a name="static_type" id="static_type">static_type</a>();<br></pre>


<p><b>Returns</b>: A value unambiguously identifying
the type of <code>MostDerived</code><br>


<b>返回：</b>一个明确标识出 <code>MostDerived</code> 类型的值<code></code><br>


<b>Note</b>: <code>id_type</code> values are
comparable with <code>operator==()</code> and <code>operator!=()</code>.
An unspecified collating order can be established with <code>std::less&lt;
id_type &gt;</code><br>


<b>说明：</b><code>id_type</code> 值可以用 <code>operator==()</code>
和 <code>operator!=()</code> 来进行比较。未指定的比较顺序可以由 <code>std::less&lt;
id_type &gt;</code> 制定<code></code></p>


<pre>template&lt; class CustomId &gt;<br>static const CustomId * <a name="custom_static_type_ptr" id="custom_static_type_ptr">custom_static_type_ptr</a>();<br></pre>


<p><b>Requires</b>: If a custom type identifier has
been set then <code>CustomId</code> must match the type of
the previously set pointer<b><br>


</b><b>要求：</b>如果已经设置了定制的类型标识符，则 <code>CustomId</code>
必须与之前设置的指针相匹配<b><br>


</b><b>
Returns</b>: The pointer to the custom type identifier for <code>MostDerived</code>
or <code>0</code><br>


<b>返回：</b>指向 <code>MostDerived</code>
的定制类型标识符的指针，或返回 <code>0</code><br>


<b>Note</b>: This function is not available if <a href="configuration.html#ApplicationDefinedMacros"><code>BOOST_STATECHART_USE_NATIVE_RTTI</code></a>
is defined<br>


<b>说明：</b>如果定义了 <a href="configuration.html#ApplicationDefinedMacros"><code>BOOST_STATECHART_USE_NATIVE_RTTI</code></a>
则本函数不可用</p>


<pre>template&lt; class CustomId &gt;<br>static void <a name="custom_static_type_ptr1" id="custom_static_type_ptr1">custom_static_type_ptr( const CustomId * )</a>;<br></pre>


<p><b>Effects</b>: Sets the pointer to the custom
type identifier for <code>MostDerived</code><br>


<span style="font-weight: bold;">作用：</span>设置指向 <code>MostDerived</code>
的定制类型标识符的指针<code></code><br>


<b>Note</b>: This function is not available if <a href="configuration.html#ApplicationDefinedMacros"><code>BOOST_STATECHART_USE_NATIVE_RTTI</code></a>
is defined<br>


<b>说明：</b>如果定义了 <a href="configuration.html#ApplicationDefinedMacros"><code>BOOST_STATECHART_USE_NATIVE_RTTI</code></a>
则本函数不可用</p>


<h1>Header &lt;boost/statechart/<a name="state.hpp" id="state.hpp">state.hpp</a>&gt;</h1>


<h2><a name="ClassTemplatestate" id="ClassTemplatestate">Class
template <code>state 类模板</code> <code>state</code></a></h2>


<p>This is the base class template for all models of the <a href="#State">State</a> concept. Such models typically
need to call at least one of the following <code><a href="#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
member functions from their constructors:<br>


这是所有符合 <a href="reference.html#State">状态</a>
概念的类型的基类模板。这些类型通常需要从它们的构造函数中调用以下 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
成员函数中的至少一个：</p>


<pre>void <b>post_event</b>(<br> const intrusive_ptr&lt; const event_base &gt; &amp; );<br>void <b>post_event</b>( const event_base &amp; );<br><br>template&lt;<br> class HistoryContext,<br> <i>implementation-defined-unsigned-integer-type<br></i> orthogonalPosition &gt;<br>void <b>clear_shallow_history</b>();<br>template&lt;<br> class HistoryContext,<br> <i>implementation-defined-unsigned-integer-type<br></i> orthogonalPosition &gt;<br>void <b>clear_deep_history</b>();<br><br>outermost_context_type &amp; <b>outermost_context</b>();<br>const outermost_context_type &amp; <b>outermost_context</b>() const;<br><br>template&lt; class OtherContext &gt;<br>OtherContext &amp; <b>context</b>();<br>template&lt; class OtherContext &gt;<br>const OtherContext &amp; <b>context</b>() const;<br><br>template&lt; class Target &gt;<br>Target <b>state_cast</b>() const;<br>template&lt; class Target &gt;<br>Target <b>state_downcast</b>() const;<br><br>state_iterator <b>state_begin</b>() const;<br>state_iterator <b>state_end</b>() const;<br></pre>


<p>States that do not need to call any of these member functions
from their constructors should rather derive from the <code><a href="#ClassTemplatesimple_state">simple_state</a></code>
class template, what saves the implementation of the forwarding
constructor.<br>


不需要从构造函数中调用以上所有成员函数的状态，应该从 <code><a href="reference.html#ClassTemplatesimple_state">simple_state</a></code>
类模板进行派生，这样可以节省前转构造函数的实现。</p>


<h3>Class template <code>state</code> synopsis 类模板 <code>state</code>
的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt;<br> class MostDerived,<br> class Context,<br> class InnerInitial = <i>unspecified</i>,<br> history_mode historyMode = has_no_history &gt;<br> class state : public simple_state&lt;<br> MostDerived, Context, InnerInitial, historyMode &gt;<br> {<br> protected:<br> struct my_context<br> {<br> // <i>implementation-defined 由实现定义</i><br>};<br>typedef state my_base;<br>state( my_context ctx );<br>~state();<br>};<br>}<br>}<br></pre>


<p>Direct and indirect subtypes of <code>state&lt;&gt;</code>
must provide a constructor with the same signature as the <code>state&lt;&gt;</code>
constructor, forwarding the context parameter.<br>


<code>state&lt;&gt;</code>
的直接和间接子类必须提供一个与 <code>state&lt;&gt;</code>
构造函数签名相同的构造函数，用于前转上下文参数。</p>


<h1>Header &lt;boost/statechart/<a name="shallow_history.hpp" id="shallow_history.hpp">shallow_history.hpp</a>&gt;</h1>


<h2><a name="ClassTemplateshallow_history" id="ClassTemplateshallow_history">Class template <code>shallow_history
类模板</code> <code>shallow_history</code></a></h2>


<p>This class template is used to specify a shallow history
transition target or a shallow history inner initial state.<br>


该类模板用于指定一个浅历史的转换目标或是一个浅历史的内层初始状态。</p>


<h3>Class template <code>shallow_history</code>
parameters 类模板 <code>shallow_history</code>
的参数</h3>


<table summary="shallow_history parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="15%"><b>Template parameter 模板参数</b></td>


      <td width="45%"><b>Requirements 要求</b></td>


      <td width="24%"><b>Semantics 语义</b></td>


    </tr>


    <tr>


      <td width="15%"><code>DefaultState</code></td>


      <td width="45%">A model of the <a href="#SimpleState">SimpleState</a> or <a href="#State">State</a> concepts. The type passed as <code>Context</code>
argument to the <code><a href="#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
or <code><a href="#ClassTemplatestate">state&lt;&gt;</a></code>
base of&nbsp;<code>DefaultState</code> must itself pass
      <code>has_shallow_history</code> or <code>has_full_history</code>
as <code>historyMode</code> argument to its <code><a href="#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
or <code><a href="#ClassTemplatestate">state&lt;&gt;</a></code>
base<br>


符合 <a href="reference.html#SimpleState">简单状态</a> 或 <a href="reference.html#State">状态</a> 概念。传给&nbsp;<code>DefaultState</code>
的 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
或 <code><a href="reference.html#ClassTemplatestate">state&lt;&gt;</a></code>
基类的 <code>Context</code>
参数的类型必须以 <code>has_shallow_history</code> 或 <code>has_full_history</code>
作为 <code>historyMode</code> 参数传给其 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
或 <code><a href="reference.html#ClassTemplatestate">state&lt;&gt;</a></code>
基类</td>


      <td width="24%">The state that is entered if shallow
history is not available<br>


在浅历史不可用时将进入的状态</td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>shallow_history</code>
synopsis 类模板 <code>shallow_history</code> 的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt; class DefaultState &gt;<br> class shallow_history<br> {<br> // <i>implementation-defined 由实现定义</i><br>};<br>}<br>}<br></pre>


<h1>Header &lt;boost/statechart/<a name="deep_history.hpp" id="deep_history.hpp">deep_history.hpp</a>&gt;</h1>


<h2><a name="ClassTemplatedeep_history" id="ClassTemplatedeep_history">Class template <code>deep_history
类模板</code> <code>deep_history</code></a></h2>


<p>This class template is used to specify a deep history
transition target or a deep history inner initial state. The current
deep history implementation has some <a href="rationale.html#Limitations">limitations</a>.<br>


该类模板用于指定一个深历史转换目标或一个深历史的内层初始状态。当前的深历史实现有一些 <a href="rationale.html#Limitations">局限</a>。</p>


<h3>Class template <code>deep_history</code>
parameters 类模板 <code>deep_history</code> 的参数</h3>


<table summary="deep_history parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="15%"><b>Template parameter 模板参数</b></td>


      <td width="45%"><b>Requirements 要求</b></td>


      <td width="24%"><b>Semantics 语义</b></td>


    </tr>


    <tr>


      <td width="15%"><code>DefaultState</code></td>


      <td width="45%">A model of the <a href="#SimpleState">SimpleState</a> or <a href="#State">State</a> concepts. The type passed as <code>Context</code>
argument to the <code><a href="#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
or <code><a href="#ClassTemplatestate">state&lt;&gt;</a></code>
base of&nbsp;<code>DefaultState</code> must itself pass
      <code>has_deep_history</code> or <code>has_full_history</code>
as <code>historyMode</code> argument to its <code><a href="#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
or <code><a href="#ClassTemplatestate">state&lt;&gt;</a></code>
base<br>


符合 <a href="reference.html#SimpleState">简单状态</a> 或 <a href="reference.html#State">状态</a> 概念。传给&nbsp;<code>DefaultState</code>
的 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
或 <code><a href="reference.html#ClassTemplatestate">state&lt;&gt;</a></code>
基类的 <code>Context</code>
参数的类型必须以 <code>has_deep_history</code> 或 <code>has_full_history</code>
作为 <code>historyMode</code> 参数传给其 <code><a href="reference.html#ClassTemplatesimple_state">simple_state&lt;&gt;</a></code>
或 <code><a href="reference.html#ClassTemplatestate">state&lt;&gt;</a></code>
基类</td>


      <td width="24%">The state that is entered if deep
history is not available<br>


在深历史不可用时将进入的状态</td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>deep_history</code>
synopsis 类模板 <code>deep_history</code> 的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt; class DefaultState &gt;<br> class deep_history<br> {<br> // <i>implementation-defined 由实现定义</i><br>};<br>}<br>}<br></pre>


<h1>Header &lt;boost/statechart/<a name="event_base.hpp" id="event_base.hpp">event_base.hpp</a>&gt;</h1>


<h2><a name="Classevent_base" id="Classevent_base">Class
<code>event_base 类</code>
<code>event_base</code></a></h2>


<p>This is the common base of all events.<br>


这是所有事件的公共基类。</p>


<h3>Class <code>event_base</code> synopsis 类 <code>event_base</code>
的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> class event_base<br> {<br> public:<br> intrusive_ptr&lt; const event_base &gt;<br> <a href="#intrusive_from_this">intrusive_from_this</a>() const;<br><br> typedef <i>implementation-defined</i> id_type;<br><br> id_type <a href="#event_base::dynamic_type">dynamic_type</a>() const;<br><br> template&lt; typename CustomId &gt;<br> const CustomId * <a href="#event_base::custom_dynamic_type_ptr">custom_dynamic_type_ptr</a>() const;<br> <br> protected:<br> <a href="#event_base">event_base</a>( <i>unspecified-parameter </i>);<br> virtual <a href="#event_basedtor">~event_base</a>();<br> };<br>}<br>}<br></pre>


<h3>Class <code>event_base</code> constructor and
destructor 类 <code>event_base</code> 的构造函数和析构函数</h3>


<pre><a name="event_base" id="event_base">event_base</a>( <i>unspecified-parameter </i>);<br></pre>


<p><b>Effects</b>: Constructs the common base portion
of an event<br>


<b>作用：</b>构造一个事件的公共基类部分</p>


<pre>virtual <a name="event_basedtor" id="event_basedtor">~event_base</a>();<br></pre>


<p><b>Effects</b>: Destructs the common base portion
of an event<br>


<b>作用：</b>析构一个事件的公共基类部分</p>


<h3>Class <code>event_base</code> observer functions
类 <code>event_base</code> 的常性函数</h3>


<pre>intrusive_ptr&lt; const event_base &gt; <a name="intrusive_from_this" id="intrusive_from_this">intrusive_from_this</a>() const;<br></pre>


<p><b>Returns</b>: Another <code>intrusive_ptr&lt;
const event_base &gt;</code> referencing <code>this</code>
<b>if</b> <code>this</code> is already
referenced by an <code>intrusive_ptr&lt;&gt;</code>.
Otherwise, returns an <code>intrusive_ptr&lt; const
event_base &gt;</code> referencing a newly created copy of
the most-derived object<br>


<b>返回：</b>如果 <code>this</code> 已经被某个 <code>intrusive_ptr&lt;&gt;</code>
引向，则返回引向 <code>this</code> 的另一个 <code>intrusive_ptr&lt;
const event_base &gt; </code>。否则，返回，为类层次最底层的对象创建一个新的拷贝并返回引向它的
一个 <code>intrusive_ptr&lt; const
event_base &gt;</code></p>


<pre>id_type <a name="event_base::dynamic_type" id="event_base::dynamic_type">dynamic_type</a>() const;<br></pre>


<p><b>Returns</b>: A value unambiguously identifying
the most-derived type<br>


<b>返回：</b>一个明确标识出类层次最底层类型的值<br>


<b>Note</b>: <code>id_type</code> values are
comparable with <code>operator==()</code> and <code>operator!=()</code>.
An unspecified collating order can be established with <code>std::less&lt;
id_type &gt;</code>. In contrast to <code>typeid( cs )</code>,
this function is available even on platforms that do not support C++
RTTI (or have been configured to not support it)<br>


<b>说明：</b><code>id_type</code> 的值可以通过 <code>operator==()</code>
和 <code>operator!=()</code> 进行比较。未指定的比较顺序可由 <code>std::less&lt;
id_type &gt;</code> 确定。与 <code>typeid( cs )</code>
相比，本函数即使在不支持 C++
RTTI (或被配置为不支持它)的平台上也可用</p>


<pre>template&lt; typename CustomId &gt;<br>const CustomId * <a name="event_base::custom_dynamic_type_ptr" id="event_base::custom_dynamic_type_ptr">custom_dynamic_type_ptr</a>() const;<br></pre>


<p><b>Requires</b>: If a custom type identifier has
been set then <code>CustomId</code> must match the type of
the previously set pointer<b><br>


</b><b>要求：</b>如果已设置了一个定制类型标识符，则 <code>CustomId</code>
必须与之前设置的指针类型相匹配<b><br>


</b><b>Returns</b>: A pointer to the custom type
identifier or <code>0</code><br>


<b>返回：</b>一个指向定制类型标识符的指针或<code>0</code><br>


<b>Note</b>: This function is not available if <a href="configuration.html#ApplicationDefinedMacros"><code>BOOST_STATECHART_USE_NATIVE_RTTI</code></a>
is defined<br>


<b>说明：</b>如果定义了 <a href="configuration.html#ApplicationDefinedMacros"><code>BOOST_STATECHART_USE_NATIVE_RTTI</code></a>，
则本函数不可用</p>


<h1>Header &lt;boost/statechart/<a name="event.hpp" id="event.hpp">event.hpp</a>&gt;</h1>


<h2><a name="ClassTemplateevent" id="ClassTemplateevent">Class
template <code>event 类模板</code> <code>event</code></a></h2>


<p>This is the base class template of all events.<br>


这是所有事件的基类模板。</p>


<h3>Class template <code>event</code> parameters 类模板
<code>event</code> 的参数</h3>


<table summary="event parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="15%"><b>Template parameter 模板参数</b></td>


      <td width="51%"><b>Requirements 要求</b></td>


      <td width="18%"><b>Semantics 语义</b></td>


      <td width="19%"><b>Default 缺省值</b></td>


    </tr>


    <tr>


      <td width="15%"><code>MostDerived</code></td>


      <td width="51%">The most-derived subtype of this
class template<br>


该类模板的最底层子类</td>


      <td width="18%">&nbsp;</td>


      <td width="19%">&nbsp;</td>


    </tr>


    <tr>


      <td width="15%"><code>Allocator</code></td>


      <td width="51%">A model of the standard Allocator
concept<br>


符合标准分配器概念的类型</td>


      <td width="18%"><code>Allocator::rebind&lt;
MostDerived &gt;::other</code> is used to allocate and
deallocate all event subtype objects of dynamic storage duration, see <code><a href="#event::operatornew">operator new</a><br>


      </code><code>Allocator::rebind&lt;
MostDerived &gt;::other</code> 用于分配和释放动态存储期间的所有事件子类对象，请见 <code><a href="reference.html#event::operatornew">operator new</a></code></td>


      <td width="19%"><code>std::allocator&lt;
void &gt;</code></td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>event</code> synopsis 类模板 <code>event</code>
的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt; class MostDerived, class Allocator = std::allocator&lt; void &gt; &gt;<br> class event : <i>implementation-defined</i><br>{<br>public:<br>static void * <a href="#event::operatornew">operator new</a>( std::size_t size );<br> static void <a href="#event::operatordelete">operator delete</a>( void * pEvent );<br><br> static id_type <a href="#event::static_type">static_type</a>();<br><br> template&lt; class CustomId &gt;<br> static const CustomId * <a href="#event::custom_static_type_ptr">custom_static_type_ptr</a>();<br><br> template&lt; class CustomId &gt;<br> static void <a href="#event::custom_static_type_ptr1">custom_static_type_ptr</a>( const CustomId * );<br><br> protected:<br> <a href="#event::event">event</a>();<br> virtual <a href="#eventdtor">~event</a>();<br> };<br>}<br>}<br></pre>


<h3>Class template <code>event</code> constructor
and destructor 类模板 <code>event</code> 的构造函数和析构函数</h3>


<pre><a name="event::event" id="event::event">event</a>();<br></pre>


<p><b>Effects</b>: Constructs an event<br>


<b>作用：</b>构造一个事件</p>


<pre>virtual <a name="eventdtor" id="eventdtor">~event</a>();<br></pre>


<p><b>Effects</b>: Destructs an event<br>


<b>作用：</b>析构一个事件</p>


<h3>Class template <code>event</code> static
functions 类模板 <code>event</code> 的静态函数</h3>


<pre>static void * <a name="event::operatornew" id="event::operatornew">operator new</a>( std::size_t size );<br></pre>


<p><b>Effects</b>: <code>Allocator::rebind&lt;
MostDerived &gt;::other().allocate( 1, static_cast&lt;
MostDerived * &gt;( 0 ) );</code><br>


<b>作用：</b><code>Allocator::rebind&lt;
MostDerived &gt;::other().allocate( 1, static_cast&lt;
MostDerived * &gt;( 0 ) );</code><br>


<b>Returns</b>: The return value of the above call<br>


<b>返回：</b>以上调用的返回值<br>


<b>Throws</b>: Whatever the above call throws<br>


<b>抛出：</b>以上调用抛出的任何异常</p><pre>static void * <a id="event::operatornew2" name="event::operatornew2">operator new</a>( std::size_t size, void * p );<br></pre>
<p><b>Effects</b>: None<br><b>作用：</b>无<br><b>Returns</b>: <code>p<br></code><b>返回：</b><code>p</code></p>


<pre>static void <a name="event::operatordelete" id="event::operatordelete">operator delete</a>( void * pEvent );<br></pre>


<p><b>Effects</b>: <code>Allocator::rebind&lt;
MostDerived &gt;::other().deallocate( static_cast&lt;
MostDerived * &gt;( pEvent ), 1 );</code><br>


<b>作用：</b><code>Allocator::rebind&lt;
MostDerived &gt;::other().deallocate( static_cast&lt;
MostDerived * &gt;( pEvent ), 1 );</code></p>


<p></p>


<pre>static id_type <a name="event::static_type" id="event::static_type">static_type</a>();<br></pre>


<p><b>Returns</b>: A value unambiguously identifying
the type of <code>MostDerived</code><br>


<b>返回：</b>一个明确标识出 <code>MostDerived</code> 类型的值<code></code><br>


<b>Note</b>: <code>id_type</code> values are
comparable with <code>operator==()</code> and <code>operator!=()</code>.
An unspecified collating order can be established with <code>std::less&lt;
id_type &gt;</code><br>


<b>说明：</b><code>id_type</code> 的值可以通过 <code>operator==()</code>
和 <code>operator!=()</code> 来比较。未指定的比较顺序可以由 <code>std::less&lt;
id_type &gt;</code> 确定<code></code></p>


<pre>template&lt; class CustomId &gt;<br>static const CustomId * <a name="event::custom_static_type_ptr" id="event::custom_static_type_ptr">custom_static_type_ptr</a>();<br></pre>


<p><b>Requires</b>: If a custom type identifier has
been set then <code>CustomId</code> must match the type of
the previously set pointer<b><br>


</b><b>要求：</b>如果已设置了一个定制类型标识符，则 <code>CustomId</code>
必须与之前设置的指针类型相匹配<b><br>


</b><b>Returns</b>: A pointer to the custom type
identifier or <code>0</code><br>


<b>返回：</b>一个指向 <code>MostDerived</code>
的定制类型标识符的指针或<code>0</code><br>


<b>Note</b>: This function is not available if <a href="configuration.html#ApplicationDefinedMacros"><code>BOOST_STATECHART_USE_NATIVE_RTTI</code></a>
is defined<br>


<b>说明：</b>如果定义了 <a href="configuration.html#ApplicationDefinedMacros"><code>BOOST_STATECHART_USE_NATIVE_RTTI</code></a>，
则本函数不可用</p>


<pre>template&lt; class CustomId &gt;<br>static void <a name="event::custom_static_type_ptr1" id="event::custom_static_type_ptr1">custom_static_type_ptr( const CustomId * )</a>;<br></pre>


<p><b>Effects</b>: Sets the pointer to the custom
type identifier for <code>MostDerived</code><code></code><br>


<b>作用：</b>设置指向 <code>MostDerived</code>
的定制类型标识符的指针<code></code><code></code><br>


<b>Note</b>: This function is not available if <a href="configuration.html#ApplicationDefinedMacros"><code>BOOST_STATECHART_USE_NATIVE_RTTI</code></a>
is defined<br>


<b>说明：</b>如果定义了 <a href="configuration.html#ApplicationDefinedMacros"><code>BOOST_STATECHART_USE_NATIVE_RTTI</code></a>，
则本函数不可用</p>


<h1>Header &lt;boost/statechart/<a name="transition.hpp" id="transition.hpp">transition.hpp</a>&gt;</h1>


<h2><a name="ClassTemplatetransition" id="ClassTemplatetransition">Class template <code>transition
类模板</code> <code>transition</code></a></h2>


<p>This class template is used to specify a transition reaction.
Instantiations of this template can appear in the <code>reactions</code>
member <code>typedef</code> in models of the <a href="#SimpleState">SimpleState</a> and <a href="#State">State</a> concepts.<br>


这个类模板用于指定转换反应。该模板的实例可以出现在符合 <a href="reference.html#SimpleState">简
单状态</a> 和 <a href="reference.html#State">状态</a>
概念的类型的 <code>reactions</code> 成员 <code>typedef</code>
中。</p>


<h3>Class template <code>transition</code>
parameters 类模板 <code>transition</code> 的参数</h3>


<table summary="transition parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="15%"><b>Template parameter 模板函数</b></td>


      <td width="45%"><b>Requirements 要求</b></td>


      <td width="24%"><b>Semantics 语义</b></td>


      <td width="19%"><b>Default 缺省值</b></td>


    </tr>


    <tr>


      <td width="15%"><code>Event</code></td>


      <td width="45%">A model of the <a href="#Event">Event</a>
concept or the class <code><a href="#Classevent_base">event_base</a><br>


      </code>符合 <a href="reference.html#Event">事件</a>
概念的类型或类 <code><a href="reference.html#Classevent_base">event_base</a></code></td>


      <td width="24%">The event triggering the transition.
If <code><a href="#Classevent_base">event_base</a></code>
is specified, the transition is triggered by all models of the <a href="#Event">Event</a> concept<br>


触发转换的事件。如果指定了 <code><a href="reference.html#Classevent_base">event_base</a></code>，
则该转换由所有符合 <a href="reference.html#Event">事件</a>
概念的类型触发</td>


      <td width="19%">&nbsp;</td>


    </tr>


    <tr>


      <td width="15%"><code>Destination</code></td>


      <td width="45%">A model of the <a href="#SimpleState">SimpleState</a> or <a href="#State">State</a> concepts or an instantiation
of the <code><a href="#ClassTemplateshallow_history">shallow_history</a></code>
or <code><a href="#ClassTemplatedeep_history">deep_history</a></code>
class templates. The source state (the state for which this transition
is defined) and <code>Destination</code> must have a
common direct or indirect context<br>


符合 <a href="reference.html#SimpleState">简单状态</a> 或 <a href="reference.html#State">状态</a> 概念的类型或是 <code><a href="reference.html#ClassTemplateshallow_history">shallow_history</a></code>
或 <code><a href="reference.html#ClassTemplatedeep_history">deep_history</a></code>
类模板的一个实例。源状态(定义该转换的状态)与 <code>Destination</code>
必须具有一个公共的直接或间接上下文</td>


      <td width="24%">The destination state to make a
transition to<br>


转换到的目标状态</td>


      <td width="19%">&nbsp;</td>


    </tr>


    <tr>


      <td width="15%"><code>TransitionContext</code></td>


      <td width="45%">A common context of the source and <code>Destination</code>
state<br>


源状态与 <code>Destination</code>
状态的公共上下文</td>


      <td width="24%">The state of which the transition
action is a member<br>


该转换动作作为其成员的状态</td>


      <td width="19%"><i><code>unspecified<br>


      </code></i><i><code>未指定</code></i></td>


    </tr>


    <tr>


      <td width="15%"><code>pTransitionAction</code></td>


      <td width="45%">A pointer to a member function of <code>TransitionContext</code>.
The member function must accept a <code>const Event &amp;</code>
parameter and return <code>void<br>


      </code>指向 <code>TransitionContext</code>
的一个成员函数的指针。该成员函数必须接受一个 <code>const Event &amp;</code> 参数并返回 <code>void</code></td>


      <td width="24%">The transition action that is
executed during the transition. By default no transition action is
executed<br>


在转换期间被执行的转换动作。缺省时不执行转换动作</td>


      <td width="19%"><i><code>unspecified</code></i><i><code><br>


      </code></i><i><code>未指定</code></i></td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>transition</code> synopsis
类模板 <code>transition</code> 的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt;<br> class Event,<br> class Destination,<br> class TransitionContext = <i>unspecified</i>,<br> void ( TransitionContext::*pTransitionAction )(<br> const Event &amp; ) = <i>unspecified</i> &gt;<br> class transition<br> {<br> // <i>implementation-defined 由实现定义</i><br>};<br>}<br>}<br></pre>


<h3>Class template <code>transition</code> semantics
类模板 <code>transition</code> 的语义</h3>


<p>When executed, one of the following calls to a member function
of the state for which the reaction was defined is made:<br>


执行时，将调用以下两个成员函数之一，这两个成员函数是定义该反应的状态类的：</p>


<ul>


  <li><code><a href="#transit1">transit&lt;
Destination &gt;()</a></code>, if no transition action
was specified<br>

    <code><a href="reference.html#transit1">transit&lt;
Destination &gt;()</a></code>, 如果未指定转换动作</li>


  <li><code><a href="#transit2">transit&lt;
Destination &gt;( pTransitionAction, <i>currentEvent</i>
)</a></code>, if a transition action was specified<br>

    <code><a href="reference.html#transit2">transit&lt;
Destination &gt;( pTransitionAction, <i>currentEvent</i>
)</a></code>, 如果指定了转换动作</li>


</ul>


<h1>Header &lt;boost/statechart/<a name="in_state_reaction.hpp" id="in_state_reaction.hpp">in_state_reaction.hpp</a>&gt;</h1>


<h2><a name="ClassTemplatein_state_reaction" id="ClassTemplatein_state_reaction">Class template <code>in_state_reaction 类模板</code> <code>in_state_reaction</code></a></h2>


<p>This class template is used to specify an in-state reaction.
Instantiations of this template can appear in the <code>reactions</code>
member <code>typedef</code> in models of the <a href="#SimpleState">SimpleState</a> and <a href="#State">State</a> concepts.<br>
这个类模板用于指定一个状态内反应。这个模板的实例可以出现在符合 <a href="reference.html#SimpleState">简
单状态</a> 和 <a href="reference.html#State">状态</a>
概念的类型的 <code>reactions</code> 成员 <code>typedef</code>
中。</p>


<h3>Class template <code>in_state_reaction</code>
parameters 类模板 <code>in_state_reaction</code> 的参数</h3>


<table summary="in_state_reaction parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="15%"><b>Template parameter 模板参数</b></td>


      <td width="45%"><b>Requirements 要求</b></td>


      <td width="24%"><b>Semantics 语义</b></td>


    </tr>


    <tr>


      <td width="15%"><code>Event</code></td>


      <td width="45%">A model of the <a href="#Event">Event</a>
concept or the class <code><a href="#Classevent_base">event_base</a><br>
      </code>符合 <a href="reference.html#Event">事件</a>
概念的类型或者为类 <code><a href="reference.html#Classevent_base">event_base</a></code></td>


      <td width="24%">The event triggering the in-state
reaction. If <code><a href="#Classevent_base">event_base</a></code>
is specified, the in-state reaction is triggered by all models of the <a href="#Event">Event</a> concept

      <br>
触发状态内反应的事件。如果指定了 <code><a href="reference.html#Classevent_base">event_base</a></code>，
则该状态内反应由所有符合 <a href="reference.html#Event">事件</a>
概念的类型触发</td>


    </tr>


    <tr>


      <td width="15%"><code>ReactionContext</code></td>


      <td width="45%">Either the state defining the
in-state reaction itself or one of it direct or indirect contexts<br>
要么是定义该状态内反应的状态，要么是它的直接或间接上下文</td>


      <td width="24%">The state of which the action is a
member<br>
以该动作为其成员的状态</td>


    </tr>


    <tr>


      <td width="15%"><code>pAction</code></td>


      <td width="45%">A pointer to a member function of <code>ReactionContext</code>.
The member function must accept a <code>const Event &amp;</code>
parameter and return <code>void</code><br>
指向 <code>ReactionContext</code> 的一个成员函数的指针。该成员函数必须接受一个 <code>const Event &amp;</code> 参数并返回 <code>void</code></td>


      <td width="24%">The action that is executed during
the in-state reaction<br>


在状态内反应期间被执行的动作</td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>in_state_reaction</code>
synopsis 类模板 <code>in_state_reaction</code> 的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt;<br> class Event,<br> class ReactionContext,<br> void ( ReactionContext::*pAction )( const Event &amp; ) &gt;<br> class in_state_reaction<br> {<br> // <i>implementation-defined 由实现定义</i><br>};<br>}<br>}<br></pre>


<h3>Class template <code>in_state_reaction</code>
semantics 类模板 <code>in_state_reaction</code> 的语义</h3>


<p>When executed then the following happens:<br>执行时有以下动作：</p>
<ol><li>If an action was specified, <code>pAction</code> is called, passing the 
triggering event as the only argument<br>如果指定了一个动作，则调用 <code>pAction</code>，以触发事件作为唯一参数 
</li><li>A call is made to the <code><a href="#discard_event">discard_event</a> 
</code>member function of the state for which the reaction was defined<br>为定义该反应的状态调用 <code><a href="reference.html#discard_event">discard_event</a> 
</code>成员函数</li></ol><h1>Header &lt;boost/statechart/<a name="termination.hpp" id="termination.hpp">termination.hpp</a>&gt;</h1>


<h2><a name="ClassTemplatetermination" id="ClassTemplatetermination">Class template <code>termination 类模板</code> <code>termination</code></a></h2>


<p>This class template is used to specify a termination reaction.
Instantiations of this template can appear in the <code>reactions</code>
member <code>typedef</code> in models of the <a href="#SimpleState">SimpleState</a> and <a href="#State">State</a> concepts.<br>
这个类模板用于指定一个终止反应。该模板的实例可以出现在符合 <a href="reference.html#SimpleState">简
单状态</a> 和 <a href="reference.html#State">状态</a>
概念的类型的 <code>reactions</code> 成员 <code>typedef</code>
中。</p>


<h3>Class template <code>termination</code>
parameters 类模板 <code>termination</code> 的参数</h3>


<table summary="termination parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="15%"><b>Template parameter 模板参数</b></td>


      <td width="45%"><b>Requirements 要求</b></td>


      <td width="24%"><b>Semantics 语义</b></td>


    </tr>


    <tr>


      <td width="15%"><code>Event</code></td>


      <td width="45%">A model of the <a href="#Event">Event</a>
concept or the class <code><a href="#Classevent_base">event_base</a><br>
      </code><code></code>符合 <a href="reference.html#Event">事件</a>
概念的类型或者为类 <code><a href="reference.html#Classevent_base">event_base</a></code></td>


      <td width="24%">The event triggering the
termination. If <code><a href="#Classevent_base">event_base</a></code>
is specified, the termination is triggered by all models of the <a href="#Event">Event</a> concept<br>
触发终止动作的事件。如果指定了 <code><a href="reference.html#Classevent_base">event_base</a></code>，
则该终止动作由所有符合 <a href="reference.html#Event">事件</a>
概念的类型触发</td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>termination</code> synopsis 类模板 <code>termination</code> 的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt; class Event &gt;<br> class termination<br> {<br> // <i>implementation-defined 由实现定义</i><br>};<br>}<br>}<br></pre>


<h3>Class template <code>termination</code> semantics 类模板 <code>termination</code> 的语义</h3>


<p>When executed, a call is made to the <code><a href="#simple_state::terminate">terminate</a></code>
member function of the state for which the reaction was defined.<br>
执行时，调用定义了该反应的状态的 <code><a href="reference.html#simple_state::terminate">terminate</a></code><code></code>
成员函数。</p>


<h1>Header &lt;boost/statechart/<a name="deferral.hpp" id="deferral.hpp">deferral.hpp</a>&gt;</h1>


<h2><a name="ClassTemplatedeferral" id="ClassTemplatedeferral">Class template <code>deferral 类模板</code> <code>deferral</code></a></h2>


<p>This class template is used to specify a deferral reaction.
Instantiations of this template can appear in the <code>reactions</code>
member <code>typedef</code> in models of the <a href="#SimpleState">SimpleState</a> and <a href="#State">State</a> concepts.<br>
这个类模板用于指定一个延迟反应。该模板的实例可以出现在符合 <a href="reference.html#SimpleState">简
单状态</a> 和 <a href="reference.html#State">状态</a>
概念的类型的 <code>reactions</code> 成员 <code>typedef</code>
中。</p>


<h3>Class template <code>deferral</code> parameters 类模板 <code>deferral</code> 的参数</h3>


<table summary="deferral parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="15%"><b>Template parameter 模板参数</b></td>


      <td width="45%"><b>Requirements 要求</b></td>


      <td width="24%"><b>Semantics 语义</b></td>


    </tr>


    <tr>


      <td width="15%"><code>Event</code></td>


      <td width="45%">A model of the <a href="#Event">Event</a>
concept or the class <code><a href="#Classevent_base">event_base</a><br>
      </code><code></code><code></code>符合 <a href="reference.html#Event">事件</a>
概念的类型或者为类 <code><a href="reference.html#Classevent_base">event_base</a></code></td>


      <td width="24%">The event triggering the deferral.
If <code><a href="#Classevent_base">event_base</a></code>
is specified, the deferral is triggered by all models of the <a href="#Event">Event</a> concept<br>
触发延迟动作的事件。如果指定了 <code><a href="reference.html#Classevent_base">event_base</a></code>，
则该延迟动作由所有符合 <a href="reference.html#Event">事件</a>
概念的类型触发</td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>deferral</code> synopsis 类模板 <code>deferral</code> 的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt; class Event &gt;<br> class deferral<br> {<br> // <i>implementation-defined 由实现定义</i><br>};<br>}<br>}<br></pre>


<h3>Class template <code>deferral</code> semantics 类模板 <code>deferral</code> 的语义</h3>


<p>When executed, a call is made to the <a href="#defer_event"><code>defer_event</code></a>
member function of the state for which the reaction was defined.<br>
执行时，调用定义了该反应的状态的 <a href="reference.html#defer_event"><code>defer_event</code></a>
成员函数。</p>


<h1>Header &lt;boost/statechart/<a name="custom_reaction.hpp" id="custom_reaction.hpp">custom_reaction.hpp</a>&gt;</h1>


<h2><a name="ClassTemplatecustom_reaction" id="ClassTemplatecustom_reaction">Class template <code>custom_reaction </code>类模板 <code>custom_reaction</code></a></h2>


<p>This class template is used to specify a custom reaction.
Instantiations of this template can appear in the <code>reactions</code>
member <code>typedef</code> in models of the <a href="#SimpleState">SimpleState</a> and <a href="#State">State</a> concepts.<br>
这个类模板用于指定一个定制反应。该模板的实例可以出现在符合 <a href="reference.html#SimpleState">简
单状态</a> 和 <a href="reference.html#State">状态</a>
概念的类型的 <code>reactions</code> 成员 <code>typedef</code>
中。</p>


<h3>Class template <code>custom_reaction</code>
parameters 类模板 <code>custom_reaction</code> 的参数</h3>


<table summary="custom_reaction parameters" border="3" cellpadding="2" width="100%">


  <tbody>


    <tr>


      <td width="17%"><b>Template parameter 模板参数</b></td>


      <td width="56%"><b>Requirements 要求</b></td>


      <td width="24%"><b>Semantics 语义</b></td>


    </tr>


    <tr>


      <td width="17%"><code>Event</code></td>


      <td width="56%">A model of the <a href="#Event">Event</a>
concept or the class <code><a href="#Classevent_base">event_base</a><br>
      </code><code></code><code></code><code></code>符合 <a href="reference.html#Event">事件</a>
概念的类型或者为类 <code><a href="reference.html#Classevent_base">event_base</a></code></td>


      <td width="24%">The event triggering the custom
reaction. If <code><a href="#Classevent_base">event_base</a></code>
is specified, the custom reaction is triggered by all models of the <a href="#Event">Event</a> concept<br>
触发这个定制反应的事件。如果指定了 <code><a href="reference.html#Classevent_base">event_base</a></code>，
则该定制反应由所有符合 <a href="reference.html#Event">事件</a>
概念的类型触发</td>


    </tr>


  
  </tbody>
</table>


<h3>Class template <code>custom_reaction</code>
synopsis 类模板 <code>custom_reaction</code> 的摘要</h3>


<pre>namespace boost<br>{<br>namespace statechart<br>{<br> template&lt; class Event &gt;<br> class custom_reaction<br> {<br> // <i>implementation-defined 由实现定义</i><br>};<br>}<br>}<br></pre>


<h3>Class template <code>custom_reaction</code>
semantics 类模板 <code>custom_reaction</code> 的语义</h3>


<p>When executed, a call is made to the user-supplied <code>react</code>
member function of the state for which the reaction was defined. The <code>react</code>
member function must have the following signature:<br>
执行时，调用定义了该反应的状态中由用户提供的 <code>react</code> 成员函数。该 <code>react</code>
成员函数必须带有以下签名：</p>


<pre><a href="#Classresult">result</a> react( const Event &amp; );<br></pre>


<p>and must call exactly one of the following reaction functions
and return the obtained <code><a href="#Classresult">result</a></code>
object:<br>
并且必须调用以下反应函数中的某一个，返回得到的 <code><a href="reference.html#Classresult">result</a></code> 对象：</p>


<pre><a href="#Classresult">result</a> <a href="#discard_event">discard_event</a>();<br><a href="#Classresult">result</a> <a href="#forward_event">forward_event</a>();<br><a href="#Classresult">result</a> <a href="#defer_event">defer_event</a>();<br>template&lt; class DestinationState &gt;<br><a href="#Classresult">result</a> <a href="#transit1">transit</a>();<br>template&lt;<br> class DestinationState,<br> class TransitionContext,<br> class Event &gt;<br><a href="#Classresult">result</a> <a href="#transit2">transit</a>(<br> void ( TransitionContext::* )( const Event &amp; ),<br> const Event &amp; );<br><a href="#Classresult">result</a> <a href="#simple_state::terminate">terminate</a>();<br></pre>


<h1>Header &lt;boost/statechart/<a name="result.hpp" id="result.hpp">result.hpp</a>&gt;</h1>


<h2><a name="Classresult" id="Classresult">Class
<code>result 类</code>
<code>result</code></a></h2>


<p>Defines the nature of the reaction taken in a user-supplied <code>react</code>
member function (called when a <code><a href="#ClassTemplatecustom_reaction">custom_reaction</a></code>
is executed). Objects of this type are always obtained by calling one
of the reaction functions and must be returned from the <code>react</code>
member function immediately.<br>
定义在一个用户提供的 <code>react</code>
成员函数(在执行一个 <code><a href="reference.html#ClassTemplatecustom_reaction">custom_reaction</a></code>
时调用)中发生的反应的结果。该类型的对象总是通过调用某一个反应函数获得，而且必须立即从 <code>react</code>
成员函数返回。</p>




<pre>namespace boost<br>{<br>namespace statechart<br>{<br> class result<br> {<br> public:<br> <a href="#result0">result</a>( const result &amp; other );<br> <a href="#resultdtor">~result</a>();<br><br> private:<br> // Result objects are not assignable <br> // Result 对象不可赋值<br> result &amp; operator=( const result &amp; other );<br> };<br>}<br>}<br></pre>


<h3>Class <code>result</code> constructor and
destructor 类 <code>result</code> 的构造函数和析构函数</h3>


<pre><a name="result0" id="result0">result</a>( const result &amp; other );<br></pre>


<p><b>Requires</b>: <code>other</code>
is <b>not</b> consumed<br>


<b>要求：</b><code>other</code> 不是已消耗的<br>


<b>Effects</b>: Copy-constructs a new <code>result</code>
object and marks <code>other</code> as consumed. That is, <code>result</code>
has destructive copy semantics<br>
<b>作用：</b>复制构造一个新的 <code>result</code>
对象，并将 <code>other</code> 标记为已消耗。即，<code>result</code>
具有破坏性的复制语义</p>


<pre><a name="resultdtor" id="resultdtor">~result</a>();<br></pre>


<p><b>Requires</b>: <code>this</code> is
marked as consumed<br>


<b>要求：</b><code>this</code> 被标记为已消耗<br>


<b>Effects</b>: Destructs the result object<br>
<b>作用：</b>析构 result 对象</p>


<hr>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Transitional" border="0" height="31" width="88"></a></p><p>Revised 06 January, 2008</p>
<p><i>Copyright © 2003-2008 <a href="contact.html">Andreas Huber 
Dönni</a></i></p><p><i>Distributed under the Boost Software License, Version
1.0. (See accompanying file <a href="../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a>
or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</i></p>


</body></html>