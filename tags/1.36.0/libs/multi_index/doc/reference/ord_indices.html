<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0.1 Transitional//EN">
<html>
<head>









  
  
  
  
  
  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">










  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <title>Boost.MultiIndex Documentation - Ordered indices reference</title>
  <link rel="stylesheet" href="../style.css" type="text/css">









  
  
  
  
  
  
  
  
  <link rel="start" href="../index.html">









  
  
  
  
  
  
  
  
  <link rel="prev" href="indices.html">









  
  
  
  
  
  
  
  
  <link rel="up" href="index.html">









  
  
  
  
  
  
  
  
  <link rel="next" href="hash_indices.html">
</head>


<body>









<h1><img src="../../../../boost.png" alt="boost.png (6897 bytes)" align="middle" height="86" width="277">Boost.MultiIndex 有序索引参考</h1>










<div class="prev_link"><a href="indices.html"><img src="../prev.gif" alt="index reference" border="0"><br>









Index 参考
</a></div>









<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.MultiIndex reference" border="0"><br>









Boost.MultiIndex 参考
</a></div>









<div class="next_link"><a href="hash_indices.html"><img src="../next.gif" alt="hashed indices" border="0"><br>









Hashed indices散列索引
</a></div>








<br style="" clear="all">










<hr>

<h2>Contents目录</h2>










<ul>









  <li><a href="#ord_index_fwd_synopsis">头文件 <code>"boost/multi_index/ordered_index_fwd.hpp"</code> 摘要</a></li>









  <li><a href="#synopsis">头文件 <code>"boost/multi_index/ordered_index.hpp"</code> 摘要</a>
    
    
    
    
    
    
    
    
    
    <ul>









      <li><a href="#unique_non_unique">索引说明 <code>ordered_unique</code> 和 <code>ordered_non_unique</code>
        </a></li>









      <li><a href="#ord_indices">有序索引</a>
        
        
        
        
        
        
        
        
        
        <ul>









          <li><a href="#complexity_signature">复杂度署名</a></li>









          <li><a href="#instantiation_types">实例化的类型</a></li>









          <li><a href="#constructors">构造函数、复制和赋值</a></li>

          <li><a href="#iterators">迭代器Iterators</a></li>









          <li><a href="#modifiers">修饰器</a></li>









          <li><a href="#observers">观察员Observers</a></li>









          <li><a href="#set_operations">Set 操作</a></li>









          <li><a href="#range_operations">Range 操作</a></li>









          <li><a href="#serialization">序列化</a></li>









        
        
        
        
        
        
        
        
        
        </ul>









      </li>









    
    
    
    
    
    
    
    
    
    </ul>









  </li>









</ul>










<h2>
<a name="ord_index_fwd_synopsis">头文件 </a><a href="../../../../boost/multi_index/ordered_index_fwd.hpp"><code>"boost/multi_index/ordered_index_fwd.hpp"</code></a> 摘要</h2>










<blockquote>
  
  
  
  
  
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="comment">// 索引说明 ordered_unique 和 ordered_non_unique</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>consult ordered_unique reference for arguments</b><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ordered_unique</span><span class="special">;</span>
<span class="keyword">template</span><span class="special">&lt;</span><b>consult ordered_non_unique reference for arguments</b><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ordered_non_unique</span><span class="special">;</span>

<span class="comment">// 索引</span>

<span class="keyword">namespace</span> <span class="identifier">detail</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined</b><span class="special">&gt;</span> <span class="keyword">class</span> <b>index name is implementation defined</b><span class="special">;</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index::detail</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>








</blockquote>










<p>
<code>ordered_index_fwd.hpp</code> 提供了索引说明 
<a href="#unique_non_unique"><code>ordered_unique</code> 和 <code>ordered_non_unique</code></a> 的前向声明，以及它们的相关 <a href="#ord_indices">ordered index有序索引</a> 类。
</p>










<h2>
<a name="synopsis">头文件 </a><a href="../../../../boost/multi_index/ordered_index.hpp"><code>"boost/multi_index/ordered_index.hpp"</code></a> 摘要</h2>










<blockquote>
  
  
  
  
  
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="comment">// 索引说明 ordered_unique 和 ordered_non_unique</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>consult ordered_unique reference for arguments</b><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ordered_unique</span><span class="special">;</span>
<span class="keyword">template</span><span class="special">&lt;</span><b>consult ordered_non_unique reference for arguments</b><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ordered_non_unique</span><span class="special">;</span>

<span class="comment">// 索引</span>
<span class="keyword">namespace</span> <span class="identifier">detail</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined</b><span class="special">&gt;</span> <span class="keyword">class</span> <b>index class name implementation defined</b><span class="special">;</span>

<span class="comment">// 索引比较</span>

<span class="comment">// <b>OP</b> is any of ==,&lt;,!=,&gt;,&gt;=,&lt;=</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span> <b><i>OP</i></b><span class="special">(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="comment">// 索引特定算法：</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined</b><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index::detail</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>








</blockquote>










<h3><a name="unique_non_unique">索引说明 <code>ordered_unique</code> 和 <code>ordered_non_unique</code>
</a></h3>










<p>这两个 <a href="indices.html#index_specification">index specifiers索引说明</a>&nbsp;用于插入 <a href="#ord_indices">ordered indices有序索引</a>，分别表示是否允许重复的元素。<code>ordered_unique</code> 和 <code>ordered_non_unique</code> 的语法是一样的，我们将它们一起描述。<code>ordered_unique</code> 和 <code>ordered_non_unique</code> 可以以两种不同的形式来实例化，分别对应于是否对索引使用标志列表：
</p>










<blockquote>
  
  
  
  
  
  
  
  
  <pre><span class="keyword">template</span><span class="special">&lt;</span>
  <span class="keyword">typename</span> <span class="identifier">KeyFromValue</span><span class="special">,</span>
  <span class="keyword">typename</span> <span class="identifier">Compare</span><span class="special">=</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">KeyFromValue</span><span class="special">::</span><span class="identifier">result_type</span><span class="special">&gt;</span>
<span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="special">(</span><span class="identifier">ordered_unique</span> <span class="special">|</span> <span class="identifier">ordered_non_unique</span><span class="special">)</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span>
  <span class="keyword">typename</span> <span class="identifier">TagList</span><span class="special">,</span>
  <span class="keyword">typename</span> <span class="identifier">KeyFromValue</span><span class="special">,</span>
  <span class="keyword">typename</span> <span class="identifier">Compare</span><span class="special">=</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">KeyFromValue</span><span class="special">::</span><span class="identifier">result_type</span><span class="special">&gt;</span>
<span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="special">(</span><span class="identifier">ordered_unique</span> <span class="special">|</span> <span class="identifier">ordered_non_unique</span><span class="special">)</span><span class="special">;</span>
  </pre>








</blockquote>










<p>如果提供了 <code>TagList</code>，则必须是类模板
<a href="indices.html#tag"><code>tag</code></a> 的实例。相应的索引实现所使用的模板参数，请参见 <a href="#ord_indices">ordered indices有序索引</a> 参考一节，其中对于可接受的类型值有更多的解释。
</p>










<h3><a name="ord_indices">有序索引</a></h3>










<p>有序索引提供类似-set的接口来操作 multi_index_container 中的底层元素。有序索引通过给定的
<a href="key_extraction.html#key_extractors"><code>Key Extractor键提取器</code></a>
和一个比较谓词来说明，键提取器用于从 <code>multi_index_container</code> 的元素中提取键。
</p>










<p>有两种不同的有序索引：<span style="font-style: italic;">唯一的</span>，不允许重复的元素(依照相应的比较谓词)和<span style="font-style: italic;">非唯一的</span>，可以允许重复。两者的接口是一样的，所以在这里把它们一起说明，只在有不同的时候特别指出。
</p>










<p>除了特殊声明以外，有序索引(唯一及非唯一)依照了
<a href="http://www.sgi.com/tech/stl/SortedAssociativeContainer.html">
<code>Sorted Associative Container</code></a> 和
<a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">
<code>Unique Associative Container</code></a>, 正如 <code>std::set 一样。因此，迭代器及元素引用的有效性是被保护的。我们只对满足以下条件的类型和操作进行描述，它们要么没在前述两个概念模型中出现，要么不完全符合该类容器的要求。</code>
</p>










<blockquote>
  
  
  
  
  
  
  
  
  <pre><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span>

<span class="keyword">namespace</span> <span class="identifier">multi_index</span><span class="special">{</span>

<span class="keyword">namespace</span><span class="special">{</span> <b>implementation defined </b><span class="identifier">unbounded</span><span class="special">;</span> <span class="special">}</span> <span class="comment">// see range()</span>

<span class="keyword">namespace</span> <span class="identifier">detail</span><span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined: dependent on types Value, Allocator,<br>  TagList, KeyFromValue, Compare</b><span class="special">&gt;</span>
<span class="keyword">class</span> <b>name is implementation defined</b>
<span class="special">{</span> <br><span class="keyword">public</span><span class="special">:</span>
  <span class="comment">// 类型:</span>

  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">KeyFromValue</span><span class="special">::</span><span class="identifier">result_type</span>         <span class="identifier">key_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">Value</span>                                      <span class="identifier">value_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">KeyFromValue</span>                               <span class="identifier">key_from_value</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">Compare</span>                                    <span class="identifier">key_compare</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>implementation defined                     </b><span class="identifier">value_compare</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">key_from_value</span><span class="special">,</span><span class="identifier">key_compare</span><span class="special">&gt;</span>          <span class="identifier">ctor_args</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">Allocator</span>                                  <span class="identifier">allocator_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">::</span><span class="identifier">reference</span>              <span class="identifier">reference</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">::</span><span class="identifier">const_reference</span>        <span class="identifier">const_reference</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>implementation defined                     </b><span class="identifier">iterator</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>implementation defined                     </b><span class="identifier">const_iterator</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>implementation defined                     </b><span class="identifier">size_type</span><span class="special">;</span>      <br>  <span class="keyword">typedef</span> <b>implementation defined                     </b><span class="identifier">difference_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">::</span><span class="identifier">pointer</span>                <span class="identifier">pointer</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Allocator</span><span class="special">::</span><span class="identifier">const_pointer</span>          <span class="identifier">const_pointer</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>equivalent to<br>    std::reverse_iterator&lt;iterator&gt;</b>                  <span class="identifier">reverse_iterator</span><span class="special">;</span>
  <span class="keyword">typedef</span> <b>equivalent to<br>    std::reverse_iterator&lt;const_iterator&gt;</b>            <span class="identifier">const_reverse_iterator</span><span class="special">;</span>

  <span class="comment">// 构造/复制/析构:</span>

  <b>index class name</b><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>

  <span class="identifier">allocator_type</span> <span class="identifier">get_allocator</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// 迭代器:</span>

  <span class="identifier">iterator</span>               <span class="identifier">begin</span><span class="special">();</span>
  <span class="identifier">const_iterator</span>         <span class="identifier">begin</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">iterator</span>               <span class="identifier">end</span><span class="special">();</span>
  <span class="identifier">const_iterator</span>         <span class="identifier">end</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">reverse_iterator</span>       <span class="identifier">rbegin</span><span class="special">();</span>
  <span class="identifier">const_reverse_iterator</span> <span class="identifier">rbegin</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">reverse_iterator</span>       <span class="identifier">rend</span><span class="special">();</span>
  <span class="identifier">const_reverse_iterator</span> <span class="identifier">rend</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
 
  <span class="comment">// 容量:</span>

  <span class="keyword">bool</span>      <span class="identifier">empty</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <span class="identifier">size</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">size_type</span> <span class="identifier">max_size</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// 修饰器:</span>

  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span><span class="keyword">bool</span><span class="special">&gt;</span> <span class="identifier">insert</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="identifier">iterator</span> <span class="identifier">insert</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">InputIterator</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">insert</span><span class="special">(</span><span class="identifier">InputIterator</span> <span class="identifier">first</span><span class="special">,</span><span class="identifier">InputIterator</span> <span class="identifier">last</span><span class="special">);</span>

  <span class="identifier">iterator</span>  <span class="identifier">erase</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">);</span>
  <span class="identifier">size_type</span> <span class="identifier">erase</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">key_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="identifier">iterator</span>  <span class="identifier">erase</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">first</span><span class="special">,</span><span class="identifier">iterator</span> <span class="identifier">last</span><span class="special">);</span>

  <span class="keyword">bool</span> <span class="identifier">replace</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Modifier</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">modify</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="identifier">Modifier</span> <span class="identifier">mod</span><span class="special">);</span><br>  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Modifier</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Rollback</span><span class="special">&gt;</span><br>  <span class="keyword">bool</span> <span class="identifier">modify</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="identifier">Modifier</span> <span class="identifier">mod</span><span class="special">,</span><span class="identifier">Rollback</span> <span class="identifier">back</span><span class="special">);</span><br>  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Modifier</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">modify_key</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="identifier">Modifier</span> <span class="identifier">mod</span><span class="special">);</span><br>  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Modifier</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Rollback</span><span class="special">&gt;</span><br>  <span class="keyword">bool</span> <span class="identifier">modify_key</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span><span class="identifier">Modifier</span> <span class="identifier">mod</span><span class="special">,</span><span class="identifier">Rollback</span> <span class="identifier">back</span><span class="special">);</span><span class="special"></span>
  
  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">);</span>
  <span class="keyword">void</span> <span class="identifier">clear</span><span class="special">();</span>

  <span class="comment">// 观察员:</span>

  <span class="identifier">key_from_value</span> <span class="identifier">key_extractor</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">key_compare</span>    <span class="identifier">key_comp</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>
  <span class="identifier">value_compare</span>  <span class="identifier">value_comp</span><span class="special">()</span><span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// set 操作:</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">&gt;</span>
  <span class="identifier">iterator</span> <span class="identifier">find</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompatibleCompare</span><span class="special">&gt;</span>
  <span class="identifier">iterator</span> <span class="identifier">find</span><span class="special">(</span>
    <span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">CompatibleCompare</span><span class="special">&amp;</span> <span class="identifier">comp</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">&gt;</span>
  <span class="identifier">size_type</span> <span class="identifier">count</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompatibleCompare</span><span class="special">&gt;</span>
  <span class="identifier">size_type</span> <span class="identifier">count</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">CompatibleCompare</span><span class="special">&amp;</span> <span class="identifier">comp</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">&gt;</span>
  <span class="identifier">iterator</span> <span class="identifier">lower_bound</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompatibleCompare</span><span class="special">&gt;</span>
  <span class="identifier">iterator</span> <span class="identifier">lower_bound</span><span class="special">(</span>
    <span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">CompatibleCompare</span><span class="special">&amp;</span> <span class="identifier">comp</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">&gt;</span>
  <span class="identifier">iterator</span> <span class="identifier">upper_bound</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompatibleCompare</span><span class="special">&gt;</span>
  <span class="identifier">iterator</span> <span class="identifier">upper_bound</span><span class="special">(</span>
    <span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">CompatibleCompare</span><span class="special">&amp;</span> <span class="identifier">comp</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">&gt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span><span class="identifier">iterator</span><span class="special">&gt;</span> <span class="identifier">equal_range</span><span class="special">(</span>
    <span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">CompatibleKey</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">CompatibleCompare</span><span class="special">&gt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span><span class="identifier">iterator</span><span class="special">&gt;</span> <span class="identifier">equal_range</span><span class="special">(</span>
    <span class="keyword">const</span> <span class="identifier">CompatibleKey</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">CompatibleCompare</span><span class="special">&amp;</span> <span class="identifier">comp</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>

  <span class="comment">// range:</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">LowerBounder</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">UpperBounder</span><span class="special">&gt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span><span class="identifier">iterator</span><span class="special">&gt;</span> <span class="identifier">range</span><span class="special">(</span>
    <span class="identifier">LowerBounder</span> <span class="identifier">lower</span><span class="special">,</span><span class="identifier">UpperBounder</span> <span class="identifier">upper</span><span class="special">)</span><span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// 索引比较:</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">size</span><span class="special">()==</span><span class="identifier">y</span><span class="special">.</span><span class="identifier">size</span><span class="special">()&amp;&amp;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal</span><span class="special">(</span><span class="identifier">x</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier">x</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span><span class="identifier">y</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">lexicographical_compare</span><span class="special">(</span><span class="identifier">x</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier">x</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span><span class="identifier">y</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier">y</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!=(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="special">!(</span><span class="identifier">x</span><span class="special">==</span><span class="identifier">y</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">y</span><span class="special">&lt;</span><span class="identifier">x</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;=(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="special">!(</span><span class="identifier">x</span><span class="special">&lt;</span><span class="identifier">y</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>arg set 1</b><span class="special">,</span><b>arg set 2</b><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;=(</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 1</b><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span>
  <span class="keyword">const</span> <b>index class name</b><span class="special">&lt;</span><b>arg set 2</b><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="special">!(</span><span class="identifier">x</span><span class="special">&gt;</span><span class="identifier">y</span><span class="special">);</span>
<span class="special">}</span>

<span class="comment">// 索引特定算法:</span>

<span class="keyword">template</span><span class="special">&lt;</span><b>implementation defined</b><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span><b>index class name</b><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">);</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index::detail</span>

<span class="special">}</span> <span class="comment">// namespace boost::multi_index</span> <br><br><span class="special">}</span> <span class="comment">// namespace boost</span>
  </pre>








</blockquote>










<h4><a name="complexity_signature">复杂度署名</a></h4>










<p>在这里以及后续对有序索引的操作描述中，我们采用了在 
<a href="indices.html#complexity_signature">complexity signature 复杂度署名一节</a> 中的记法。有序索引的复杂度署名是：
</p>








<ul>









  <li>复制: <code>c(n)=n*log(n)</code>,</li>









  <li>插入: <code>i(n)=log(n)</code>,</li>









  <li>带提示的插入: <code>h(n)=1</code> (常量) 如果提示的元素在插入点之前，否则 <code>h(n)=log(n)</code>,</li>









  <li>删除: <code>d(n)=1</code> (分期常量),</li>









  <li>替换: <code>r(n)=1</code> (常量) 如果元素的位置不变，否则 <code>r(n)=log(n)</code>,</li>









  <li>更改: <code>m(n)=1</code> (常量) 如果元素的位置不变，否则 <code>m(n)=log(n)</code>.</li>









</ul>











<h4><a name="instantiation_types">实例化的类型</a></h4>










<p>有序索引在 <code>multi_index_container</code> 的内部进行实例化，并且使用带 <a href="#unique_non_unique">索引说明 <code>ordered_unique</code> 和 <code>ordered_non_unique</code></a> 的 <a href="indices.html#indexed_by"><code>indexed_by</code></a> 来指定。实例化依赖于以下类型：
</p>








<ul>









  <li><code>Value</code> 来自于 <code>multi_index_container</code>,</li>









  <li><code>Allocator</code> 来自于 <code>multi_index_container</code>,</li>









  <li><code>TagList</code> 来自于索引说明(如果有),</li>









  <li><code>KeyFromValue</code> 来自于索引说明,</li>









  <li><code>Compare</code> 来自于索引说明.</li>









</ul>









<code>TagList</code> 必须是
<a href="indices.html#tag"><code>tag</code></a> 的实例。类型 <code>KeyFromValue</code>,
用于指定从 Value 中取出键的方法，必须符合 <a href="key_extraction.html#key_extractors">
<code>Key Extractor</code></a> 且来自 <code>Value</code>. <code>Compare</code> 符合
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">
<code>Strict Weak Ordering严格弱序</code></a>，用于
<code>KeyFromValue::result_type</code> 元素<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html"><code></code></a>。


<h4><a name="constructors">构造函数、复制与赋值</a></h4>










<p>如 <a href="indices.html#index_concepts">index
concepts 索引概念一节</a> 中的说明，索引没有公有的构造函数或析构函数。但是赋值操作则有提供。
</p>










<code><b>index class name</b>&amp; operator=(const <b>index class name</b>&amp; x);</code>










<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b>
  
  
  
  
  
  
  
  
  <blockquote>
    
    
    
    
    
    
    
    
    <pre><span class="identifier">a</span><span class="special">=</span><span class="identifier">b</span><span class="special">;</span>
    </pre>








  </blockquote>








其中 <code>a</code> 和 <code>b</code> <code>分别</code>是 <code>*this</code> 和 <code>x</code>&nbsp;<code>所属的 multi_index_container</code>
对象。<br>









  <span style="font-weight: bold;">返回</span><b>:</b> <code>*this</code>.<br>

</blockquote>


<h4><a name="iterators">迭代器Iterators</a></h4>

<code>iterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator_to(const 
value_type&amp; x);<br>

const_iterator iterator_to(const value_type&amp; 
x)const;</code> 
<blockquote><b>要求：</b><code>x</code> 是容器中某个元素的引用。<br>

  <b>返回：</b>指向 
  <code>x</code> 的迭代器。<br>

  <b>复杂度：</b>常数。<br>

  <b>异常安全性：</b><code>不抛出异常。</code><br>

</blockquote>

<h4><a name="modifiers">修饰器</a></h4>










<code>std::pair&lt;iterator,bool&gt; insert(const value_type&amp; x);</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 插入 <code>x</code> 到索引所属的 <code>multi_index_container</code>，如果
  
  
  
  
  
  
  
  
  <ul>









  <li>索引是非唯一的，或者容器中不存在相等键值的元素，</li>









  <li>并且插入操作对于
    <code>multi_index_container</code> 的其它所有索引都允许。</li>









  
  
  
  
  
  
  
  
  </ul>









  <span style="font-weight: bold;">返回</span><b>:</b> 返回值是一个 pair <code>p</code>. <code>当且仅当插入成功时，p.second</code>
为真。插入成功时，<code>p.first</code> 指向被插入元素；否则 <code>p.first</code>
指向导致插入失败的某个元素。注意，可能有多于一个的元素导致插入失败。<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(I(n))</code>.<br>









  <b>异常安全性:</b> 强。<br>









</blockquote>










<code>iterator insert(iterator position,const value_type&amp; x);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 是索引的一个有效迭代器。<span style="font-weight: bold;"><br>








效果</span><b>:</b> 插入 <code>x</code> 到索引所属的 <code>multi_index_container</code>，如果
  
  
  
  
  
  
  
  
  <ul>









  <li>索引是非唯一的，或者容器中不存在相等键值的元素，</li>








    <li>并且插入操作对于
    <code>multi_index_container</code> 的其它所有索引都允许。</li>








  
  
  
  
  
  
  
  
  </ul>









  <code>position</code> 用于提示和提高操作的效率。<br>









  <span style="font-weight: bold;">返回</span><b>:</b> 插入成功时，返回新插入元素的迭代器。否则，返回导致失败的元素的迭代器。注意，可能有多于一个的元素导致插入失败。<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(H(n))</code>.<br>









  <b>异常安全性:</b> 强。<br>









</blockquote>










<code>template&lt;typename InputIterator&gt;<br>









void insert(InputIterator first,InputIterator last);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>InputIterator</code> 为
  <a href="http://www.sgi.com/tech/stl/InputIterator.html">
  <code>Input Iterator输入迭代器</code></a>，其元素类型为
  <code>value_type</code> 或可转换为 <code>value_type</code>.
  <code>first</code> 和 <code>last</code> 不是索引所属的 <code>multi_index_container</code> 的任意索引的迭代器。<code>last</code> 可以从 <code>first</code> 到达。<br>








  <span style="font-weight: bold;">效果</span><b>:</b>
  
  
  
  
  
  
  
  
  <blockquote>
    
    
    
    
    
    
    
    
    <pre><span class="identifier">iterator</span> <span class="identifier">hint</span><span class="special">=</span><span class="identifier">end</span><span class="special">();</span>
<span class="keyword">while</span><span class="special">(</span><span class="identifier">first</span><span class="special">!=</span><span class="identifier">last</span><span class="special">)</span><span class="identifier">hint</span><span class="special">=</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">hint</span><span class="special">,*</span><span class="identifier">first</span><span class="special">++);</span>
    </pre>








  </blockquote>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(m*H(n+m))</code>, <code>m</code> 为 [<code>first</code>,
  <code>last</code>) 中的元素数量。<br>









  <b>异常安全性:</b> 基本。<br>









</blockquote>










<code>iterator erase(iterator position);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 是索引的一个有效的可提领的迭代器。<span style="font-weight: bold;"><br>







效果</span><b>:</b> 删除 <code>position</code> 所指向的元素。<br>









  <span style="font-weight: bold;">返回</span><b>:</b> 返回一个迭代器，指向紧跟在被删元素之后的元素，或者 <code>end()</code>
如果没有这样的元素。<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(D(n))</code>.<br>









  <b>异常安全性:</b> 不抛出异常。<br>









</blockquote>










<code>size_type erase(const key_type&amp; x);</code>

<blockquote>
  <span style="font-weight: bold;">效果</span><b>:</b> 删除键值为 x 的元素。<br>









  <b>返回:</b> 删除的元素数量。<br>









  <b>复杂度:</b> <code>O(log(n) + m*D(n))</code>,&nbsp;<code>m</code> 为删除的元素数量。<br>









  <b>异常安全性:</b> 基本。<br>









</blockquote>










<code>iterator erase(iterator first,iterator last);</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> [<code>first</code>,<code>last</code>) 是索引的有效区间。<br>









  <b>效果:</b> 删除 [<code>first</code>,<code>last</code>) 中的元素。<br>









  <span style="font-weight: bold;">返回</span><b>:</b> <code>last</code>.<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(log(n) + m*D(n))</code>,&nbsp;<code>m</code> 为 [<code>first</code>,<code>last</code>) 中的元素数量。<br>









  <b>异常安全性:</b> 不抛出异常。<br>









</blockquote>










<a name="replace"><code>bool replace(iterator position,const value_type&amp; x);</code></a>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>position</code> 是索引的一个有效可提领迭代器。<span style="font-weight: bold;"><br>







  </span><b>效果:</b> 把值 <code>x</code> 赋给 <code>position</code> 所指的元素，元素位于索引所属的 <code>multi_index_container，如果</code><code></code>
  
  
  
  
  
  
  
  
  <ul>









  <li>索引是非唯一的或者没有其它元素(除了 <code>*position</code>)具有相等的键值，</li>









  <li>并且替换被
    <code>multi_index_container</code> 的所有其它索引允许。</li>









  
  
  
  
  
  
  
  
  </ul>









  <span style="font-weight: bold;">后续条件</span><b>:</b> 在所有情况下，<code>position</code> 的有效性被保证。<br>









  <b>返回:</b> <code>true</code> 如果替换发生，否则返回 <code>false</code>.<br>









  <b>复杂度:</b> <code>O(R(n))</code>.<br>









  <b>异常安全性:</b><b></b> 强。如果某个用户提供的操作抛出异常，索引所属的 <code>multi_index_container</code> 将保持原有状态。
</blockquote>









  
<a name="modify">
<code>template&lt;typename Modifier&gt; bool modify(iterator position,Modifier mod);</code></a>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>mod 为</code>
  <a href="http://www.sgi.com/tech/stl/UnaryFunction.html">
  <code>Unary Function一元函数</code></a>，接受类型为
  <code>value_type&amp;</code> 的参数。<code>position</code> 为索引的一个有效可提领迭代器。<br>







  <b>效果:</b> 调用 <code>mod(e)</code>，其中 <code>e</code> 是 <code>position</code> 所指的元素，并对 <code>multi_index_container</code> 的所有索引重排 <code>*position</code>。重排将在满足以下条件时成功：
  
  
  
  
  
  
  
  
  <ul>









  <li>索引是非唯一的或者没有其它元素具有相等的键值，</li>









  <li>并且重排被 <code>multi_index_container</code> 的所有索引所允许。</li>









  
  
  
  
  
  
  
  
  </ul>







如果重排失败，该元素将被删除。<br>









  <b>后续条件:</b> 如果操作成功，<code>position</code> 的有效性将被保证。<br>









  <b>返回:</b> <code>true</code> 如果操作成功，否则返回 <code>false</code>.<br>









  <b>复杂度:</b> <code>O(M(n))</code>.<br>









  <b>异常安全性:</b> 基本。如果用户提供的操作(除了 <code>mod 以外</code>)抛出异常，则 <code>position</code> 所指元素将被删除。
</blockquote>










    
<code>template&lt;typename Modifier,typename Rollback&gt;<br>

bool 
modify(iterator position,Modifier mod,Rollback back);</code> 
<blockquote><b>要求：</b><code>Modifier</code> 和 <code>Rollback</code> 均为 <a href="http://www.sgi.com/tech/stl/UnaryFunction.html"><code>Unary 
Function一元函数</code></a>，接受类型为 <code>value_type&amp;</code> 的参数。<code>position</code> 为索引的一个有效可提领迭代器。顺序操作 <code>mod(e)</code>, <code>back(e)</code>, 其中 
  <code>e</code> 为 <code>position</code> 所指向的元素，可以将元素的所有键恢复为原来的状态。<br>

  <b>作用：</b>调用 <code>mod(e)</code>，其中 <code>e</code> 是 <code>position</code> 所指的元素，并对 <code>multi_index_container</code> 的所有索引重排 <code>*position</code>。重排将在满足以下条件时成功：
  
  
  
  
  
  
  
  
  <ul>
    <li>索引是非唯一的或者没有其它元素具有相等的键值，</li>
    <li>并且重排被 <code>multi_index_container</code> 的所有索引所允许。</li>
  </ul>







如果重排失败，则 <code>back(e)</code> 被调用，该元素的所有索引恢复到原来的位置。<br>









  <b>后续条件:</b>&nbsp;<code>position</code> 的有效性将被保证，除非在下述情况下元素被删除。<br>









  <b>返回:</b> <code>true</code> 如果操作成功，否则返回 <code>false</code>.<br>









  <b>复杂度:</b> <code>O(M(n))</code>.<br>









  <b>异常安全性:</b> 强，除非 
  <code>back</code> 抛出异常，这种情况下已修改元素将被删除。如果 <code>back</code> 是在用户提供的操作抛出异常后的处理代码中抛出的，则由 
  <code>back</code> 生成的异常被重抛出。 </blockquote>

<a name="modify_key"><code>template&lt;typename Modifier&gt; bool modify_key(iterator position,Modifier mod);</code></a>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>key_from_value</code> 是一个用于 <code>value_type</code> 的读/写
  <a href="key_extraction.html#key_extractors"><code>Key Extractor键提取器</code></a>。<code>Modifier</code> 是
  <a href="http://www.sgi.com/tech/stl/UnaryFunction.html">
  <code>Unary Function一元函数</code></a>，接受类型为 <code>key_type&amp; 的参数</code>。<code>position</code> 是索引的有效可提领迭代器。<span style="font-weight: bold;"><br>







效果</span><b>:</b> 调用 <code>mod(k)</code>，<code>k</code> 为通过索引内部的 <code>KeyFromValue</code> 对象从 <code>position 所指元素取得的键值，并对</code> <code>multi_index_container</code><code> 的所有索引重排</code>
  <code>*position。</code>重排将在满足以下条件时成功：
  
  
  
  
  
  
  
  
  <ul>







    <li>索引是非唯一的或者没有其它元素具有相等的键值，</li>







    <li>并且重排被 <code>multi_index_container</code> 的所有索引所允许。</li>







  
  
  
  
  
  
  
  </ul>







如果重排失败，该元素将被删除。<br>









  <b>后续条件:</b> 如果操作成功，<code>position</code> 的有效性将被保证。<br>









  <b>返回:</b> <code>true</code> 如果操作成功，否则返回 <code>false</code>.<br>









  <b>复杂度:</b> <code>O(M(n))</code>.<br>









  <b>异常安全性:</b> 基本。如果用户提供的操作(除了 <code>mod 以外</code>)抛出异常，则 <code>position</code> 所指元素将被删除。
</blockquote>










<h4 style="font-weight: normal;"><code>template&lt;typename Modifier,typename Rollback&gt;<br>

bool 
modify_key(iterator position,Modifier mod,Rollback back);</code> 
</h4>

<blockquote><span style="font-weight: bold;">要求</span><b>:</b> <code>key_from_value</code> 是一个用于 <code>value_type</code> 的读/写
  <a href="key_extraction.html#key_extractors"><code>Key Extractor键提取器</code></a>。<code>Modifier</code><code></code> 和 <code>Rollback</code> 是
  <a href="http://www.sgi.com/tech/stl/UnaryFunction.html">
  <code>Unary Function一元函数</code></a>，接受类型为 <code>key_type&amp; 的参数</code>。<code>position</code> 是索引的有效可提领迭代器。顺序操作 <code>mod(k)</code>, <code>back(k)</code>, 其中 <code>k</code> 为 <code>position</code> 所指向的元素的键，可以将 k 恢复为原来的状态。<span style="font-weight: bold;"></span><br>

  <span style="font-weight: bold;">效果：</span>等价于 <code>modify(position,mod',back')</code>, 其中 <code>mod'</code> 和 
  <code>back</code> 按如下方式定义，<code>mod'(x)</code> 等同于 
  <code>mod(key(x))</code> 而 <code>back'(x)</code> 等同于 
  <code>back(key(x))</code>, 其中 <code>key</code> 是索引内部的 
  <code>KeyFromValue</code> 对象。 </blockquote>

<h4><a name="observers">观察员</a></h4>










<p>除了标准的 <code>key_comp</code> 和 <code>value_comp</code>,
有序索引还有一个成员函数用于取出内部使用的键提取器。
</p>










<code>key_from_value key_extractor()const;</code>

<blockquote>返回用于构造索引的 <code>key_from_value</code> 对象的拷贝。<br>









  <b>复杂度:</b> 常量时间。
</blockquote>










<h4><a name="set_operations">Set 操作</a></h4>










<p>有序索引提供了
<a href="http://www.sgi.com/tech/stl/SortedAssociativeContainer.html">
<code>Sorted Associative Containers</code></a> 和
<a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">
<code>Unique Associative Containers</code></a> 所要求的所有查找功能，即 <code>find</code>,
<code>count</code>, <code>lower_bound</code>, <code>upper_bound</code> 和 <code>equal_range</code>. 另外，这些成员函数被模板化，允许非标准的参数，允许扩展搜索操作的类型。调用查找成员函数时允许的参数种类被定义为以下概念。
</p>










<p>考虑类型 Key 的一个
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">
<code>Strict Weak Ordering严格弱序</code></a>&nbsp;<code>Compare</code>。一对类型 (<code>CompatibleKey</code>, 
<code>CompatibleCompare</code>) 被称为 <code>Compare 的</code>&nbsp;<i>兼容扩展</i><code></code>，如果：
</p>








<ol>









  <li><code>CompatibleCompare</code> 是 (<code>Key</code>,
    <code>CompatibleKey</code>)&nbsp;上的
    <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">
    <code>Binary Predicate二元谓词</code></a>，</li>









  <li><code>CompatibleCompare</code> 是 (<code>CompatibleKey</code>,
    <code>Key</code>) 上的
    <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">
    <code>Binary Predicate二元谓词</code></a>，</li>









  <li>如果 <code>c_comp(ck,k1)</code> 则 <code>!c_comp(k1,ck)</code>,</li>









  <li>如果 <code>!c_comp(ck,k1)</code> 且 <code>!comp(k1,k2)</code> 则
    <code>!c_comp(ck,k2)</code>,</li>









  <li>如果 <code>!c_comp(k1,ck)</code> 且 <code>!comp(k2,k1)</code> 则
    <code>!c_comp(k2,ck)</code>,</li>









</ol>






其中，c_comp 的类型为 <code>CompatibleCompare</code><code></code><span style="font-family: monospace;">，comp 的类型为</span> <code>Compare</code>，ck 的类型为
<code>CompatibleKey</code><code>，k1,k2 的类型为</code>
<code>Key</code><code></code><code></code>。




<p>另外，类型 <code>CompatibleKey</code> 被称为 <code>Compare</code> 的&nbsp;<i>兼容键</i>，如果 (<code>CompatibleKey</code>,
<code>Compare</code>) 为 <code>Compare 的兼容扩展。这意味着</code> <code>Compare 作为一个严格弱序，接受类型为</code> <code>CompatibleKey 的参数，因此通常它有多个</code> <code>operator() 的重载。</code>
</p>










<p>在兼容扩展或兼容键的上下文中，表达式
"相等", "小于" 和 "大于" 是通常的意义。
</p>










<code>template&lt;typename CompatibleKey&gt; iterator find(const CompatibleKey&amp; x)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>CompatibleKey</code> 为
  <code>key_compare 的兼容键。<br>






  </code><span style="font-weight: bold;">效果</span><b>:</b> 返回一个元素的指针，该元素的键与 x 相等，或者返回 <code>end()</code> 如果没有这样的元素。<br>









  <b>复杂度:</b> <code>O(log(n))</code>.<br>









</blockquote>










<code>template&lt;typename CompatibleKey,typename CompatibleCompare&gt;<br>









iterator find(const CompatibleKey&amp; x,const CompatibleCompare&amp; comp)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> (<code>CompatibleKey</code>, <code>CompatibleCompare</code>)
为 <code>key_compare 的兼容扩展。</code><br>






  <span style="font-weight: bold;">效果</span><b>:</b> 返回一个元素的指针，该元素的键与 x 相等，或者返回 <code>end()</code> 如果没有这样的元素。<br>









  <b>复杂度:</b> <code>O(log(n))</code>.<br>









</blockquote>










<code>template&lt;typename CompatibleKey&gt; size_type<br>









count(const CompatibleKey&amp; x)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>CompatibleKey</code> 为
  <code>key_compare 的兼容键。<br>






  </code><span style="font-weight: bold;">效果</span><b>:</b> 返回与 x 相等的元素数量。<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(log(n) + count(x))</code>.<br>









</blockquote>










<code>template&lt;typename CompatibleKey,typename CompatibleCompare&gt;<br>









size_type count(const CompatibleKey&amp; x,const CompatibleCompare&amp; comp)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> (<code>CompatibleKey</code>, <code>CompatibleCompare</code>)
为 <code>key_compare 的兼容扩展。</code><br>






  <span style="font-weight: bold;">效果</span><b>:</b><b></b> 返回与 x 相等的元素数量。<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(log(n) + count(x))</code>.<br>









</blockquote>










<code>template&lt;typename CompatibleKey&gt;<br>









iterator lower_bound(const CompatibleKey&amp; x)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>CompatibleKey</code> 为
  <code>key_compare 的兼容键。<br>






  </code><span style="font-weight: bold;">效果</span><b>:</b><b></b> 返回一个迭代器，指向键值不小于 x 的第一个元素，或者返回 <code>end()</code> 如果这样的元素不存在。<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(log(n))</code>.<br>









</blockquote>










<code>template&lt;typename CompatibleKey,typename CompatibleCompare&gt;<br>









iterator lower_bound(const CompatibleKey&amp; x,const CompatibleCompare&amp; comp)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> (<code>CompatibleKey</code>, <code>CompatibleCompare</code>)
为 <code>key_compare 的兼容扩展。</code><br>






  <span style="font-weight: bold;">效果</span><b>:</b><b></b> 返回一个迭代器，指向键值不小于 x 的第一个元素，或者返回 <code>end()</code> 如果这样的元素不存在。<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(log(n))</code>.<br>









</blockquote>










<code>template&lt;typename CompatibleKey&gt;<br>









iterator upper_bound(const CompatibleKey&amp; x)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>CompatibleKey</code> 为
  <code>key_compare 的兼容键。<br>






  </code><span style="font-weight: bold;">效果</span><b>:</b> 返回一个迭代器，指向键值大于 x 的第一个元素，或者返回 <code>end()</code> 如果这样的元素不存在。<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(log(n))</code>.<br>









</blockquote>










<code>template&lt;typename CompatibleKey,typename CompatibleCompare&gt;<br>









iterator upper_bound(const CompatibleKey&amp; x,const CompatibleCompare&amp; comp)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> (<code>CompatibleKey</code>, <code>CompatibleCompare</code>)
为 <code>key_compare 的兼容扩展。</code><br>






  <span style="font-weight: bold;">效果</span><b>:</b><b></b> 返回一个迭代器，指向键值大于 x 的第一个元素，或者返回 <code>end()</code> 如果这样的元素不存在。<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(log(n))</code>.<br>









</blockquote>










<code>template&lt;typename CompatibleKey&gt;<br>









std::pair&lt;iterator,iterator&gt; equal_range(<br>









&nbsp;&nbsp;const CompatibleKey&amp; x)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>CompatibleKey</code> 为
  <code>key_compare 的兼容键。<br>






  </code><span style="font-weight: bold;">效果</span><b>:</b><b></b> 等价于 <code>make_pair(lower_bound(x),upper_bound(x))</code>.<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(log(n))</code>.<br>









</blockquote>










<code>template&lt;typename CompatibleKey,typename CompatibleCompare&gt;<br>









std::pair&lt;iterator,iterator&gt; equal_range(
&nbsp;&nbsp;const CompatibleKey&amp; x,const CompatibleCompare&amp; comp)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> (<code>CompatibleKey</code>, <code>CompatibleCompare</code>)
为 <code>key_compare 的兼容扩展。</code><br>






  <span style="font-weight: bold;">效果</span><b>:</b><b></b> 等价于
  <code>make_pair(lower_bound(x,comp),upper_bound(x,comp))</code>.<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(log(n))</code>.<br>









</blockquote>











<h4><a name="range_operations">Range 操作</a></h4>










<p>对于有序关联式容器，并没有定义成员函数 <code>range</code>，但是有序索引则提供了它，以便于使用。范围或区间由下界和上界两个条件所定义，符合以下概念。
</p>










<p>考虑类型 Key 的一个
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">
<code>Strict Weak Ordering严格弱序</code></a> <code>Compare。类型</code> <code>LowerBounder</code> 被称为 <code>Compare</code> 的<span style="font-style: italic;">下界绑定器</span>，如果：
</p>








<ol>









  <li><code>LowerBounder</code> 是 Key 的一个
    <a href="http://www.sgi.com/tech/stl/Predicate.html">
    <code>Predicate谓词</code></a><code></code>,</li>









  <li>如果 <code>lower(k1)</code> 且 <code>!comp(k2,k1)</code> 则
    <code>lower(k2)</code>,</li>









</ol>






其中 <code>lower</code> 的类型为 <code>LowerBounder</code>,
<code>comp</code> 的类型为 <code>Compare</code>,&nbsp;<code>k1</code>,
<code>k2</code> 的类型为 <code>Key</code>. 相似的，类型&nbsp;<code>UpperBounder 被称为<span style="font-style: italic;">上界绑定器</span></code>则有：
<ol>









  <li><code>UpperBounder</code>&nbsp;是 Key 的一个
    <a href="http://www.sgi.com/tech/stl/Predicate.html">
    <code>Predicate谓词</code></a><code></code>,</li>









  <li>如果 <code>upper(k1)</code> 且 <code>!comp(k1,k2)</code> 则
    <code>upper(k2)</code>,</li>









</ol>






其中 <code>upper</code> 的类型为 <code>UpperBounder</code>,
<code>comp</code> 的类型为 <code>Compare</code>,&nbsp;<code>k1</code>,
<code>k2</code> 的类型为 <code>Key</code>.


<br>






<br>






<code>template&lt;typename LowerBounder,typename UpperBounder&gt;<br>









std::pair&lt;iterator,iterator&gt; range(LowerBounder lower,UpperBounder upper)const;
</code>

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> <code>LowerBounder</code> 和 <code>UpperBounder</code> 分别为 <code>key_compare 的下界和上界绑定器。</code><br>






  <b>效果:</b> 返回一对迭代器，分别指向同时满足下界和上界条件的第一个元素和最后一个元素的下一个。如果这样的元素不存在 ，则迭代器均指向满足下界条件的第一个元素，如果这种元素也不存在，则迭代器均为 <code>end()</code>。<br>









  <span style="font-weight: bold;">复杂度</span><b>:</b> <code>O(log(n))</code>.<br>









  <span style="font-weight: bold;">变种</span><b>:</b> 作为 <code>lower</code> 或 <code>upper</code> (或两者)的替代，可以使用单个值 <code>boost::multi_index::unbounded</code>. 相当于类型为 key_type的所有值都满足谓词。<br>









</blockquote>










<h4><a name="serialization">序列化</a></h4>










<p>索引不可以自行序列化，只能作为所嵌入的
<code>multi_index_container</code> 的一部分。在描述有序索所属容器的序列化所要满足的前提条件和相关保证时，我们使用在 <code>multi_index_container</code>
<a href="multi_index_container.html#serialization">序列化一节</a> 中定义的概念。
</p>










操作: 保存一个 <code>multi_index_container</code> <code>m</code> 到一个输出档案(XML档案) <code>ar</code>.

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> 没有额外的要求。
</blockquote>






操作: 从一个输入档案(XML档案) <code>ar 导入一个</code> <code>multi_index_container</code> <code>m</code><code></code><code>'</code>.

<blockquote>
  <b>要求:</b> 有额外要求，<code>value_comp()</code> 必须与 <code>m.get&lt;i&gt;().value_comp()</code> 序列化兼容,
其中 <code>i</code> 为有序索引在容器中的位置。<br>









  <b>后续条件:</b> 若导入成功，[<code>begin()</code>, <code>end()</code>) 的每个元素为 [<code>m.get&lt;i&gt;().begin()</code>, <code>m.get&lt;i&gt;().end()</code>) 中各对应元素的恢复拷贝。
</blockquote>










操作: 保存一个迭代器或常量性迭代器
<code>it </code>到一个输出档案(XML档案) <code>ar</code><code></code>.

<blockquote>
  <span style="font-weight: bold;">要求</span><b>:</b> 
  <code>it </code>须为索引的有效迭代器。相应的
  <code>multi_index_container</code> 在之前已保存。
</blockquote>






操作: 从一个输入档案(XML档案) <code>ar 导入一个</code>代器或常量性迭代器 <code>it'</code><code></code>.

<blockquote>
  <span style="font-weight: bold;">后续条件</span><b>:</b>&nbsp;导入成功时，若
  <code>it </code>可提领则 <code>*it'</code> 为 <code>*it 的恢复拷贝</code>, 否则
  <code>it'==end()</code>.<br>









  <span style="font-weight: bold;">注意</span><b>:</b> 允许以下情况，<code>it</code> 为常量性迭代器而恢复的 <code>it'</code> 为迭代器，或反之。
</blockquote>










<hr>

<div class="prev_link"><a href="indices.html"><img src="../prev.gif" alt="index reference" border="0"><br>









Index 参考
</a></div>









<div class="up_link"><a href="index.html"><img src="../up.gif" alt="Boost.MultiIndex reference" border="0"><br>









Boost.MultiIndex 参考
</a></div>









<div class="next_link"><a href="hash_indices.html"><img src="../next.gif" alt="hashed indices" border="0"><br>






散列索引
</a></div>








<br style="" clear="all">










<br>

<p>Revised July 2nd 2007</p>


<p>&copy; Copyright 2003-2007 Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz. Distributed under the Boost 
Software License, Version 1.0. (See accompanying file <a href="../../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>) 
</p>

</body>
</html>
